<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/posts/7a6a6b5a.html"/>
    <url>/posts/7a6a6b5a.html</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章。<br>lalala</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SAT问题及DPLL简述</title>
    <link href="/posts/935b2a8c.html"/>
    <url>/posts/935b2a8c.html</url>
    
    <content type="html"><![CDATA[<h2 id="聊聊SAT问题是什么"><a href="#聊聊SAT问题是什么" class="headerlink" title="聊聊SAT问题是什么"></a>聊聊SAT问题是什么</h2><blockquote><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3></blockquote><p>SAT问题又称命题逻辑公式的可满足性问题（satisfiability problem），是判断对合取范式形式给出的命题逻辑公式是否存在一个真值指派使得该逻辑公式为真。SAT问题是计算机科学与人工智能基本问题，是一个典型的NP完全问题。看似简单，却可广泛应用于许多实际问题如人工智能、电子设计自动化、自动化推理、硬件设计、安全协议验证等，具有重要理论意义与应用价值。对于SAT问题的研究从没有停止过，在1997年和2003年，H.Kautz与B.Selman两次列举出SAT搜索面临的挑战性问题，并于2011年和2007年，两度对当时的SAT问题研究现状进行了全面的综述。黄文奇提出的Solar算法在北京第三届SAT问题快速算法比赛中获得第一名。对SAT问题的求解主要有完备算法和不完备算法两大类。不完备算法主要是局部搜索算法，这种算法不能保证一定找到解，但是求解速度快，对于某些SAT问题的求解，局部搜索算法要比很多完备算法更有效。完备算法出现的时间更早，优点是可以正确判断SAT问题的可满足性，在算例无解的情况下可以给出完备的证明。对于求解SAT问题的优化算法主要有启发式算法、冲突子句学习算法、双文字监视法等。</p><blockquote><h3 id="研究意义"><a href="#研究意义" class="headerlink" title="研究意义"></a>研究意义</h3></blockquote><p>SAT问题是第一个被证明的NP完全问题，而NP完全问题由于其极大的理论价值和困难程度，破解后将会在许多领域得到广泛应用，从而在计算复杂性理论中具有非常重要的地位。由于所有的NP完全问题都能够在多项式时间内进行转换，那么如果SAT问题能够得到高效解决，所有的NP完全问题都能够在多项式时间内得到解决。对SAT问题的求解，可用于解决计算机和人工智能领域内的CSP问题（约束满足问题）、语义信息的处理和逻辑编程等问题，也可用于解决计算机辅助设计领域中的任务规划与设计、三维物体识别等问题。SAT问题的应用领域非常广泛，还能用于解决数学研究和应用领域中的旅行商问题和逻辑算数问题。许多实际问题，例如数据库检索、积木世界规划、超大规模集成电路设计、人工智能等都可以转换成SAT问题进而进行求解。可见对SAT问题求解的研究，具有重大意义。</p><blockquote><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3></blockquote><p>SAT问题即命题逻辑公式的可满足性问题（satisfiability problem），是计算机科学与人工智能基本问题，是一个典型的NP完全问题，可广泛应用于许多实际问题如硬件设计、安全协议验证等，具有重要理论意义与应用价值。SAT问题也是程序设计与竞赛的经典问题。<br>对于任一布尔变元x，x与其非“¬x”称为文字(literal)。对于多个布尔变元，若干个文字的或运算l1∨l2∨…∨lk称为子句(clause)。只含一个文字的子句称为单子句。不含任何文字的子句称为空子句，常用符号□表示。子句所含文字越多，越易满足，空子句不可满足。<br>SAT问题一般可描述为：给定布尔变元集合{x1, x2, …, xn}以及相应的子句集合{c1, c2, …, cm}，对于合取范式（CNF范式）：F = c1∧c2∧…∧cm，判定是否存在对每个布尔变元的一组真值赋值使F为真，当为真时（问题是可满足的，SAT），输出对应的变元赋值（一组解）结果。<br>一个CNF公式也可以表示成子句集合的形式：S={c1,c2,…,cm}.<br>例如，由三个布尔变元a,b,c所形成的一个CNF公式（¬a∨b）∧（¬b∨c）,可用集合表示为{¬a∨b,¬b∨c}，该公式是满足的，a=0, b=0,c=1是其一组解。 </p><blockquote><h3 id="cnf文件解读"><a href="#cnf文件解读" class="headerlink" title="cnf文件解读"></a>cnf文件解读</h3></blockquote><p>一个CNF SAT公式或算例的具体信息通常存储在一个.cnf文件中，下图是算例problem1.cnf文件前若干行的截图。</p><p><img src="https://user-images.githubusercontent.com/73998546/133534700-41b7c5f8-9448-4cea-a079-763b69aa4988.png" alt="1(1)"></p><p>在每个CNF文件的开始，由‘c’开头的是若干注释说明行；‘p’开头的行说明公式的总体信息，包括：范式为CNF；公式有200个布尔变元，由1到200的整数表示；320个子句。之后每行对应一个子句，0为结束标记。46表示第46号变元，且为正文字；-46则是对应的负文字，文字之间以空格分隔。</p><p>DPLL算法是经典的SAT完备型求解算法，对给定的一个SAT问题实例，理论上可判定其是否满足，满足时可给出对应的一组解。</p><h2 id="DPLL算法是什么呢"><a href="#DPLL算法是什么呢" class="headerlink" title="DPLL算法是什么呢"></a>DPLL算法是什么呢</h2><p>DPLL算法是基于树/二叉树的回溯搜索算法，主要使用两种基本处理策略：</p><p>单子句规则。如果子句集S中有一个单子句L,那么L一定取真值，于是可以从S中删除所有包含L的子句（包括单子句本身），得到子句集S1，如果它是空集，则S可满足。否则对S1中的每个子句，如果它包含文字¬L,则从该子句中去掉这个文字，这样可得到子句集合S2。S可满足当且仅当S2可满足。单子句传播策略就是反复利用单子句规则化简S的过程。</p><p>分裂策略。按某种策略选取一个文字L.如果L取真值，则根据单子句传播策略，可将S化成S2；若L取假值（即¬L成立）时，S可化成S1.</p><p>交错使用上述两种策略可不断地对公式化简，并最终达到终止状态，其执行过程可表示为一棵二叉搜索树,如下图所示。</p><p><img src="https://user-images.githubusercontent.com/73998546/133535483-b924184a-7b00-4034-9e67-5489e8e7cec1.png" alt="1(2)"></p><p>基于单子句传播与分裂策略的DPLL算法可以描述为一个如后所示的递归过程DPLL( S ), DPLL算法也可用非递归实现。</p><div class="hljs code-wrapper"><pre><code>DPLL( S) :/* S为公式对应的子句集。若其满足，返回TURE；否则返回FALSE. */&#123;while(S中存在单子句) &#123;//单子句传播在S中选一个单子句L；依据单子句规则，利用L化简S；if S = Φ return(TRUE);else if (S中有空子句 ) return（FALSE）；&#125;//while基于某种策略选取变元v；         //策略对DPLL性能影响很大if DPLL（S ∪v ）return(TURE);  //在第一分支中搜索return DPLL(S ∪¬v);//回溯到对v执行分支策略的初态进入另一分支&#125;</code></pre></div><p>对于公式{¬1∨2, ¬2，¬3∨4, 3∨¬5,3∨4, 3∨5，¬2∨¬5∨6} ,大家可以利用DPLL算法进行手动推理其搜索处理及回溯过程，获得求解结果。</p>]]></content>
    
    
    <categories>
      
      <category>由SAT问题引发的小思考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法重写</title>
    <link href="/posts/5504c575.html"/>
    <url>/posts/5504c575.html</url>
    
    <content type="html"><![CDATA[<p>发生在类的继承中，这个方法子和父名称一样，子生效<br><a name="44XsM"></a></p><h3 id="重写（override）规则："><a href="#重写（override）规则：" class="headerlink" title="重写（override）规则："></a>重写（override）规则：</h3><ol><li>参数列表必须完全与被重写方法相同</li><li>返回类型必须完全与被重写的返回类型相同</li><li>访问权限不能比父类中被重写的访问权限更低。例如：如果父类的一个方法被声明为public，name子类中重写该方法就不能声明为protected</li><li>父类的成员方法只能被他的子类重写</li><li>声明为static和private的方法不能被重写，但是能够被再次声明<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> stsic <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Student s = <span class="hljs-keyword">new</span> Student();<br>        s.say();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span>&#123;<br>        System.<span class="hljs-function">out <span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;锄禾日当午，汗滴禾下土&quot;</span>)</span></span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">class Student extends Person</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;床前明月光&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><p><a name="Gotao"></a></p><h4 id="注意：面试题：Java中重写（override）和重载（overland）的区别"><a href="#注意：面试题：Java中重写（override）和重载（overland）的区别" class="headerlink" title="注意：面试题：Java中重写（override）和重载（overland）的区别"></a>注意：面试题：Java中重写（override）和重载（overland）的区别</h4><ol><li>重写是发生在子父类中的操作</li><li>重载是一个类里面参数列表的长度、参数类型和参数类型顺序不同（分为构造方法重载和方法重载）</li></ol><p>a. 发生的位置<br />重载：一个类中<br />重写：子父类中<br />b. 参数列表限制<br />重载：必须不同<br />重写：必须相同<br />c. 返回值类型：<br />重载：与返回值类型无关<br />重写：返回值类型必须一致<br />d. 访问权限：<br />重载：与访问权限无关<br />重写： 子的方法权限 必须不能小于 父的方法权限<br />e.异常（bug）处理：<br />重载：与异常无关<br />重写：可以减少或删除（异常范围可以更小更精准，但是不能抛出新的异常）<br /><br><br /></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>final关键字</title>
    <link href="/posts/af55167d.html"/>
    <url>/posts/af55167d.html</url>
    
    <content type="html"><![CDATA[<p>final用于修饰属性、变量<br />变量成为了常量，无法对其再次进行赋值<br />final修饰的局部变量，只能赋值一次（可以先声明后赋值）<br />final修饰的是成员属性，必须在声明时赋值<br />全局常量（public static final）<br /><br><br />常量的命名规范：<br />由一个或多个单词组成，单词与单词之间必须使用下划线隔开，单词中所有字母大写<br />例如：SQL_INSET<br /><br><br /><br><br />final用于修饰类<br />final修饰的类，不可以被继承<br />final用于修饰方法<br />final修饰的方法，不能被子类重写<br />全局常量（public static final）<br /></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>异常处理</title>
    <link href="/posts/28877bf.html"/>
    <url>/posts/28877bf.html</url>
    
    <content type="html"><![CDATA[<p>情况描述：当程序出现bug时，Java虚拟机发现异常，虚拟机就会new出来一个新的对象，用类似返回的方式返回错误类型和异常原因，同时中断程序。</p><h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><p>对异常进行处理，捕获异常，避免异常返回使程序中断</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//有可能发生异常的代码</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">1</span> 对象名<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-comment">//异常的操作</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">1</span> 对象名<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-comment">//异常的操作</span><br>&#125;...<br><span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-comment">//异常的统一出口</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>catch语句相当于if语句<br />如果满足异常类型，则实现代码块里面的操作<br /><br><br />易错警告<br />eg1.</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.java.demo1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Person p =haha();<br>        System.out.println(p.age);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Person <span class="hljs-title">haha</span><span class="hljs-params">()</span></span>&#123;<br>        Person p = <span class="hljs-keyword">new</span> Person();<br>       <span class="hljs-keyword">try</span>&#123;<br>           p.age = <span class="hljs-number">18</span>;<br>           <span class="hljs-keyword">return</span> p;<br>       &#125;<span class="hljs-keyword">finally</span>&#123;<br>           p.age = <span class="hljs-number">28</span>;<br>       &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>        <span class="hljs-keyword">int</span> age;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//始终是一个对象，最后执行finally，p.age年龄被更改</span><br></code></pre></div></td></tr></table></figure><p>eg2.</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.java.demo1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> a =haha();<br>        System.out.println(a);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">haha</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;<span class="hljs-keyword">finally</span>&#123;<br>            a = <span class="hljs-number">20</span>;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//return a;中的a是被备份的那个</span><br><span class="hljs-comment">//实际上又开辟了一块内存空间，这是返回的a和finally中的赋值的a无关</span><br></code></pre></div></td></tr></table></figure><p>eg3.</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.java.demo1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        haha();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">haha</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;<br>            System.out.println(a/b);<br>        &#125;<br>        <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            <span class="hljs-comment">//退出JVM</span><br>            System.exit(<span class="hljs-number">0</span>);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;锄禾日当午，汗滴禾下土&quot;</span>);<br><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>唯一一种在代码中使finally不执行的代码就是上述eg3.<br /> System.exit(0);<br />总结：finally问题总绕不开两点：<br />1.finally必然执行<br />2.return的时机以及备份的具体内容</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>github访问加速</title>
    <link href="/posts/ceb1ca5c.html"/>
    <url>/posts/ceb1ca5c.html</url>
    
    <content type="html"><![CDATA[<h2 id="通过修改HOSTS文件进行加速"><a href="#通过修改HOSTS文件进行加速" class="headerlink" title="通过修改HOSTS文件进行加速"></a>通过修改HOSTS文件进行加速</h2><p>参考如下介绍</p><hr><h3 id="为什么github下载速度这么龟？"><a href="#为什么github下载速度这么龟？" class="headerlink" title="为什么github下载速度这么龟？"></a>为什么github下载速度这么龟？</h3><p>GitHub 我们都知道是世界上最大的开源及私有软件项目的托管平台，全世界每天有海量优秀的开源软件在这里产生，而 GitHub 在国内很多时候获取到的下载链接是亚马逊的服务器。</p><span id="more"></span><p>国内访问github，经常抽疯或龟速。</p><h3 id="如何提高github的下载速度？"><a href="#如何提高github的下载速度？" class="headerlink" title="如何提高github的下载速度？"></a>如何提高github的下载速度？</h3><p>手动把cdn和ip地址绑定。</p><h3 id="第一步：访问：这里-获取cdn和ip域名"><a href="#第一步：访问：这里-获取cdn和ip域名" class="headerlink" title="第一步：访问：这里 获取cdn和ip域名"></a>第一步：访问：<a href="http://github.global.ssl.fastly.net.ipaddress.com/#ipinfo">这里</a> 获取cdn和ip域名</h3><h3 id="第二步：获取github的global-ssl-fastly地址"><a href="#第二步：获取github的global-ssl-fastly地址" class="headerlink" title="第二步：获取github的global.ssl.fastly地址"></a>第二步：获取github的global.ssl.fastly地址</h3><p>得到：192.30.255.112</p><h3 id="第三步：获取github-com地址"><a href="#第三步：获取github-com地址" class="headerlink" title="第三步：获取github.com地址"></a>第三步：获取github.com地址</h3><p>得到：185.31.16.184</p><h3 id="第四步：修改host文件映射上面查找到的IP"><a href="#第四步：修改host文件映射上面查找到的IP" class="headerlink" title="第四步：修改host文件映射上面查找到的IP"></a>第四步：修改host文件映射上面查找到的IP</h3><p>windows系统：</p><p>找到C:\Windows\System32\drivers\etc\hosts<br>在<mark>最后写入 </p><p>192.30.255.112  github.com git</p><p>185.31.16.184 github.global.ssl.fastly.net</p><h3 id="第五步：在cmd中输入：ping-github-com即可"><a href="#第五步：在cmd中输入：ping-github-com即可" class="headerlink" title="第五步：在cmd中输入：ping github.com即可"></a>第五步：在cmd中输入：ping github.com即可</h3>]]></content>
    
    
    <categories>
      
      <category>github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实用技能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>build the drawing bed on github</title>
    <link href="/posts/96102aeb.html"/>
    <url>/posts/96102aeb.html</url>
    
    <content type="html"><![CDATA[<p>问题描述：在写第一篇博客时，图片在md文件中能够正常显示，而在网页上浏览时显示上传失败。查了资料发现原因是md中的文件路径使用相对路径，page到网页上时路径失效，找不到本地存图片的文件，因此加载失败。想解决这个问题，需要将本地图片page到网上生成网链（md可辨别的）。</p><span id="more"></span><p>做法：</p><p>1.在github上新建仓库作为图床<br>2.在issue中点击new issues<br><img src="https://user-images.githubusercontent.com/73998546/122338823-cdbeff80-cf72-11eb-98a0-c7af3504da7c.png" alt="1 (1)"></p><p>3.将图片拖入输入框</p><p>4.在preview中可以预览图片样式</p><p>5.在write中生成的链接可以再md中直接应用<br><img src="https://user-images.githubusercontent.com/73998546/122338817-cbf53c00-cf72-11eb-8527-09a51858866b.png" alt="1 (2)"></p><p>完成！撒花✿✿ヽ(°▽°)ノ✿</p>]]></content>
    
    
    <categories>
      
      <category>github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实用技能</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
