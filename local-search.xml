<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>应用DCT实现对音频水印的添加和提取</title>
    <link href="/posts/e1e00902.html"/>
    <url>/posts/e1e00902.html</url>
    
    <content type="html"><![CDATA[<h3 id="关于数字水印"><a href="#关于数字水印" class="headerlink" title="关于数字水印"></a>关于数字水印</h3><p>数字⽔印技术是⼀种信息隐藏技术。所谓⾳频数字⽔印算法就是将数字⽔印通过⽔印嵌⼊算法嵌⼊到⾳频⽂件中（如 .wav、.mp3、.avi 等），但对原⾳质没有影响。也就是说，嵌入前后的音频人耳无法识别。水印提取的过程与前面正相反，我们需要从嵌入水印的音频中完整的提取出水印。</p><p>同时，水印嵌入音频需要对攻击和其他类型的失真具有鲁棒性，以防止篡改和伪造。典型的攻击包括添加噪声、数据压缩、过滤、重采样、混响等。</p><h3 id="DCT思想"><a href="#DCT思想" class="headerlink" title="DCT思想"></a>DCT思想</h3><p>DCT变换的全称是离散余弦变换(Discrete Cosine Transform)，DCT是一个特殊的DFT，也就是说，DCT变换就是输入信号为实偶函数的DFT变换。</p><p>我的想法是通过DCT变换将音频从时域转换到频域，在频域中寻找引起整体改变最小的数据块，并将其用我们的水印进行覆盖。</p><p><img src="https://user-images.githubusercontent.com/73998546/183948742-8ab26ae2-45a9-41cd-990a-84d0750eae4e.png" alt="DCT变换"></p><p>DCT和逆DCT的公式：</p><p><del>水平有限，只能不求甚解了</del>😭</p><p><img src="https://user-images.githubusercontent.com/73998546/183949971-1f784650-743d-4b79-9908-0ec9bf7fea7d.png" alt="DCT和逆DCT"></p><h3 id="对音频添加音频水印"><a href="#对音频添加音频水印" class="headerlink" title="对音频添加音频水印"></a>对音频添加音频水印</h3><p>DCT水印算法思想</p><hr><p>1: Divide the audio into non-overlapping blocks of size row × collum.</p><p>2: Suppose we have n such blocks. </p><p>3: Generate a set of keys called k. This will be used as a seed for the pseudo-random generator. </p><p>4: The size of the watermark is expressed as width w times height h. Therefore, there are fea = w×h feature points in the watermark. </p><p>5: Check if n ≤ fea. If not, the watermark cannot be embedded. </p><p>6: For each feature point of the watermark, repeat 7-10: </p><p>7: Compute the DCT of this block. Let it be named dct block. </p><p>8: Let change[i] = k[i] × watermark[h][w]</p><p>9: Add the change[i] to the last column of the current block, dct block[i, collum − 1]+ = change[i]. </p><p>10: Calculate the inverse DCT of the block and save it. </p><p>11: Save watermarked audio.</p><hr><hr><hr><h3 id="关键代码思路"><a href="#关键代码思路" class="headerlink" title="关键代码思路"></a>关键代码思路</h3><ul><li><p>初始化对象</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, background, watermark, block_size, alpha</span>):</span><br>        b_h, b_w = background.shape[:<span class="hljs-number">2</span>]<br>        w_h, w_w = watermark.shape[:<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">assert</span> w_h &lt;= b_h / block_size, \<br>            <span class="hljs-string">&quot;\r\n请确保您的的水印音频尺寸 不大于 原有音频尺寸的1/&#123;:&#125;\r\nbackground尺寸&#123;:&#125;\r\nwatermark尺寸&#123;:&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<br>                block_size, background.shape, watermark.shape<br>            )<br>        <span class="hljs-comment"># 块大小保存</span><br>        self.block_size = block_size<br>        self.block_size_y = b_w<br>        <span class="hljs-comment"># 水印强度控制</span><br>        self.alpha = alpha<br>        <span class="hljs-comment"># 随机序列</span><br>        self.k1 = np.random.randn(block_size)<br></code></pre></div></td></tr></table></figure><p>这里有一个强条件：水印音频是原有音频大小的1/n。否则水印块和原有块的映射关系被破坏，水印音频将无法完全插入到原有音频中。</p></li><li><p>分块&amp;DCT变换</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dct_blk</span>(<span class="hljs-params">self, background</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        对background进行分块，然后进行dct变换，得到dct变换后的矩阵</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br><br>        background_dct_blocks_h = background.shape[<span class="hljs-number">0</span>]//self.block_size<br>        background_dct_blocks = np.zeros(shape=(<br>            (background_dct_blocks_h,<br>             self.block_size, background.shape[<span class="hljs-number">1</span>])<br>        ))  <br>        <span class="hljs-comment"># 前2个维度用来遍历所有block，后2个维度用来存储每个block的DCT变换的值</span><br>        <span class="hljs-comment"># 垂直方向分成background_dct_blocks_h个块</span><br>        h_data = np.vsplit(background, background_dct_blocks_h)<br>        <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(background_dct_blocks_h):<br>            a_block = h_data[h]<br>            <span class="hljs-comment"># dct变换</span><br>            background_dct_blocks[h, ...] = dct(a_block, <span class="hljs-built_in">type</span>=<span class="hljs-number">3</span>, norm=<span class="hljs-string">&quot;ortho&quot;</span>)<br>        <span class="hljs-keyword">return</span> background_dct_blocks<br></code></pre></div></td></tr></table></figure></li><li><p>水印嵌入</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dct_embed</span>(<span class="hljs-params">self, dct_data, watermark</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;_summary_</span><br><span class="hljs-string">        嵌入水印到original audio的dct系数中</span><br><span class="hljs-string">        Args:</span><br><span class="hljs-string">            dct_data (_type_): original audio的dct系数</span><br><span class="hljs-string">            watermark (_type_): 音频数组</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--------dct_embed start-----------------&quot;</span>)<br>        temp = watermark.flatten()<br>        result = dct_data.copy()<br>        <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(watermark.shape[<span class="hljs-number">0</span>]):<br>            <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(watermark.shape[<span class="hljs-number">1</span>]):   <br>                <span class="hljs-comment"># 查询块(h,w)并遍历对应块的最后一列（影响最小的部分），进行修改</span><br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.block_size):<br>                    result[h, i, self.block_size_y-<span class="hljs-number">1</span>] = dct_data[h,<br>                                                                 i, self.block_size_y-<span class="hljs-number">1</span>]+self.alpha*watermark[h][w]<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--------dct_embed end-----------------&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br></code></pre></div></td></tr></table></figure></li><li><p>IDCT(DCT逆变换)</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">idct_embed</span>(<span class="hljs-params">self, dct_data</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        进行对dct矩阵进行idct变换，完成从频域到空域的变换</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--------idct_embed start-----------------&quot;</span>)<br>        row = <span class="hljs-literal">None</span><br>        result = <span class="hljs-literal">None</span><br>        h = dct_data.shape[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(h):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--------Round:&quot;</span>, i, <span class="hljs-string">&quot;-----------------&quot;</span>)<br>            block = idct(dct_data[i, ...], <span class="hljs-built_in">type</span>=<span class="hljs-number">3</span>, norm=<span class="hljs-string">&quot;ortho&quot;</span>)<br>            result = block <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> np.vstack((result, block))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--------idct_embed end-----------------&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br></code></pre></div></td></tr></table></figure></li><li><p>水印提取</p><p>在每一个块中，遍历对应的加密区域（每个块最后一列），进行加密的逆操作，得到提取出的水印。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dct_extract</span>(<span class="hljs-params">self, synthesis, watermark_size, background</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        从嵌入水印的音频中提取水印</span><br><span class="hljs-string">        :param synthesis: 嵌入水印的空域音频</span><br><span class="hljs-string">        :param watermark_size: 水印大小</span><br><span class="hljs-string">        :return: 提取的空域水印</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        w_h, w_w = watermark_size<br>        recover_watermark = np.zeros(shape=watermark_size)<br>        synthesis_dct_blocks = self.dct_blk(background=synthesis)<br>        background_dct_blocks = self.dct_blk(background=background)<br>        p = np.zeros(self.block_size)<br>        <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(w_h):<br>            <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(w_w):<br>                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.block_size):<br>                    recover_watermark[h, w] = (<br>                        synthesis_dct_blocks[h, k, self.block_size_y-<span class="hljs-number">1</span>] - background_dct_blocks[h, k, self.block_size_y-<span class="hljs-number">1</span>])/self.alpha<br>        <span class="hljs-keyword">return</span> recover_watermark<br></code></pre></div></td></tr></table></figure></li><li><p>绘制频谱图像</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_time</span>(<span class="hljs-params">path, filename</span>):</span><br>    f = wave.<span class="hljs-built_in">open</span>(path, <span class="hljs-string">&#x27;rb&#x27;</span>)<br>    params = f.getparams()<br>    params = f.getparams()<br>    <span class="hljs-comment"># 通道数、采样字节数、采样率、采样帧数</span><br>    nchannels, sampwidth, framerate, nframes = params[:<span class="hljs-number">4</span>]<br>    voiceStrData = f.readframes(nframes)<br>    waveData = np.fromstring(voiceStrData, dtype=np.short)  <span class="hljs-comment"># 将原始字符数据转换为整数</span><br>    <span class="hljs-comment"># 音频数据归一化</span><br>    waveData = waveData * <span class="hljs-number">1.0</span>/<span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>(waveData))<br>    <span class="hljs-comment"># 将音频信号规整乘每行一路通道信号的格式，即该矩阵一行为一个通道的采样点，共nchannels行</span><br>    waveData = np.reshape(waveData, [nframes, nchannels]).T  <span class="hljs-comment"># .T 表示转置</span><br>    f.close()<br><br>    time = np.arange(<span class="hljs-number">0</span>, nframes)*(<span class="hljs-number">1.0</span>/framerate)<br>    plt.plot(time, waveData[<span class="hljs-number">0</span>, :], c=<span class="hljs-string">&#x27;b&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;time&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;am&#x27;</span>)<br>    plt.savefig(<span class="hljs-string">&#x27;./%s.jpg&#x27;</span> % filename)<br>    plt.show()<br></code></pre></div></td></tr></table></figure></li><li><p>主函数</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>   <br>    alpha = <span class="hljs-number">0.1</span><br>    block_size = <span class="hljs-number">4</span><br>    <span class="hljs-comment"># 1.数据读取</span><br>    samplerate_wm, data_wm = wavfile.read(<span class="hljs-string">&quot;piano_3s.wav&quot;</span>)<br>    samplerate_bg, data_bg = wavfile.read(<span class="hljs-string">&quot;buddy_19s.wav&quot;</span>)<br>    <span class="hljs-comment">#若无法平均分块，也就是说数组大小不是块的大小的整数倍，给数组加一列0，使其变成块大小的整数倍</span><br>    <span class="hljs-keyword">if</span>((np.shape(data_bg)[<span class="hljs-number">0</span>] % block_size) != <span class="hljs-number">0</span>):<br>        data_bg = np.r_[data_bg, np.zeros(<br>            block_size-(np.shape(data_bg)[<span class="hljs-number">0</span>] % block_size))]<br>    <span class="hljs-comment">#将单声道音频转为双声道，方便统一处理</span><br>    <span class="hljs-keyword">if</span>(data_bg.ndim == <span class="hljs-number">1</span>):<br>        a = np.array(np.zeros(data_bg.shape[<span class="hljs-number">0</span>])).T<br>        data_bg = np.c_[np.array([data_bg]).T, a]<br>    <span class="hljs-built_in">print</span>(np.shape(data_wm), np.shape(data_bg))<br><br>    <span class="hljs-comment"># 2.分块&amp;dct</span><br>    dct_embed = DCT_Embed(background=data_bg, watermark=data_wm,<br>                          block_size=block_size, alpha=alpha)<br>    background_dct_blocks = dct_embed.dct_blk(background=data_bg)<br>    <span class="hljs-comment"># print(np.shape(background_dct_blocks))</span><br>    <span class="hljs-comment"># 3.嵌入水印到频域</span><br>    embed_wm_blocks = dct_embed.dct_embed(<br>        dct_data=background_dct_blocks, watermark=data_wm)<br>    <span class="hljs-comment"># 4.idct 从频域变换到时域</span><br>    synthesis = dct_embed.idct_embed(dct_data=embed_wm_blocks)<br>    data = normalizeForWav(synthesis)<br>    wavfile.write(<span class="hljs-string">&quot;piano_dct.wav&quot;</span>, samplerate_bg, data)<br>    draw_time(<span class="hljs-string">&quot;piano_3s.wav&quot;</span>,<span class="hljs-string">&quot;piano_3s&quot;</span>)<br>    draw_time(<span class="hljs-string">&quot;buddy_19s.wav&quot;</span>,<span class="hljs-string">&quot;buddy_19s&quot;</span>)<br>    draw_time(<span class="hljs-string">&quot;piano_dct.wav&quot;</span>,<span class="hljs-string">&quot;piano_dct&quot;</span>)<br><br>    <span class="hljs-comment"># 5.提取水印</span><br>    samplerate_syn, data_syn = wavfile.read(<span class="hljs-string">&quot;bunny_compress.wav&quot;</span>)<br>    <span class="hljs-keyword">if</span>((np.shape(data_syn)[<span class="hljs-number">0</span>] % block_size) != <span class="hljs-number">0</span>):<br>        data_syn = np.r_[data_syn, np.zeros(<br>            block_size-(np.shape(data_syn)[<span class="hljs-number">0</span>] % block_size))]<br>    <span class="hljs-keyword">if</span>(data_syn.ndim == <span class="hljs-number">1</span>):<br>        a = np.array(np.zeros(data_syn.shape[<span class="hljs-number">0</span>])).T<br>        data_syn = np.c_[np.array([data_syn]).T, a]<br>    <span class="hljs-built_in">print</span>(np.shape(data_syn))<br>    extract_watermark = dct_embed.dct_extract(<br>        synthesis=data_syn, watermark_size=data_wm.shape, background=data_bg)<br>    data = normalizeForWav(extract_watermark)<br>    wavfile.write(<span class="hljs-string">&quot;compress_ext.wav&quot;</span>, samplerate_wm, data)<br>    draw_time(<span class="hljs-string">&quot;piano_3s.wav&quot;</span>, <span class="hljs-string">&quot;piano_3s&quot;</span>)<br>    draw_time(<span class="hljs-string">&quot;compress_ext.wav&quot;</span>, <span class="hljs-string">&quot;compress_ext&quot;</span>)<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">normalizeForWav</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-keyword">return</span> np.int16(data.real)<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h3><p>是时候展示真正的实力了！</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">&lt;audio id=&quot;audio&quot; controls=&quot;&quot; preload=&quot;none&quot;&gt;<br>      &lt;source id=&quot;mp3&quot; src=&quot;音频地址&quot;&gt;<br>&lt;/audio&gt;<br></code></pre></div></td></tr></table></figure><audio id="audio" controls="" preload="none">      <source id="mp3" src="img\audio\piano_3s.mp3"></audio><p><img src="/img/bg/panda.jpg" alt="DCT"></p><h3 id="对音频添加图像水印"><a href="#对音频添加图像水印" class="headerlink" title="对音频添加图像水印"></a>对音频添加图像水印</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NUS暑校实验记录</title>
    <link href="/posts/1f6f5090.html"/>
    <url>/posts/1f6f5090.html</url>
    
    <content type="html"><![CDATA[<p>把任务书和实验分析过程(部分)放在这里,以此纪念我逝去的半个暑假</p><p>有些分析过程搞丢了，找到了lab4的全尸<br><a href="https://github.com/Weipp7/NUS-Project-Audio-Watermarking/blob/main/lab/Lab4InfrastructureAndMachines.pdf">任务书</a></p><h2 id="LAB-4-1-Creating-a-certificate-authority"><a href="#LAB-4-1-Creating-a-certificate-authority" class="headerlink" title="LAB 4-1 Creating a certificate authority"></a>LAB 4-1 Creating a certificate authority</h2><p><b>What is the purpose of the extra information in the (CA) certificate you created? </b></p>I don't know what means of the extra information,after I search the internet for extra information.And I found this answer :<br>A digital certificate usually contains:</br><br>public key;</br><br>holder information;</br><br>Information about the Certificate Authority (CA);</br><br>The CA's digital signature of this document and the algorithm used;</br><br>certificate validity period;</br><br>the extra information;</br><br>According to the above information and the testCA.crt,I think the extra information are fingerprints in testCA.crt.And it is used to authenticate the identity and determine whether the document has been tampered with</br><img src="https://user-images.githubusercontent.com/73998546/180237472-09f7d5fd-e483-4536-a402-be504971273f.png"><img src="https://user-images.githubusercontent.com/73998546/180237482-7b7b61ee-fc6c-46f8-a6ff-40bf86f06e7c.png"><img src="https://user-images.githubusercontent.com/73998546/180237506-b9764add-f550-4f89-bae0-1fa25c2d1290.png"><p><b>Explain the files you created. What is each file used for?</b></p><br>In the experiment, we mainly do two things:</br><br>1.Use openssl to create a root certificate</br><br>2.create the certificate for the server</br><img src="https://user-images.githubusercontent.com/73998546/180237635-52d2a7f9-9582-4c9b-bca6-614d7912ecf7.png"><br>On step 1:</br><br>localhost.cnf:Store some configuration files for simplifying parameters</br><br>testCA.key:private key file</br><br>testCA.crt:Credential crt file</br><p><br>On step 2:</br><br><br>localhost.key:key for the server</br><br><br>localhost.csr:certificate signing request csr file for the client key</br><br><br>localhost.crt:Use the key of the CA certificate to sign the client key and generate a signature file</br><br><br>testCA.srl:Record the serial number of the certificate generated by the current CA</br></p><p><b>Why is the webserver using both the certificate and private key? (What does it use each for?)</b></p><br>In most protocols, client and server indicate that both parties want to establish an encrypted session.</br><br>1. The server transmits the digital certificate to the client. The certificate contains the public key of the server. The client uses the public key to parse the digital signature in the certificate, which can verify the identity of the server.</br><br>2. The client generates a symmetric encryption key for encrypted transmission of actual data, encrypts it with the server's public key, and transmits the generated key to the server. Also carry a "client finished" encrypted with the encryption key just generated.</br><br>3. The server receives the symmetric encryption key and tries to decrypt the encrypted field with the key. If the plaintext "client finished" can be obtained, the key is considered valid and can be used for subsequent data encryption transmission. At the same time, "server finished" is encrypted with this key and passed to the client.</br><br>4. The client decrypts with the symmetric secret key. If the plaintext "server finished" can be obtained, the client believes that the server has correctly received the symmetric key.</br><br>Using both certificates and private keys at the same time can greatly improve security and prevent data from being decrypted during transmission</br><br>The specific running example is as follows:</br><img src="https://user-images.githubusercontent.com/73998546/180237587-34cdc0d9-4144-41ed-b31a-1eb096290805.png"><img src="https://user-images.githubusercontent.com/73998546/180237602-ad0db595-8558-4879-b85b-92fb164a1ec9.png"><h2 id="LAB-4-2-SEED-Buffer-Overflow-Vulnerability-Lab"><a href="#LAB-4-2-SEED-Buffer-Overflow-Vulnerability-Lab" class="headerlink" title="LAB 4-2 SEED Buffer-Overflow Vulnerability Lab"></a>LAB 4-2 SEED Buffer-Overflow Vulnerability Lab</h2><p><p1><b>Task 1: Getting Familiar with Shellcode</b></p1><br><br>typing make in terminal,then Two binaries will be created, a32.out (32-bit) and a64.out (64-bit).Run them and we observe that we get the root shell.</br><br><img src="https://user-images.githubusercontent.com/73998546/180107462-523e17bd-07d2-462a-96e8-111c749c182f.png"></p><p><br><p1><b>Task 2:Understanding the Vulnerable Program</b></p1></br><br><br>Since the  compilation and setup commands are already included in Makefile,we just need to type make to execute those commands.</br></p><p><p1><b>Task 3:Launching Attack on 32-bit Program </b><p1><br><br>Our purpose is to implement malicious code by exploiting buffer overflows and eventually gain root privileges.</br><br><br>We can see that in the exploit.py file, we need to fill in several parts, namely shellcode, start, ret and offset.</br><br><br>First, we fill in the 32-bit corresponding malicious code to obtain root shell.</br><br><img src="https://user-images.githubusercontent.com/73998546/180107547-06916f1c-958f-42ee-96d6-a1df1fc6f3fd.png"><br><br>Then we analyze the stack frame structure in the function bof:</br><br><img src="https://user-images.githubusercontent.com/73998546/180107561-1b604e81-edcd-4550-bbf3-441ecda45872.jpg"><br><br>We consider putting shellcode at the end of badfile, so “start = 517-len(shellcode)”</br><br><br>After that we need to determine the position of ret in badfile, that is offset. We consider offset = ebp - &amp;buffer + 4 , so the first step is to determine the values of ebp and &amp;buffer.</br><br><br>We print out the ebp value and the buffer’s address through the gdb debugging tool.</br></p><p><br>According to the note1 in the task book,we need to use next to execute a few instructions and stop after the ebp register is modified to point to the stack frame of the bof() function.</br><br><img src="https://user-images.githubusercontent.com/73998546/180107567-85507cee-1612-4d98-baf6-f9344891191f.png"><br><br>buff = 0xffffca7c</br><br><br>ebp = 0xffffcae8</br></p><p><br>The value of ret (return address) should jump after new ret and before shellcode. This ensures that the shellcode is executed.</br><br><br>so ret = ebp + n(n&gt;=8)</br><br><br>But I found that when n=8, the program reported an error:segmentation fault.</br><br><br>According to the note2 in the task book,the real stack frame value is larger than the value of the gdb runtime,so we should add an offset.</br><br><br>After many attempts, I found that offsets between 200-300 can get a root shell.</br><br><br>Now let’s check it!</br><br><img src="https://user-images.githubusercontent.com/73998546/180107577-1284062f-b37b-4c0a-8919-e0621ccebf57.png"><br><br>OK!I obtain the root shell!</br></p><h2 id="LAB-4-3-SEED-Return-to-libc-Attack-lab"><a href="#LAB-4-3-SEED-Return-to-libc-Attack-lab" class="headerlink" title="LAB 4-3 SEED Return-to-libc Attack lab"></a>LAB 4-3 SEED Return-to-libc Attack lab</h2><p><p1><b>Task 1:Finding out the Addresses of libc Functions</b></p1><br><br>We used the p command to print the addresses of system() and exit() functions.</br><br><br>As follow:</br><br><br><img src="https://user-images.githubusercontent.com/73998546/180268460-177875dd-b562-4422-b566-bb3b745c60f3.png"></br></p><p><br><p1><b>Task 2: Putting the shell string in the memory</b></p1></br><br>I uesd the method inntask 2 to put the shell string in the memory.<br>First define a new shell variable MYSHELL = /bin/sh,then I will use the addresses of this variable as an argument to system() call.<br>Following the code in task3.2, we could compile the code and print the addresses of MYSHELL.<br><br><img src="https://user-images.githubusercontent.com/73998546/180268512-55e72405-0c67-4d06-ad70-26dafff3ab36.png"></br></p><p><p1><b>Task 3: Launching the Attack </b></p1><br>According to the above two tasks,we get thses informations:<br>0xf7e12420 <system><br>0xf7e04f80 <exit><br>0xffffd3f6 bin/sh<br>So it is natural to fill them in the corresponding address.<br>After we should consider the stack frame structure to figure out X,Y and Z.<br>I think the stack frame as this:<br><br><img src="https://user-images.githubusercontent.com/73998546/180268579-bb65767b-38ef-46f6-a582-a8ae28ab4e1e.jpg"></br><br>Since we are going to excute the function system(),the return address should be loaded the system_addr.<br>So Y should be the relative offset of ret,Y = ebp - buff + 4.<br>And then, considering the addresses of the variable MYSHELL as an argument to system() call,I put it behind the system().<br>So X = ebp - buff + 8<br>Then execute function exit(),I put it behind MYSHELL.<br>So Z = ebp - buff + 12<br>Let’s try to run<br><br><img src="https://user-images.githubusercontent.com/73998546/180268633-efae3337-cbbf-4afa-a968-71db83adbc03.png"></br><br><br><img src="https://user-images.githubusercontent.com/73998546/180268664-3961c817-d295-4d7f-8ec5-24cb980a16fc.png"></br><br>Opps maybe something wrong.We check it.I think the system_addr won’t be wrong,that’s the start of the execution programm.<br>So maybe X or Z is wrong.At present I have no idea,so we could try to change X and Z.<br>I first tried swapping the values of X and Z, after that I ran the program.Then it works!<br><br><img src="https://user-images.githubusercontent.com/73998546/180268686-d0fa33b2-2ddd-4603-b275-6b592eb9e446.png"></br><br><br><img src="https://user-images.githubusercontent.com/73998546/180268698-01b52cc2-00e2-4320-84ad-974f4fef5bd7.png"></br><br>It’s amazing,I wonder how.After I search on Internet about the stack frame structure,then I find this:<br><br><img src="https://user-images.githubusercontent.com/73998546/180268707-6095327f-d6bf-409c-a99f-add9f052684a.png"></br><br>So the position “ebp - buff + 8” to be filled in is the return address of the system.<br>The return address of system is followed by the parameters,and MYSHELL is passed as a parameter to system.</p><p><p1><b>Attack variation 1: Is the exit() function really necessary?</b></p1><br><br>I think it’s not really necessary.<br>Actually, I found that whether it is to remove the exit, or to change the position of the exit, such as making Z = ebp - buff + 4 or Z = ebp - buff + 16,<br>can successfully obtain root privileges.<br>My idea is that the main function of this experiment is to pass MYSHELL as a parameter and run the system function at the same time.<br>This has little to do with exit. As long as the previous steps are successfully executed, root privileges can be obtained.<br>Even if I remove exit, it still gets root shell and exits successfully, this is what I have observed.<br>According to the paper,the function exit() seems to help the shellcode to quit without a trace,but I could not find somewhere different with the previous.</br></p><p><p1><b>Attack variation 2: change the file name of retlib to a different name,Repeat the attack (without changing the content of badfile). Will your attack succeed or not?</b></p1><br><br>After rename the file name , my attack failed.<br>In fact, when the program is executed, the name of the program is passed on the stack first,<br> and then the other variables in the program are passed on the stack. So when we only change the length of the program name,<br> the addresses of the other environment variables will be extended backwards,and our badfile isn’t changeg, which will cause us to be unable to access the correct environment variables<br> , so the attack fails.</br></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基于TABLE FILLING的NER&amp;RE</title>
    <link href="/posts/d92671ff.html"/>
    <url>/posts/d92671ff.html</url>
    
    <content type="html"><![CDATA[<p>在以往的NER&amp;RE的任务中，很多方法都是基于复杂的手工特征和神经网络架构，这导致训练的时间和基于历史的预测时间较长。</p><p>现在呢，有大佬提出了一种新颖而简单的方法：基于<strong>表格表示</strong>从<strong>非结构化文本</strong>中提取命名实体和关系</p><p><code>输入：单词序列w1,w2 ... wn（n 是输入中的单词数）</code></p><blockquote><p>Johanson Smith lives in London</p></blockquote><p><code>输出：关系三元组（arg0type0，relation，arg1type1）</code></p><blockquote><p>（Johanson_B-PER,LiveIn,London_U-LOC）<br>（Smith_B-PER,LiveIn,London_U-LOC）</p></blockquote><p>具体怎么整呢。我们定义一个 n×n 上三角矩阵 Y ，其中对角元素 <strong>Yi,i</strong> ∈ E (1 ≤ i ≤ n) 表示<strong>词wi</strong>，非对角元素 <strong>Yi,j</strong> ∈ R(1 ≤ i &lt; j ≤ n) 表示有向关系单词 wi 和 wj 之间的**<strong>标签</strong>。</p><p>此模型可以看做将一系列单词 w1w,2 · · · wn映射到上三角矩阵</p><p><img src="https://user-images.githubusercontent.com/73998546/183257257-ea3bf94f-a5c2-4fd8-b974-0157fd4c382c.png" alt="上三角矩阵"></p><h2 id="模型框架"><a href="#模型框架" class="headerlink" title="模型框架"></a>模型框架</h2><p>该模型分为并行的两块，在到达Entity Representation层后，分别用不同的方法进行ner和re。也就是说，我们在 BERT 编码器之上执行 RE<br>识别实体之后，NER 模型填充 Y 中的所有对角线元素，RE 模型预测所有非对角元素。</p><p><img src="https://user-images.githubusercontent.com/73998546/183257289-9735816a-8a38-45c0-9dc0-f6a1783e326f.png" alt="模型框架"></p><h3 id="Named-Entity-Recognition"><a href="#Named-Entity-Recognition" class="headerlink" title="Named Entity Recognition"></a>Named Entity Recognition</h3><h4 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h4><p>BERT 分词器使用 WordPiece 拆分单词在 BPE 的帮助下转化为子词标记</p><blockquote><p>“Johanson” –&gt; “Johan”和”##son”</p></blockquote><p><code>输入：经WordPiece处理过的子词序列</code><br><code>输出：文本中各个子词融合了全文语义信息后的向量表示</code></p><h4 id="Word-level-Embedding"><a href="#Word-level-Embedding" class="headerlink" title="Word-level Embedding"></a>Word-level Embedding</h4><p>由于 NE 是在单词级别注释的，我们在训练和预测两个过程中都需要它在单词级别的表示。<br>计算方法如下：<br>Bert嵌入的子词标记组成词（eti,1,eti,2…eti,s）作为输入,ewi作为输出</p><p><img src="https://user-images.githubusercontent.com/73998546/183257538-c90f3dcd-f3cb-4b72-9259-ffd6fbbfc1ef.png" alt=" "></p><p>f表示一个最大池化操作，即对（eti,1,eti,2…eti,s）进行降维压缩，以某种方式取最大值</p><p><code>输入：子词向量</code><br><code>输出：池化后的word level的单词向量</code></p><h4 id="Entity-Representation"><a href="#Entity-Representation" class="headerlink" title="Entity Representation"></a>Entity Representation</h4><p><img src="https://user-images.githubusercontent.com/73998546/183257819-75c634af-abf8-434f-8043-2d8ce3f8b6aa.png" alt="Entity Representation"></p><p>计算方法如下：<br>①词wi的表示ewi<br>②上一个标签yi-1的embedding lyi−1<br>③<del>出现在时间步长上的前一个 NE 跨度的 BERT 嵌入的最大池化</del>（翻译成人话：上一个实体的向量表示）</p><blockquote><p>如上图的示例，③为上一个实体”Johanson Smith”的向量表示</p></blockquote><p>其中⊕代表向量连接。</p><p><img src="https://user-images.githubusercontent.com/73998546/183257900-65e248b0-e492-4753-be11-89dd8104c897.png" alt=" "></p><p>输入：①⊕②⊕③<br>输出：关系隐藏向量h</p><h4 id="Softmax-Classifier-of-NER"><a href="#Softmax-Classifier-of-NER" class="headerlink" title="Softmax Classifier of NER"></a>Softmax Classifier of NER</h4><p>之后应用一个全连接层，然后是一个softmax 函数 σ 在时间步 i 处获得所有可能的 NE 标签的概率分布，之后选择概率最高的y^i填充Yi,i (= yi)</p><p><img src="https://user-images.githubusercontent.com/73998546/183258044-c7e1f768-6904-42b7-86c3-15dbd23e1016.png" alt=" "></p><p><code>输入：关系隐藏向量h、矩阵w、线性变换的偏置向量b</code><br><code>输出：概率最高的标签y</code></p><h3 id="Relation-Extraction"><a href="#Relation-Extraction" class="headerlink" title="Relation Extraction"></a>Relation Extraction</h3><p>RE模型利用实体跨度和他们的NE标签以获得关系表示，用于预测关系标签。</p><p><img src="https://user-images.githubusercontent.com/73998546/183258323-bb980bfa-6fdb-4e98-bc91-a0acbf05084b.png" alt="RE模型"></p><h4 id="Word-Representation"><a href="#Word-Representation" class="headerlink" title="Word Representation"></a>Word Representation</h4><p>实体跨度特征 zi（在时间点 i）是使用实体跨度中组成词的表示来计算的：</p><p><img src="https://user-images.githubusercontent.com/73998546/183258388-b9770e0d-eb0e-4ed9-a724-b626b91a3728.png" alt=" "></p><p>换个说法，zi是从 first(i) 开始的,last（i）结束的实体跨度的单词表示的最大池化。<br>在数学上，单词表示，即 RE 模型的输入，是实体跨度和实体标签特征的串联，</p><p><img src="https://user-images.githubusercontent.com/73998546/183258558-8d424d6e-f6e2-49ed-a848-1020db450fba.png" alt=" "></p><p>生成qk矩阵张量</p><p><img src="https://user-images.githubusercontent.com/73998546/183259054-97cd14b3-0c2a-4c31-8338-07a0b2aa45eb.png" alt=" "></p><p><code>输入：实体跨度zi和实体标签特征lyi的串联</code><br><code>输出：qk矩阵张量</code></p><h4 id="Tensor-Dot-Product"><a href="#Tensor-Dot-Product" class="headerlink" title="Tensor Dot-Product"></a>Tensor Dot-Product</h4><p><code>输入：qk矩阵张量</code><br><code>输出：qk张量的点积</code></p><h4 id="Softmax-Classifier-of-RE"><a href="#Softmax-Classifier-of-RE" class="headerlink" title="Softmax Classifier of RE"></a>Softmax Classifier of RE</h4><p>Softmax 函数σ 计算所有的概率分布关系标签 R。我们用产生最高概率的关系标签记为y^i,j 。</p><p><img src="https://user-images.githubusercontent.com/73998546/183259181-b700d4d0-a49b-43ce-9483-e823811aa2d2.png" alt=" "></p><p><code>输入：qk张量的点积</code><br><code>输出：产生最高概率的关系标签y^i,j</code></p><p>参考论文<br><a href="https://www.jstage.jst.go.jp/article/jnlp/29/1/29_187/_pdf/-char/ja">Named Entity Recognition and Relation Extraction using Enhanced Table Filling by Contextualized Representations</a></p>]]></content>
    
    
    <categories>
      
      <category>NER</category>
      
      <category>RE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NER</tag>
      
      <tag>RE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AESINER模型分析</title>
    <link href="/posts/a8e0d3dd.html"/>
    <url>/posts/a8e0d3dd.html</url>
    
    <content type="html"><![CDATA[<p>NER 的主要方法传统上被认为是具有隐马尔可夫模型 (HMM) 和条件随机场 (CRF) 等模型的序列标记任务学习。而神经模型也占据主导地位。原因是他们在编码上下文信息方面非常强大，可以驱动 NER 系统更好地理解文本并识别输入文本中的NE。</p><p>对于一段语料而言，有很多句法特征，例如词性标签、句法成分、依赖关系等。对NER任务来讲，这些特征可以有效地识别一段文本中的继承结构，从而指导系统相应地找到合适的实体单元。因此，寻找合适的方法将这些信息整合到神经模型中，将会是一次全新的突破。</p><p>AESINER提出了一个巧妙的解决方案。</p><h3 id="有监督-or-无监督？"><a href="#有监督-or-无监督？" class="headerlink" title="有监督 or 无监督？"></a>有监督 or 无监督？</h3><p>AESI模型是有监督学习。其预训练的嵌入包含从大规模语料库中学习到的上下文信息，在本模型中通过在输入中直接连接多个预训练嵌入来合并它们，这里的预训练都是给出训练文本对应标注的训练，因此判断为有监督。</p><h3 id="数据集样式"><a href="#数据集样式" class="headerlink" title="数据集样式"></a>数据集样式</h3><p><code>输入：普通文本</code><br><code>中间输出：每个词向量的句法信息（包括词性标签、语法信息和依赖关系）的集合</code><br><code>最终输出：输出句子中判断出的实体标签</code></p><blockquote><p>输入：Today is my last day at my office.</p></blockquote><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">中间输出：<br>&#123;<span class="hljs-attr">&quot;sentences&quot;</span>: [&#123;<span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">&quot;line&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">&quot;parse&quot;</span>: <span class="hljs-string">&quot;(ROOT\n  (S\n    (NP (NN today))\n    (VP (VBZ is)\n      (NP\n        (NP (PRP$ my) (JJ last) (NN day))\n        (PP (IN at)\n          (NP (DT the) (NN office)))))\n    (. .)))&quot;</span>, <span class="hljs-attr">&quot;basicDependencies&quot;</span>: [&#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;ROOT&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;ROOT&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;nsubj&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;today&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;cop&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;is&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;nmod:poss&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;my&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;amod&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;last&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;case&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;office&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;at&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;det&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;office&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">7</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;the&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;nmod&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;office&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;punct&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">9</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;.&quot;</span>&#125;], <span class="hljs-attr">&quot;enhancedDependencies&quot;</span>: [&#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;ROOT&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;ROOT&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;nsubj&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;today&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;cop&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;is&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;nmod:poss&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;my&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;amod&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;last&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;case&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;office&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;at&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;det&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;office&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">7</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;the&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;nmod:at&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;office&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;punct&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">9</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;.&quot;</span>&#125;], <span class="hljs-attr">&quot;enhancedPlusPlusDependencies&quot;</span>: [&#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;ROOT&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;ROOT&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;nsubj&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;today&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;cop&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;is&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;nmod:poss&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;my&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;amod&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;last&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;case&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;office&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;at&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;det&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;office&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">7</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;the&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;nmod:at&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;office&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;punct&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">9</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;.&quot;</span>&#125;], <span class="hljs-attr">&quot;tokens&quot;</span>: [&#123;<span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">&quot;word&quot;</span>: <span class="hljs-string">&quot;today&quot;</span>, <span class="hljs-attr">&quot;originalText&quot;</span>: <span class="hljs-string">&quot;today&quot;</span>, <span class="hljs-attr">&quot;characterOffsetBegin&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">&quot;characterOffsetEnd&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;pos&quot;</span>: <span class="hljs-string">&quot;NN&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">&quot;word&quot;</span>: <span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-attr">&quot;originalText&quot;</span>: <span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-attr">&quot;characterOffsetBegin&quot;</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">&quot;characterOffsetEnd&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">&quot;pos&quot;</span>: <span class="hljs-string">&quot;VBZ&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">&quot;word&quot;</span>: <span class="hljs-string">&quot;my&quot;</span>, <span class="hljs-attr">&quot;originalText&quot;</span>: <span class="hljs-string">&quot;my&quot;</span>, <span class="hljs-attr">&quot;characterOffsetBegin&quot;</span>: <span class="hljs-number">9</span>, <span class="hljs-attr">&quot;characterOffsetEnd&quot;</span>: <span class="hljs-number">11</span>, <span class="hljs-attr">&quot;pos&quot;</span>: <span class="hljs-string">&quot;PRP$&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">&quot;word&quot;</span>: <span class="hljs-string">&quot;last&quot;</span>, <span class="hljs-attr">&quot;originalText&quot;</span>: <span class="hljs-string">&quot;last&quot;</span>, <span class="hljs-attr">&quot;characterOffsetBegin&quot;</span>: <span class="hljs-number">12</span>, <span class="hljs-attr">&quot;characterOffsetEnd&quot;</span>: <span class="hljs-number">16</span>, <span class="hljs-attr">&quot;pos&quot;</span>: <span class="hljs-string">&quot;JJ&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;word&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;originalText&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;characterOffsetBegin&quot;</span>: <span class="hljs-number">17</span>, <span class="hljs-attr">&quot;characterOffsetEnd&quot;</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">&quot;pos&quot;</span>: <span class="hljs-string">&quot;NN&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">&quot;word&quot;</span>: <span class="hljs-string">&quot;at&quot;</span>, <span class="hljs-attr">&quot;originalText&quot;</span>: <span class="hljs-string">&quot;at&quot;</span>, <span class="hljs-attr">&quot;characterOffsetBegin&quot;</span>: <span class="hljs-number">21</span>, <span class="hljs-attr">&quot;characterOffsetEnd&quot;</span>: <span class="hljs-number">23</span>, <span class="hljs-attr">&quot;pos&quot;</span>: <span class="hljs-string">&quot;IN&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-number">7</span>, <span class="hljs-attr">&quot;word&quot;</span>: <span class="hljs-string">&quot;the&quot;</span>, <span class="hljs-attr">&quot;originalText&quot;</span>: <span class="hljs-string">&quot;the&quot;</span>, <span class="hljs-attr">&quot;characterOffsetBegin&quot;</span>: <span class="hljs-number">24</span>, <span class="hljs-attr">&quot;characterOffsetEnd&quot;</span>: <span class="hljs-number">27</span>, <span class="hljs-attr">&quot;pos&quot;</span>: <span class="hljs-string">&quot;DT&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">&quot;word&quot;</span>: <span class="hljs-string">&quot;office&quot;</span>, <span class="hljs-attr">&quot;originalText&quot;</span>: <span class="hljs-string">&quot;office&quot;</span>, <span class="hljs-attr">&quot;characterOffsetBegin&quot;</span>: <span class="hljs-number">28</span>, <span class="hljs-attr">&quot;characterOffsetEnd&quot;</span>: <span class="hljs-number">34</span>, <span class="hljs-attr">&quot;pos&quot;</span>: <span class="hljs-string">&quot;NN&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-number">9</span>, <span class="hljs-attr">&quot;word&quot;</span>: <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-attr">&quot;originalText&quot;</span>: <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-attr">&quot;characterOffsetBegin&quot;</span>: <span class="hljs-number">35</span>, <span class="hljs-attr">&quot;characterOffsetEnd&quot;</span>: <span class="hljs-number">36</span>, <span class="hljs-attr">&quot;pos&quot;</span>: <span class="hljs-string">&quot;.&quot;</span>&#125;]&#125;]&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>最终输出：<br>today O<br>is O<br>my O<br>last O<br>day O<br>at O<br>the O<br>office O<br>. O</p></blockquote><h3 id="模型框架"><a href="#模型框架" class="headerlink" title="模型框架"></a>模型框架</h3><p><img src="https://user-images.githubusercontent.com/73998546/183022036-0d0fcb88-8e00-4fff-96b4-9049d7d47a26.png" alt="模型框架"></p><p>AESINER由6个模块组成。</p><h4 id="1-Embedding-Layer-amp-Encoder"><a href="#1-Embedding-Layer-amp-Encoder" class="headerlink" title="1.Embedding Layer &amp; Encoder"></a>1.Embedding Layer &amp; Encoder</h4><p>以transformer作为上下文编码器，输出单字在句子中的向量表示<br><code>输入：文本</code><br><code>输出：文本中各个字融合了全文语义信息后的向量表示</code></p><h4 id="2-句法信息提取"><a href="#2-句法信息提取" class="headerlink" title="2.句法信息提取"></a>2.句法信息提取</h4><p><img src="https://user-images.githubusercontent.com/73998546/183026914-e2868d7d-f662-4929-a11f-641d1359ed79.png" alt="句法信息提取"></p><p><strong>For POS LABELS</strong>:我们将每个 xi 视为中心字并采用±1字的窗口来提取<br>它的上下文词及其对应的词性标签。<br>例如，在图 (a) 的示例中，对于“Salt”，±1 字窗口覆盖其左侧和右侧的单词，以便生成的上下文特征是“Salt”、“is”和“Lake”，我们使用这些词及其词性标签的组合作为POS 信息（即“Salt NNP”、“is BVZ”和“Lake NNP”）用于 NER 任务。</p><p><strong>For syntactic constituents</strong>：我们从 xi 开始(X 的语法树的叶子)，然后向上搜索树来找到第一个可接受的语法节点2,并选择该节点下的所有标记作为上下文特征，并将它们组合起来用语法节点2获取成分信息。<br>例如，在图 (b) 中，我们从“Salt”开始并提取其第一个接受节点“NP”，然后收集“NP”下的token作为上下文特征（即“Salt”、“Lake”和“City”）并将它们组合起来<br>用“NP”来获取成分信息（即，“Salt NP”, “Lake NP”, and “City NP”)。</p><p><strong>For dependency relations</strong>：对于依赖关系，我们找到所有上下文，通过收集其所有依赖项来为每个 xi 提供特征。<del>然后考虑上下文特征的组合和它们的入站依赖类型作为相应的依赖信息。</del>（不说人话是吧，直接看例子）<br>例如，如图 (c) 所示，对于“Salt”，其上下文特征是“Salt”和“City”，以及它们对应的依赖信息是“Salt compound”和“City root”.</p><p><code>输入：字向量</code><br><code>输出：每个字对应的POS LABELS、syntactic constituents、dependency relations的key-values向量表示</code></p><h4 id="3-kvmn模块"><a href="#3-kvmn模块" class="headerlink" title="3.kvmn模块"></a>3.kvmn模块</h4><p>由于句法信息是从现成的工具包，可能有提取的句法信息中的噪声，其中如果使用不当，可能会损害模型性能。此模型提出了一个 KVMN 模块（Mc)对成对组织的上下文特征进行建模和句法信息实例。</p><p><img src="https://user-images.githubusercontent.com/73998546/183028144-86a78bae-b95a-4fbc-a4b7-5d6980bd0c57.png" alt="kvmn模块"></p><p>首先映射它的上下文特征和句法信息到 KVMN 中的键和值，用Kc i = [k c i,1 , . . . , kc i,j , . . . , kc i,mi ]和V c i = [v c i,1 , . . . , vc i,j , . . . , vc i,mi ]表示</p><p><img src="https://user-images.githubusercontent.com/73998546/183028378-d97127d1-725e-4231-8e96-95aa720103e4.png" alt=" "><br><img src="https://user-images.githubusercontent.com/73998546/183028397-f39ba36b-043e-4d12-8132-e001a7caca2b.png" alt=" "></p><p>Si是Mc（即KVMN模块）的输出<br>KVMN 保证了句法信息根据其对应的上下文特征进行加权，以便重要信息可以相应地加以区分和利用</p><p><code>输入：每个字对应的POS LABELS、syntactic constituents、dependency relations的key-values向量</code><br><code>输出：由k-v映射出的si向量</code></p><h4 id="4-The-Syntax-Attention"><a href="#4-The-Syntax-Attention" class="headerlink" title="4.The Syntax Attention"></a>4.The Syntax Attention</h4><p><img src="https://user-images.githubusercontent.com/73998546/183029034-3dd082e4-e2bd-40b6-8c5e-5d8338398dc9.png" alt="Syntax Attention模块"><br>在对每种类型的句法信息进行编码时通过 KVMN，最直接的做法是把他们直接相连。然而考虑到不同的句法信息可能会相互冲突，所以采用一个更有效的方式将它们结合起来。</p><p><code>输入：si向量</code><br><code>输出：si‘是不同句法类型的syntax attention的输出</code></p><h4 id="5-The-Gate-Mechanism"><a href="#5-The-Gate-Mechanism" class="headerlink" title="5.The Gate Mechanism"></a>5.The Gate Mechanism</h4><p>AESI模型提出了一种门机制 (GM) 将其合并到主干 NER 模型中，其中这种机制可以动态加权并决定如何在标记 NE 时利用句法信息。</p><p><img src="https://user-images.githubusercontent.com/73998546/183235285-305dce78-1160-49cd-9486-ff39dc12f85a.png" alt="Gate Mechanism"></p><p>主要操作是重置函数ri得到来自上下文编码器的编码和语法注意</p><p><img src="https://user-images.githubusercontent.com/73998546/183235767-3baaf8fb-6b0f-48c1-8de7-47fcff7dad4e.png" alt=" "><br><img src="https://user-images.githubusercontent.com/73998546/183235768-f60289ab-4954-4183-98fd-b99e658593c0.png" alt=" "></p><p><code>输入：si‘和hi（融合了全文语义信息后的字向量表示）</code><br><code>输出：Oi（对应于输入xi的门机制输出）</code></p><h4 id="6-Output-layer"><a href="#6-Output-layer" class="headerlink" title="6.Output layer"></a>6.Output layer</h4><p>将oi用一个可训练的矩阵 Wo 用于将其维度对齐到ui = Wo · oi 的输出空间得到yi。之后应用条件随机场 (CRF) 解码器预测标签 y^i ∈ T（其中 T 是具有所有NE标签），再输出序列Y</p><p><code>输入：oi</code><br><code>输出：最终的标签序列Y</code></p><p>参考论文<br><a href="https://arxiv.org/pdf/2010.15466.pdf">Improving Named Entity Recognition with<br>Attentive Ensemble of Syntactic Information</a></p>]]></content>
    
    
    <categories>
      
      <category>NER</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NER</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关系三重提取的新框架</title>
    <link href="/posts/e938ff54.html"/>
    <url>/posts/e938ff54.html</url>
    
    <content type="html"><![CDATA[<h2 id="CASREL模型的分析"><a href="#CASREL模型的分析" class="headerlink" title="CASREL模型的分析"></a>CASREL模型的分析</h2><p>在做知识图谱的工作时，我们面临的首要问题是对一段语料进行实体识别(NER)和关系抽取(RE)。</p><p><del>啥？知识图谱是啥？</del></p><blockquote><p>A knowledge graph, also known as a semantic network, represents a network of real-world entities—i.e. objects, events, situations, or concepts—and illustrates the relationship between them. This information is usually stored in a graph database and visualized as a graph structure, prompting the term knowledge “graph.”</p></blockquote><p><img src="https://user-images.githubusercontent.com/73998546/182825426-f5f2a104-51eb-4ccd-b340-5a990a1c615a.png" alt="知识图谱"></p><p>简而言之，我们现实生活中的一切都可以用三元组（主语，关系，宾语）表示，抽象到图的数据结构中，圈圈代表主语和宾语，连接圈圈的箭头表示关系。</p><p>知识图谱的关键成分是关系事实，其中大部分由两个实体组成，由语义关系连接。 这些事实是以（主语，关系，宾语）或（s，r，o）的形式，称为关系三元组。</p><p>在之前的做法中，针对关系提取最早的做法是<strong>管道方法</strong>。它首先识别句子中的所有实体，然后对每个实体对进行关系分类。这种方法往往会受到错误传播问题的影响，因为早期阶段的错误无法在早期阶段得到纠正。</p><p>为了解决这个问题，后续大牛们提出了<strong>实体和关系的联合学习</strong>，其中有基于特征的模型以及神经网络模型。但是现有方法不能有效处理一个句子包含多个关系三元组的情况。<br>而且这些提取重叠三元组的工作仍有很多不足之处。</p><p>我们来看看当有多个三元组时，可能会出现的问题：</p><p>Normal：<font color=Green>华科</font>学生<font color=Green>wpy</font>邀请<font color=Green>腾讯</font>老板<font color=Green>马化腾</font>上模电课<br>关系三元组：（wpy，就读于，华科），（马化腾，CEO，腾讯）</p><p>EPO:<font color=Green>姜文</font>在他导演的<font color=Green>让子弹飞</font>中出演张麻子<br>关系三元组：（姜文，出演，让子弹飞），（姜文，导演，让子弹飞）</p><p>SEO：<font color=Green>我</font>出生在<font color=Green>河南</font>，<font color=Green>郑州</font><br>关系三元组：（我，出生地，河南），（我，出生地，郑州），（郑州，是…省会，河南）</p><blockquote><p>EPO:EntityPairOverlap<br>SEO:SingleEntityOverlap overlapping patterns.</p></blockquote><p>面对上面的三元组重叠问题，现有方法都不能很好的解决。</p><p>具体来说，它们都将关系视为分配给实体对的离散标签。这个公式使关系分类成为一个困难的机器学习问题。<strong>首先，类分布高度不平衡</strong>。在所有提取的实体对中，大多数都没有形成有效的关系，产生了太多的反面例子。<strong>其次，当同一实体参与多个有效关系（重叠三元组）时，分类器可能会混淆。</strong>如果没有足够的训练样本，分类器很难分辨出实体参与了哪个关系。因此，提取的三元组是通常不完整和不准确。</p><p>这就体现出来CASREL牛逼的地方了，别人不能解决的，他行啊。</p><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><p>该框架的核心是全新的观点，即我们可以将关系建模为将主体映射到对象的函数，而不是将关系视为实体对上的离散标签。这完全颠覆了以往的离散思想，而是把关系作为函数进行训练。更准确地说，我们<strong>不是学习关系分类器 f(s, o) → r</strong>，而是<strong>学习关系特定标记器 fr(s) → o，</strong>每个标记器都识别特定关系下给定实体s的可能对象；或不返回对象，表示有没有给定实体s和关系的三元组。</p><p>在这个框架下，三重提取是一个两步过程：</p><p><strong>1.我们识别一个句子中所有可能的实体s；</strong></p><p><strong>2.对于每个实体s，我们应用关系特定的标记器来同时识别所有可能的关系和相应的对象。</strong></p><p>CASREL框架将实现上述步骤。它由一个<strong>BERT 模块</strong>、一个<strong>subject标记模块</strong>和一个<strong>特定于关系的object标记模块</strong>组成。</p><h4 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h4><blockquote><p>到了头疼的公式推导环节，非战斗人员请撤离</p></blockquote><p>给定注释的句子 xj 从训练集 D 和一组可能重叠的xj 中的三元组 Tj = {(s, r, o)} ：<br><img src="https://user-images.githubusercontent.com/73998546/182838469-44b3758e-663c-4592-becf-15da5e316150.png" alt="公式推导"><br>第二步应用了概率的链式法则方程。第三步，我们应该承认：<strong>对于一个给定的主题 s，与 s 相关的任何关系（Tj |s 中的那些）会导致句子中出现对应的宾语，并且所有其他关系必然没有句子中的宾语，即“空”宾语。</strong></p><p>我们的目的是把公式（3）的每一块尽量提高，以保证最后结果最大。（即最大化训练集 D 的数据似然度）</p><h4 id="模型框架"><a href="#模型框架" class="headerlink" title="模型框架"></a>模型框架</h4><p>事实上，这种新颖的标记方案使我们能够一次提取多个三元组：我们首先运行subject标记器以查找句子中所有可能的subject，然后对于找到的每个subject，应用特定于关系的object标记器以查找所有相关的关系和对应的object。<br><img src="https://user-images.githubusercontent.com/73998546/182839709-7f967c70-5bc1-4fb4-9268-81e0a9a7ee8c.png" alt="模型框架"></p><blockquote><p>An overview of the proposed CASREL framework. In this example, there are three candidate subjects detected at the low level, while the presented 0/1 tags at high level are specific to the first subject Jackie R. Brown, i.e., a snapshot of the iteration state when k = 1 is shown as above. For the subsequent iterations (k = 2, 3), the results at high level will change, reflecting different triples detected. For instance, when k = 2, the high-level orange (green) blocks will change to 0 (1), respectively, reflecting the relational triple (Washington, Capital of,United States Of America) led by the second candidate subject Washington.</p></blockquote><h5 id="BERT-ENCODER"><a href="#BERT-ENCODER" class="headerlink" title="BERT ENCODER"></a>BERT ENCODER</h5><p><img src="https://user-images.githubusercontent.com/73998546/182840186-999b5114-8c15-48db-9018-2553e2ce7409.png" alt=" "><br>其中 S 是输入句子中子词索引的 one-hot 向量矩阵，Ws 是子词嵌入矩阵，Wp是位置嵌入矩阵，其中 p 表示位置输入序列中的索引，hα是隐藏状态<br>向量，即输入句子在第α层的上下文表示，N是Transformer块的数量。</p><p><code>输入：单个文本句子</code><br><code>输出：综合文本信息的单词向量矩阵</code></p><h5 id="Cascade-Decoder"><a href="#Cascade-Decoder" class="headerlink" title="Cascade Decoder"></a>Cascade Decoder</h5><p>首先，我们从输入句子中检测主体s。 然后对于每个候选主体s，我们检查所有可能的关系，看看是否有关系可以将句子中的对象与该主体s相关联。<br>这又分为两个模块</p><h6 id="1-Subject-Tagger"><a href="#1-Subject-Tagger" class="headerlink" title="1.Subject Tagger"></a>1.Subject Tagger</h6><p>通过直接解码 N 层 BERT 编码器产生的编码向量 hN 来识别输入句子中所有可能的主体。<br>它采用两个相同的二元分类器来检测对象的开始和结束位置，如果概率超过某个特定阈值，则标记为 1，否则标签 0<br><img src="https://user-images.githubusercontent.com/73998546/182840329-1412ccd7-bbf6-4a23-8200-8aa8c167d459.png" alt=" "><br>W是训练权重，xi=hn[i],b是偏差，derta是激活函数<br>此外论文中还提到了实体跨度的监测，在此不再赘述</p><h6 id="2-Relation-specific-Object-Taggers"><a href="#2-Relation-specific-Object-Taggers" class="headerlink" title="2.Relation-specific Object Taggers"></a>2.Relation-specific Object Taggers</h6><p>所有对象标记器object taggers将同时为每个检测到的对象识别相应的对象。<br><img src="https://user-images.githubusercontent.com/73998546/182840360-96fc9871-1cb1-479a-844a-66a8e751e566.png" alt=" "></p><p>参考论文<br><a href="https://arxiv.org/pdf/1909.03227.pdf">A Novel Cascade Binary Tagging Framework for Relational Triple Extraction</a></p>]]></content>
    
    
    <categories>
      
      <category>NER</category>
      
      <category>RE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NER</tag>
      
      <tag>RE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BERT-BiLSTM-CRF</title>
    <link href="/posts/7a6a6b5a.html"/>
    <url>/posts/7a6a6b5a.html</url>
    
    <content type="html"><![CDATA[<h1 id="BERT-BiLSTM-CRF模型分析"><a href="#BERT-BiLSTM-CRF模型分析" class="headerlink" title="BERT-BiLSTM-CRF模型分析"></a>BERT-BiLSTM-CRF模型分析</h1><p>上学期搞大创的时候接触了NER相关的模型和知识，暑假终于有时间整理一下乐</p><p>首先先了解一下BERT-BiLSTM-CRF的应用场景，这种方法主要用于命名实体识别。简单来讲，就是在一段语料中抽出其中的名词进行划分。<br>先上例子，以提取公司企业和人物实体为例：</p><p><code>输入： &#123;&quot;text&quot;: &quot;作为蔚来汽车的 a 轮投资人，刘二海已经是第二次见证李斌在纽交所敲钟，第一次是李斌创办的易车在纽交所上市。&#125;</code><br><code>输出： &#123;&quot;label&quot;: &#123;&quot;person&quot;: &#123;&quot;刘二海&quot;: [13, 15]&#125;, &quot;org&quot;: &#123;&quot;蔚来汽车&quot;: [2，5]&#125;&#125;&#125;</code></p><p>输入一段文本 text，输出的标签为句子中的organization 和 person 实体</p><p>需要明确的是，BERT-BiLSTM-CRF是有监督分类问题，训练语料一定要给出训练文本对应的标注。</p><p>那么我们如何从一段语料中“聪明地”获取实体并打上标签呢？<br>上模型！</p><h3 id="模型框架"><a href="#模型框架" class="headerlink" title="模型框架"></a>模型框架</h3><p><img src="https://user-images.githubusercontent.com/73998546/182521959-df17f189-c427-4a99-a38b-1b52ce78de4e.png" alt="模型框架"></p><p>BERT-CRF 模型由 3 个模块组成。首先使用 BERT 模型获取字向量，提<br>取文本重要特征；之后由 BiLSTM 层对 BERT 的输出序列处理，通过双向 LSTM 计算输入隐藏信息；<br>在CRF层，结合 CRF 中的状态转移矩阵，根<br>据相邻之间标签得到一个全局最优序列。</p><h4 id="BERT层"><a href="#BERT层" class="headerlink" title="BERT层"></a>BERT层</h4><p>模型第一层是利用预训练的 BERT 语言模型初始化获取输入文本信息中的字向量记为<br>序列 E=(e1,e2,e3,⋯ ,en) , 所获取的字向量能够利用词与词之间的相互关<br>系</p><p>BERT 是一种自然语言处理预训练语言表征模型. BERT 能够计算词语之间的相互关系, 并利用所计算的关系调节权重提取文本中的重要特征, 利用自注意力机制的结构来进行预<br>训练, 基于所有层融合左右两侧语境来预训练深度双向表征, 比起以往的预训练模型, 它捕<br>捉到的是真正意义上的上下文信息, 并能够学习到连续文本片段之间的关系.</p><h4 id="BiLSTM"><a href="#BiLSTM" class="headerlink" title="BiLSTM"></a>BiLSTM</h4><p>想要知道BiLSTM是什么，需要先了解LSTM是干嘛的</p><p>LSTM 长短期记忆网络<br>是一种特殊的循环神经网络。RNN 网络主要包括输入层、隐藏层和输出层三部分组成，<br>隐藏层连接前后两层，这种特殊的结构，能让 RNN 网络具有一定的“记忆能力，能够有效<br>处理命名实体识别任务。</p><h5 id="LSTM框架"><a href="#LSTM框架" class="headerlink" title="LSTM框架"></a>LSTM框架</h5><p><img src="https://user-images.githubusercontent.com/73998546/182525122-b3fe78f8-650e-419b-9b72-7ba250c895db.png" alt="LSTM框架"><br>LSTM模型可以理解为：现在有一串细胞代表着不同时刻的状态（C0，C1…Ct），他们是串联关系。在t时刻，你有三个输入，分别为上一细胞状态Ct-1、隐藏层ht-1和输入词Xt。在经过细胞Ct后，你将得到本细胞的隐藏信息ht和此时新的细胞状态Ct。<br>在每个细胞中具体有遗忘门，记忆门和输出门，让我们看看这些可爱的小细胞是如何工作的吧</p><p><strong>计算过程</strong><br>计算过程的思路就是，将遗忘信息和新的信息整合起来，得到有用的信息传递给下一细胞，同时丢弃无用信息。并在每一时刻输出隐层状态ht，ht相当于一个中间参数，参与到下一层的信息计算中。</p><ul><li><p>计算<strong>遗忘门</strong><br><code>输入：前一时刻隐藏状态ht-1,输入词Xt</code><br><code>输出：遗忘门的值ft</code><br><img src="https://user-images.githubusercontent.com/73998546/182526393-185580bb-f2f9-45bf-97bd-59b6785bf134.png" alt="遗忘门"></p></li><li><p>计算<strong>记忆门</strong><br><code>输入：前一时刻隐藏状态ht-1,输入词Xt</code><br><code>输出：记忆门的值it，临时细胞状态Ct</code><br><img src="https://user-images.githubusercontent.com/73998546/182526419-d7ee10bb-90cb-437a-91c1-30a965ddd351.png" alt="记忆门"></p></li><li><p>更新<strong>细胞状态</strong><br><code>输入：记忆门的值it，遗忘门的值ft，上一细胞状态Ct-1，临时细胞状态Ct</code><br><code>输出：当前细胞状态Ct</code><br><img src="https://user-images.githubusercontent.com/73998546/182526444-b82c367d-ef01-4241-a43f-a6d82012efef.png" alt="细胞状态更新"></p></li><li><p>计算<strong>隐藏层</strong><br><code>输入：前一时刻隐藏状态ht-1,输入词Xt ，当前细胞状态Ct</code><br><code>输出：隐层状态ht</code><br><img src="https://user-images.githubusercontent.com/73998546/182526465-c75c0560-5471-4e96-8188-0d826f189c57.png" alt="最后输出"></p></li></ul><p>一顿操作下来，我们得到了和原始句子一样长的隐层状态序列[h0,h1…hn-1]</p><h5 id="BiLSTM框架"><a href="#BiLSTM框架" class="headerlink" title="BiLSTM框架"></a>BiLSTM框架</h5><p>知道了LSTM的计算流程，他是从一个方向得到状态序列。进一步想，我们如果从两个方向（从左到右，从右到左）进行LSTM的运算，并将两个结果合并，是否能得到更全面的语义信息呢</p><p>SMART GUY!这就是BiLSTM的思路。</p><p><img src="https://user-images.githubusercontent.com/73998546/182528230-0d562287-b91b-42eb-928b-660ed09b89f2.png" alt="BiLSTM框架"><br>我们对一句话进行两个方向的LSTM计算，最后将两者捏在一起。这样每个词和前后的词都存在关联性，在ner中能表现出更好的性能。</p><h4 id="CRF层"><a href="#CRF层" class="headerlink" title="CRF层"></a>CRF层</h4><p>CRF 用来分割和标记序列数据, 根据输入的观察序列来预测对应的状态序列, 同时考<br>虑输入的当前状态特征和各个标签类别转移特征, 被广泛应用于 NER 的问题中.</p><p><img src="https://user-images.githubusercontent.com/73998546/182520083-e46c0fd1-f27d-409a-8a49-b4a2d5ffb3de.png" alt="CRF层"><br>如上图可知，BiLSTM层输出全文的向量表示后，得到这个词对应每个标签的权重。<br>CRF层会选取权重较高的标签，注意不是最高。他还会从训练数据中学习约束，确保选取标签的合理性。<br>CRF 层可以为最终预测的标签添加一些约束（如句子中第一个单词的标签应该以“B-”或“O”开头，而不是“I-”、“B-label1 I-label2 I-label3 I-…”，<br>在这个模式中，label1、label2、label3…应该是同一个命名实体标签），以减少无效预测标签序列的数量。这些约束可以在训练过程中由 CRF 层自动从训练数据集中学习。<br><em>约束可能是：<br>句子中第一个单词的标签应该以“B-”或“O”开头，而不是“I-” “B-label1 I-label2 I-label3 I-…”，在这个模式中，label1、label2、label3…应该是同一个命名实体标签。例如，“B-Person I-Person”有效，但“B-Person I-Organization”无效。<br>“O I-label”无效。一个命名实体的第一个标签应该以“B-”而不是“I-”开头，换句话说，有效模式应该是“O B-label</em></p><p>再回头梳理一遍<strong>模型IO</strong><br><code>原始输入：语句文本</code><br><strong>BERT 层</strong>：<br><code>输入：</code><br>①由原始文本利用 word2Vector 等算法得到的原始字向量<br>②文本向量：该向量的取值在模型训练过程中自动学习，用于刻画文本的全局语义信息，<br>并与单字/词的语义信息相融合<br>③位置向量：刻画不同位置的字，对不同位置的字附加一个不同的向量加以区分<br><code>输出：文本中各个字融合了全文语义信息后的向量表示</code><br><strong>BiLSTM层</strong>：<br><code>输入：BERT 模型的输出序列</code><br><code>输出：每个字对应的标签权重</code><br><strong>CRF 层</strong>：<br><code>输入：每个字对应的标签权重</code><br><code>输出：预测的标签序列</code><br><img src="https://user-images.githubusercontent.com/73998546/182521959-df17f189-c427-4a99-a38b-1b52ce78de4e.png" alt=" "><br>复习一下前面的图~<br>over</p>]]></content>
    
    
    <categories>
      
      <category>NER</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NER</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SAT问题及DPLL简述</title>
    <link href="/posts/935b2a8c.html"/>
    <url>/posts/935b2a8c.html</url>
    
    <content type="html"><![CDATA[<h2 id="聊聊SAT问题是什么"><a href="#聊聊SAT问题是什么" class="headerlink" title="聊聊SAT问题是什么"></a>聊聊SAT问题是什么</h2><blockquote><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3></blockquote><p>SAT问题又称命题逻辑公式的可满足性问题（satisfiability problem），是判断对合取范式形式给出的命题逻辑公式是否存在一个真值指派使得该逻辑公式为真。SAT问题是计算机科学与人工智能基本问题，是一个典型的NP完全问题。看似简单，却可广泛应用于许多实际问题如人工智能、电子设计自动化、自动化推理、硬件设计、安全协议验证等，具有重要理论意义与应用价值。对于SAT问题的研究从没有停止过，在1997年和2003年，H.Kautz与B.Selman两次列举出SAT搜索面临的挑战性问题，并于2011年和2007年，两度对当时的SAT问题研究现状进行了全面的综述。黄文奇提出的Solar算法在北京第三届SAT问题快速算法比赛中获得第一名。对SAT问题的求解主要有完备算法和不完备算法两大类。不完备算法主要是局部搜索算法，这种算法不能保证一定找到解，但是求解速度快，对于某些SAT问题的求解，局部搜索算法要比很多完备算法更有效。完备算法出现的时间更早，优点是可以正确判断SAT问题的可满足性，在算例无解的情况下可以给出完备的证明。对于求解SAT问题的优化算法主要有启发式算法、冲突子句学习算法、双文字监视法等。</p><blockquote><h3 id="研究意义"><a href="#研究意义" class="headerlink" title="研究意义"></a>研究意义</h3></blockquote><p>SAT问题是第一个被证明的NP完全问题，而NP完全问题由于其极大的理论价值和困难程度，破解后将会在许多领域得到广泛应用，从而在计算复杂性理论中具有非常重要的地位。由于所有的NP完全问题都能够在多项式时间内进行转换，那么如果SAT问题能够得到高效解决，所有的NP完全问题都能够在多项式时间内得到解决。对SAT问题的求解，可用于解决计算机和人工智能领域内的CSP问题（约束满足问题）、语义信息的处理和逻辑编程等问题，也可用于解决计算机辅助设计领域中的任务规划与设计、三维物体识别等问题。SAT问题的应用领域非常广泛，还能用于解决数学研究和应用领域中的旅行商问题和逻辑算数问题。许多实际问题，例如数据库检索、积木世界规划、超大规模集成电路设计、人工智能等都可以转换成SAT问题进而进行求解。可见对SAT问题求解的研究，具有重大意义。</p><blockquote><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3></blockquote><p>SAT问题即命题逻辑公式的可满足性问题（satisfiability problem），是计算机科学与人工智能基本问题，是一个典型的NP完全问题，可广泛应用于许多实际问题如硬件设计、安全协议验证等，具有重要理论意义与应用价值。SAT问题也是程序设计与竞赛的经典问题。<br>对于任一布尔变元x，x与其非“¬x”称为文字(literal)。对于多个布尔变元，若干个文字的或运算l1∨l2∨…∨lk称为子句(clause)。只含一个文字的子句称为单子句。不含任何文字的子句称为空子句，常用符号□表示。子句所含文字越多，越易满足，空子句不可满足。<br>SAT问题一般可描述为：给定布尔变元集合{x1, x2, …, xn}以及相应的子句集合{c1, c2, …, cm}，对于合取范式（CNF范式）：F = c1∧c2∧…∧cm，判定是否存在对每个布尔变元的一组真值赋值使F为真，当为真时（问题是可满足的，SAT），输出对应的变元赋值（一组解）结果。<br>一个CNF公式也可以表示成子句集合的形式：S={c1,c2,…,cm}.<br>例如，由三个布尔变元a,b,c所形成的一个CNF公式（¬a∨b）∧（¬b∨c）,可用集合表示为{¬a∨b,¬b∨c}，该公式是满足的，a=0, b=0,c=1是其一组解。 </p><blockquote><h3 id="cnf文件解读"><a href="#cnf文件解读" class="headerlink" title="cnf文件解读"></a>cnf文件解读</h3></blockquote><p>一个CNF SAT公式或算例的具体信息通常存储在一个.cnf文件中，下图是算例problem1.cnf文件前若干行的截图。</p><p><img src="https://user-images.githubusercontent.com/73998546/133534700-41b7c5f8-9448-4cea-a079-763b69aa4988.png" alt="1(1)"></p><p>在每个CNF文件的开始，由‘c’开头的是若干注释说明行；‘p’开头的行说明公式的总体信息，包括：范式为CNF；公式有200个布尔变元，由1到200的整数表示；320个子句。之后每行对应一个子句，0为结束标记。46表示第46号变元，且为正文字；-46则是对应的负文字，文字之间以空格分隔。</p><p>DPLL算法是经典的SAT完备型求解算法，对给定的一个SAT问题实例，理论上可判定其是否满足，满足时可给出对应的一组解。</p><h2 id="DPLL算法是什么呢"><a href="#DPLL算法是什么呢" class="headerlink" title="DPLL算法是什么呢"></a>DPLL算法是什么呢</h2><p>DPLL算法是基于树/二叉树的回溯搜索算法，主要使用两种基本处理策略：</p><p>单子句规则。如果子句集S中有一个单子句L,那么L一定取真值，于是可以从S中删除所有包含L的子句（包括单子句本身），得到子句集S1，如果它是空集，则S可满足。否则对S1中的每个子句，如果它包含文字¬L,则从该子句中去掉这个文字，这样可得到子句集合S2。S可满足当且仅当S2可满足。单子句传播策略就是反复利用单子句规则化简S的过程。</p><p>分裂策略。按某种策略选取一个文字L.如果L取真值，则根据单子句传播策略，可将S化成S2；若L取假值（即¬L成立）时，S可化成S1.</p><p>交错使用上述两种策略可不断地对公式化简，并最终达到终止状态，其执行过程可表示为一棵二叉搜索树,如下图所示。</p><p><img src="https://user-images.githubusercontent.com/73998546/133535483-b924184a-7b00-4034-9e67-5489e8e7cec1.png" alt="1(2)"></p><p>基于单子句传播与分裂策略的DPLL算法可以描述为一个如后所示的递归过程DPLL( S ), DPLL算法也可用非递归实现。</p><div class="hljs code-wrapper"><pre><code>DPLL( S) :/* S为公式对应的子句集。若其满足，返回TURE；否则返回FALSE. */&#123;while(S中存在单子句) &#123;//单子句传播在S中选一个单子句L；依据单子句规则，利用L化简S；if S = Φ return(TRUE);else if (S中有空子句 ) return（FALSE）；&#125;//while基于某种策略选取变元v；         //策略对DPLL性能影响很大if DPLL（S ∪v ）return(TURE);  //在第一分支中搜索return DPLL(S ∪¬v);//回溯到对v执行分支策略的初态进入另一分支&#125;</code></pre></div><p>对于公式{¬1∨2, ¬2，¬3∨4, 3∨¬5,3∨4, 3∨5，¬2∨¬5∨6} ,大家可以利用DPLL算法进行手动推理其搜索处理及回溯过程，获得求解结果。</p>]]></content>
    
    
    <categories>
      
      <category>由SAT问题引发的小思考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法重写</title>
    <link href="/posts/5504c575.html"/>
    <url>/posts/5504c575.html</url>
    
    <content type="html"><![CDATA[<p>发生在类的继承中，这个方法子和父名称一样，子生效<br><a name="44XsM"></a></p><h3 id="重写（override）规则："><a href="#重写（override）规则：" class="headerlink" title="重写（override）规则："></a>重写（override）规则：</h3><ol><li>参数列表必须完全与被重写方法相同</li><li>返回类型必须完全与被重写的返回类型相同</li><li>访问权限不能比父类中被重写的访问权限更低。例如：如果父类的一个方法被声明为public，name子类中重写该方法就不能声明为protected</li><li>父类的成员方法只能被他的子类重写</li><li>声明为static和private的方法不能被重写，但是能够被再次声明<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> stsic <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Student s = <span class="hljs-keyword">new</span> Student();<br>        s.say();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span>&#123;<br>        System.<span class="hljs-function">out <span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;锄禾日当午，汗滴禾下土&quot;</span>)</span></span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">class Student extends Person</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;床前明月光&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><p><a name="Gotao"></a></p><h4 id="注意：面试题：Java中重写（override）和重载（overland）的区别"><a href="#注意：面试题：Java中重写（override）和重载（overland）的区别" class="headerlink" title="注意：面试题：Java中重写（override）和重载（overland）的区别"></a>注意：面试题：Java中重写（override）和重载（overland）的区别</h4><ol><li>重写是发生在子父类中的操作</li><li>重载是一个类里面参数列表的长度、参数类型和参数类型顺序不同（分为构造方法重载和方法重载）</li></ol><p>a. 发生的位置<br />重载：一个类中<br />重写：子父类中<br />b. 参数列表限制<br />重载：必须不同<br />重写：必须相同<br />c. 返回值类型：<br />重载：与返回值类型无关<br />重写：返回值类型必须一致<br />d. 访问权限：<br />重载：与访问权限无关<br />重写： 子的方法权限 必须不能小于 父的方法权限<br />e.异常（bug）处理：<br />重载：与异常无关<br />重写：可以减少或删除（异常范围可以更小更精准，但是不能抛出新的异常）<br /><br><br /></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>final关键字</title>
    <link href="/posts/af55167d.html"/>
    <url>/posts/af55167d.html</url>
    
    <content type="html"><![CDATA[<p>final用于修饰属性、变量<br />变量成为了常量，无法对其再次进行赋值<br />final修饰的局部变量，只能赋值一次（可以先声明后赋值）<br />final修饰的是成员属性，必须在声明时赋值<br />全局常量（public static final）<br /><br><br />常量的命名规范：<br />由一个或多个单词组成，单词与单词之间必须使用下划线隔开，单词中所有字母大写<br />例如：SQL_INSET<br /><br><br /><br><br />final用于修饰类<br />final修饰的类，不可以被继承<br />final用于修饰方法<br />final修饰的方法，不能被子类重写<br />全局常量（public static final）<br /></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>异常处理</title>
    <link href="/posts/28877bf.html"/>
    <url>/posts/28877bf.html</url>
    
    <content type="html"><![CDATA[<p>情况描述：当程序出现bug时，Java虚拟机发现异常，虚拟机就会new出来一个新的对象，用类似返回的方式返回错误类型和异常原因，同时中断程序。</p><h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><p>对异常进行处理，捕获异常，避免异常返回使程序中断</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//有可能发生异常的代码</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">1</span> 对象名<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-comment">//异常的操作</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">1</span> 对象名<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-comment">//异常的操作</span><br>&#125;...<br><span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-comment">//异常的统一出口</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>catch语句相当于if语句<br />如果满足异常类型，则实现代码块里面的操作<br /><br><br />易错警告<br />eg1.</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.java.demo1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Person p =haha();<br>        System.out.println(p.age);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Person <span class="hljs-title">haha</span><span class="hljs-params">()</span></span>&#123;<br>        Person p = <span class="hljs-keyword">new</span> Person();<br>       <span class="hljs-keyword">try</span>&#123;<br>           p.age = <span class="hljs-number">18</span>;<br>           <span class="hljs-keyword">return</span> p;<br>       &#125;<span class="hljs-keyword">finally</span>&#123;<br>           p.age = <span class="hljs-number">28</span>;<br>       &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>        <span class="hljs-keyword">int</span> age;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//始终是一个对象，最后执行finally，p.age年龄被更改</span><br></code></pre></div></td></tr></table></figure><p>eg2.</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.java.demo1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> a =haha();<br>        System.out.println(a);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">haha</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;<span class="hljs-keyword">finally</span>&#123;<br>            a = <span class="hljs-number">20</span>;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//return a;中的a是被备份的那个</span><br><span class="hljs-comment">//实际上又开辟了一块内存空间，这是返回的a和finally中的赋值的a无关</span><br></code></pre></div></td></tr></table></figure><p>eg3.</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.java.demo1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        haha();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">haha</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;<br>            System.out.println(a/b);<br>        &#125;<br>        <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            <span class="hljs-comment">//退出JVM</span><br>            System.exit(<span class="hljs-number">0</span>);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;锄禾日当午，汗滴禾下土&quot;</span>);<br><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>唯一一种在代码中使finally不执行的代码就是上述eg3.<br /> System.exit(0);<br />总结：finally问题总绕不开两点：<br />1.finally必然执行<br />2.return的时机以及备份的具体内容</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>github访问加速</title>
    <link href="/posts/ceb1ca5c.html"/>
    <url>/posts/ceb1ca5c.html</url>
    
    <content type="html"><![CDATA[<h2 id="通过修改HOSTS文件进行加速"><a href="#通过修改HOSTS文件进行加速" class="headerlink" title="通过修改HOSTS文件进行加速"></a>通过修改HOSTS文件进行加速</h2><p>参考如下介绍</p><hr><h3 id="为什么github下载速度这么龟？"><a href="#为什么github下载速度这么龟？" class="headerlink" title="为什么github下载速度这么龟？"></a>为什么github下载速度这么龟？</h3><p>GitHub 我们都知道是世界上最大的开源及私有软件项目的托管平台，全世界每天有海量优秀的开源软件在这里产生，而 GitHub 在国内很多时候获取到的下载链接是亚马逊的服务器。</p><span id="more"></span><p>国内访问github，经常抽疯或龟速。</p><h3 id="如何提高github的下载速度？"><a href="#如何提高github的下载速度？" class="headerlink" title="如何提高github的下载速度？"></a>如何提高github的下载速度？</h3><p>手动把cdn和ip地址绑定。</p><h3 id="第一步：访问：这里-获取cdn和ip域名"><a href="#第一步：访问：这里-获取cdn和ip域名" class="headerlink" title="第一步：访问：这里 获取cdn和ip域名"></a>第一步：访问：<a href="http://github.global.ssl.fastly.net.ipaddress.com/#ipinfo">这里</a> 获取cdn和ip域名</h3><h3 id="第二步：获取github的global-ssl-fastly地址"><a href="#第二步：获取github的global-ssl-fastly地址" class="headerlink" title="第二步：获取github的global.ssl.fastly地址"></a>第二步：获取github的global.ssl.fastly地址</h3><p>得到：192.30.255.112</p><h3 id="第三步：获取github-com地址"><a href="#第三步：获取github-com地址" class="headerlink" title="第三步：获取github.com地址"></a>第三步：获取github.com地址</h3><p>得到：185.31.16.184</p><h3 id="第四步：修改host文件映射上面查找到的IP"><a href="#第四步：修改host文件映射上面查找到的IP" class="headerlink" title="第四步：修改host文件映射上面查找到的IP"></a>第四步：修改host文件映射上面查找到的IP</h3><p>windows系统：</p><p>找到C:\Windows\System32\drivers\etc\hosts<br>在<mark>最后写入 </p><p>192.30.255.112  github.com git</p><p>185.31.16.184 github.global.ssl.fastly.net</p><h3 id="第五步：在cmd中输入：ping-github-com即可"><a href="#第五步：在cmd中输入：ping-github-com即可" class="headerlink" title="第五步：在cmd中输入：ping github.com即可"></a>第五步：在cmd中输入：ping github.com即可</h3>]]></content>
    
    
    <categories>
      
      <category>github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实用技能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>build the drawing bed on github</title>
    <link href="/posts/96102aeb.html"/>
    <url>/posts/96102aeb.html</url>
    
    <content type="html"><![CDATA[<p>问题描述：在写第一篇博客时，图片在md文件中能够正常显示，而在网页上浏览时显示上传失败。查了资料发现原因是md中的文件路径使用相对路径，page到网页上时路径失效，找不到本地存图片的文件，因此加载失败。想解决这个问题，需要将本地图片page到网上生成网链（md可辨别的）。</p><span id="more"></span><p>做法：</p><p>1.在github上新建仓库作为图床<br>2.在issue中点击new issues<br><img src="https://user-images.githubusercontent.com/73998546/122338823-cdbeff80-cf72-11eb-98a0-c7af3504da7c.png" alt="1 (1)"></p><p>3.将图片拖入输入框</p><p>4.在preview中可以预览图片样式</p><p>5.在write中生成的链接可以再md中直接应用<br><img src="https://user-images.githubusercontent.com/73998546/122338817-cbf53c00-cf72-11eb-8527-09a51858866b.png" alt="1 (2)"></p><p>完成！撒花✿✿ヽ(°▽°)ノ✿</p>]]></content>
    
    
    <categories>
      
      <category>github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实用技能</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
