<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关系三重提取的新框架</title>
    <link href="/posts/e938ff54.html"/>
    <url>/posts/e938ff54.html</url>
    
    <content type="html"><![CDATA[<h2 id="CASREL模型的分析"><a href="#CASREL模型的分析" class="headerlink" title="CASREL模型的分析"></a>CASREL模型的分析</h2><p>在做知识图谱的工作时，我们面临的首要问题是对一段语料进行实体识别(NER)和关系抽取(RE)。</p><p><del>啥？知识图谱是啥？</del></p><blockquote><p>A knowledge graph, also known as a semantic network, represents a network of real-world entities—i.e. objects, events, situations, or concepts—and illustrates the relationship between them. This information is usually stored in a graph database and visualized as a graph structure, prompting the term knowledge “graph.”</p></blockquote><p><img src="https://user-images.githubusercontent.com/73998546/182825426-f5f2a104-51eb-4ccd-b340-5a990a1c615a.png" alt="知识图谱"></p><p>简而言之，我们现实生活中的一切都可以用三元组（主语，关系，宾语）表示，抽象到图的数据结构中，圈圈代表主语和宾语，连接圈圈的箭头表示关系。</p><p>知识图谱的关键成分是关系事实，其中大部分由两个实体组成，由语义关系连接。 这些事实是以（主语，关系，宾语）或（s，r，o）的形式，称为关系三元组。</p><p>在之前的做法中，针对关系提取最早的做法是<strong>管道方法</strong>。它首先识别句子中的所有实体，然后对每个实体对进行关系分类。这种方法往往会受到错误传播问题的影响，因为早期阶段的错误无法在早期阶段得到纠正。</p><p>为了解决这个问题，后续大牛们提出了<strong>实体和关系的联合学习</strong>，其中有基于特征的模型以及神经网络模型。但是现有方法不能有效处理一个句子包含多个关系三元组的情况。<br>而且这些提取重叠三元组的工作仍有很多不足之处。</p><p>我们来看看当有多个三元组时，可能会出现的问题：</p><p>Normal：<font color=Green>华科</font>学生<font color=Green>wpy</font>邀请<font color=Green>腾讯</font>老板<font color=Green>马化腾</font>上模电课<br>关系三元组：（wpy，就读于，华科），（马化腾，CEO，腾讯）</p><p>EPO:<font color=Green>姜文</font>在他导演的<font color=Green>让子弹飞</font>中出演张麻子<br>关系三元组：（姜文，出演，让子弹飞），（姜文，导演，让子弹飞）</p><p>SEO：<font color=Green>我</font>出生在<font color=Green>河南</font>，<font color=Green>郑州</font><br>关系三元组：（我，出生地，河南），（我，出生地，郑州），（郑州，是…省会，河南）</p><blockquote><p>EPO:EntityPairOverlap<br>SEO:SingleEntityOverlap overlapping patterns.</p></blockquote><p>面对上面的三元组重叠问题，现有方法都不能很好的解决。</p><p>具体来说，它们都将关系视为分配给实体对的离散标签。这个公式使关系分类成为一个困难的机器学习问题。<strong>首先，类分布高度不平衡</strong>。在所有提取的实体对中，大多数都没有形成有效的关系，产生了太多的反面例子。<strong>其次，当同一实体参与多个有效关系（重叠三元组）时，分类器可能会混淆。</strong>如果没有足够的训练样本，分类器很难分辨出实体参与了哪个关系。因此，提取的三元组是通常不完整和不准确。</p><p>这就体现出来CASREL牛逼的地方了，别人不能解决的，他行啊。</p><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><p>该框架的核心是全新的观点，即我们可以将关系建模为将主体映射到对象的函数，而不是将关系视为实体对上的离散标签。这完全颠覆了以往的离散思想，而是把关系作为函数进行训练。更准确地说，我们<strong>不是学习关系分类器 f(s, o) → r</strong>，而是<strong>学习关系特定标记器 fr(s) → o，</strong>每个标记器都识别特定关系下给定实体s的可能对象；或不返回对象，表示有没有给定实体s和关系的三元组。</p><p>在这个框架下，三重提取是一个两步过程：</p><p><strong>1.我们识别一个句子中所有可能的实体s；</strong></p><p><strong>2.对于每个实体s，我们应用关系特定的标记器来同时识别所有可能的关系和相应的对象。</strong></p><p>CASREL框架将实现上述步骤。它由一个<strong>BERT 模块</strong>、一个<strong>subject标记模块</strong>和一个<strong>特定于关系的object标记模块</strong>组成。</p><h4 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h4><blockquote><p>到了头疼的公式推导环节，非战斗人员请撤离</p></blockquote><p>给定注释的句子 xj 从训练集 D 和一组可能重叠的xj 中的三元组 Tj = {(s, r, o)} ：<br><img src="https://user-images.githubusercontent.com/73998546/182838469-44b3758e-663c-4592-becf-15da5e316150.png" alt="公式推导"><br>第二步应用了概率的链式法则方程。第三步，我们应该承认：<strong>对于一个给定的主题 s，与 s 相关的任何关系（Tj |s 中的那些）会导致句子中出现对应的宾语，并且所有其他关系必然没有句子中的宾语，即“空”宾语。</strong></p><p>我们的目的是把公式（3）的每一块尽量提高，以保证最后结果最大。（即最大化训练集 D 的数据似然度）</p><h4 id="模型框架"><a href="#模型框架" class="headerlink" title="模型框架"></a>模型框架</h4><p>事实上，这种新颖的标记方案使我们能够一次提取多个三元组：我们首先运行subject标记器以查找句子中所有可能的subject，然后对于找到的每个subject，应用特定于关系的object标记器以查找所有相关的关系和对应的object。<br><img src="https://user-images.githubusercontent.com/73998546/182839709-7f967c70-5bc1-4fb4-9268-81e0a9a7ee8c.png" alt="模型框架"></p><blockquote><p>An overview of the proposed CASREL framework. In this example, there are three candidate subjects detected at the low level, while the presented 0/1 tags at high level are specific to the first subject Jackie R. Brown, i.e., a snapshot of the iteration state when k = 1 is shown as above. For the subsequent iterations (k = 2, 3), the results at high level will change, reflecting different triples detected. For instance, when k = 2, the high-level orange (green) blocks will change to 0 (1), respectively, reflecting the relational triple (Washington, Capital of,United States Of America) led by the second candidate subject Washington.</p></blockquote><h5 id="BERT-ENCODER"><a href="#BERT-ENCODER" class="headerlink" title="BERT ENCODER"></a>BERT ENCODER</h5><p><img src="https://user-images.githubusercontent.com/73998546/182840186-999b5114-8c15-48db-9018-2553e2ce7409.png" alt=" "><br>其中 S 是输入句子中子词索引的 one-hot 向量矩阵，Ws 是子词嵌入矩阵，Wp是位置嵌入矩阵，其中 p 表示位置输入序列中的索引，hα是隐藏状态<br>向量，即输入句子在第α层的上下文表示，N是Transformer块的数量。</p><p><code>输入：单个文本句子</code><br><code>输出：综合文本信息的单词向量矩阵</code></p><h5 id="Cascade-Decoder"><a href="#Cascade-Decoder" class="headerlink" title="Cascade Decoder"></a>Cascade Decoder</h5><p>首先，我们从输入句子中检测主体s。 然后对于每个候选主体s，我们检查所有可能的关系，看看是否有关系可以将句子中的对象与该主体s相关联。<br>这又分为两个模块</p><h6 id="1-Subject-Tagger"><a href="#1-Subject-Tagger" class="headerlink" title="1.Subject Tagger"></a>1.Subject Tagger</h6><p>通过直接解码 N 层 BERT 编码器产生的编码向量 hN 来识别输入句子中所有可能的主体。<br>它采用两个相同的二元分类器来检测对象的开始和结束位置，如果概率超过某个特定阈值，则标记为 1，否则标签 0<br><img src="https://user-images.githubusercontent.com/73998546/182840329-1412ccd7-bbf6-4a23-8200-8aa8c167d459.png" alt=" "><br>W是训练权重，xi=hn[i],b是偏差，derta是激活函数<br>此外论文中还提到了实体跨度的监测，在此不再赘述</p><h6 id="2-Relation-specific-Object-Taggers"><a href="#2-Relation-specific-Object-Taggers" class="headerlink" title="2.Relation-specific Object Taggers"></a>2.Relation-specific Object Taggers</h6><p>所有对象标记器object taggers将同时为每个检测到的对象识别相应的对象。<br><img src="https://user-images.githubusercontent.com/73998546/182840360-96fc9871-1cb1-479a-844a-66a8e751e566.png" alt=" "></p><p>参考论文<a href="https://arxiv.org/pdf/1909.03227.pdf">A Novel Cascade Binary Tagging Framework for<br>Relational Triple Extraction</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BERT-BiLSTM-CRF</title>
    <link href="/posts/7a6a6b5a.html"/>
    <url>/posts/7a6a6b5a.html</url>
    
    <content type="html"><![CDATA[<h1 id="BERT-CRF模型分析"><a href="#BERT-CRF模型分析" class="headerlink" title="BERT-CRF模型分析"></a>BERT-CRF模型分析</h1><p>上学期搞大创的时候接触了NER相关的模型和知识，暑假终于有时间整理一下乐</p><p>首先先了解一下BERT-BiLSTM-CRF的应用场景，这种方法主要用于命名实体识别。简单来讲，就是在一段语料中抽出其中的名词进行划分。<br>先上例子，以提取公司企业和人物实体为例：</p><p><code>输入： &#123;&quot;text&quot;: &quot;作为蔚来汽车的 a 轮投资人，刘二海已经是第二次见证李斌在纽交所敲钟，第一次是李斌创办的易车在纽交所上市。&#125;</code><br><code>输出： &#123;&quot;label&quot;: &#123;&quot;person&quot;: &#123;&quot;刘二海&quot;: [13, 15]&#125;, &quot;org&quot;: &#123;&quot;蔚来汽车&quot;: [2，5]&#125;&#125;&#125;</code></p><p>输入一段文本 text，输出的标签为句子中的organization 和 person 实体</p><p>需要明确的是，BERT-BiLSTM-CRF是有监督分类问题，训练语料一定要给出训练文本对应的标注。</p><p>那么我们如何从一段语料中“聪明地”获取实体并打上标签呢？<br>上模型！</p><h3 id="模型框架"><a href="#模型框架" class="headerlink" title="模型框架"></a>模型框架</h3><p><img src="https://user-images.githubusercontent.com/73998546/182521959-df17f189-c427-4a99-a38b-1b52ce78de4e.png" alt="模型框架"></p><p>BERT-CRF 模型由 3 个模块组成。首先使用 BERT 模型获取字向量，提<br>取文本重要特征；之后由 BiLSTM 层对 BERT 的输出序列处理，通过双向 LSTM 计算输入隐藏信息；<br>在CRF层，结合 CRF 中的状态转移矩阵，根<br>据相邻之间标签得到一个全局最优序列。</p><h4 id="BERT层"><a href="#BERT层" class="headerlink" title="BERT层"></a>BERT层</h4><p>模型第一层是利用预训练的 BERT 语言模型初始化获取输入文本信息中的字向量记为<br>序列 E=(e1,e2,e3,⋯ ,en) , 所获取的字向量能够利用词与词之间的相互关<br>系</p><p>BERT 是一种自然语言处理预训练语言表征模型. BERT 能够计算词语之间的相互关系, 并利用所计算的关系调节权重提取文本中的重要特征, 利用自注意力机制的结构来进行预<br>训练, 基于所有层融合左右两侧语境来预训练深度双向表征, 比起以往的预训练模型, 它捕<br>捉到的是真正意义上的上下文信息, 并能够学习到连续文本片段之间的关系.</p><h4 id="BiLSTM"><a href="#BiLSTM" class="headerlink" title="BiLSTM"></a>BiLSTM</h4><p>想要知道BiLSTM是什么，需要先了解LSTM是干嘛的</p><p>LSTM 长短期记忆网络<br>是一种特殊的循环神经网络。RNN 网络主要包括输入层、隐藏层和输出层三部分组成，<br>隐藏层连接前后两层，这种特殊的结构，能让 RNN 网络具有一定的“记忆能力，能够有效<br>处理命名实体识别任务。</p><h5 id="LSTM框架"><a href="#LSTM框架" class="headerlink" title="LSTM框架"></a>LSTM框架</h5><p><img src="https://user-images.githubusercontent.com/73998546/182525122-b3fe78f8-650e-419b-9b72-7ba250c895db.png" alt="LSTM框架"><br>LSTM模型可以理解为：现在有一串细胞代表着不同时刻的状态（C0，C1…Ct），他们是串联关系。在t时刻，你有三个输入，分别为上一细胞状态Ct-1、隐藏层ht-1和输入词Xt。在经过细胞Ct后，你将得到本细胞的隐藏信息ht和此时新的细胞状态Ct。<br>在每个细胞中具体有遗忘门，记忆门和输出门，让我们看看这些可爱的小细胞是如何工作的吧</p><p><strong>计算过程</strong><br>计算过程的思路就是，将遗忘信息和新的信息整合起来，得到有用的信息传递给下一细胞，同时丢弃无用信息。并在每一时刻输出隐层状态ht，ht相当于一个中间参数，参与到下一层的信息计算中。</p><ul><li><p>计算<strong>遗忘门</strong><br><code>输入：前一时刻隐藏状态ht-1,输入词Xt</code><br><code>输出：遗忘门的值ft</code><br><img src="https://user-images.githubusercontent.com/73998546/182526393-185580bb-f2f9-45bf-97bd-59b6785bf134.png" alt="遗忘门"></p></li><li><p>计算<strong>记忆门</strong><br><code>输入：前一时刻隐藏状态ht-1,输入词Xt</code><br><code>输出：记忆门的值it，临时细胞状态Ct</code><br><img src="https://user-images.githubusercontent.com/73998546/182526419-d7ee10bb-90cb-437a-91c1-30a965ddd351.png" alt="记忆门"></p></li><li><p>更新<strong>细胞状态</strong><br><code>输入：记忆门的值it，遗忘门的值ft，上一细胞状态Ct-1，临时细胞状态Ct</code><br><code>输出：当前细胞状态Ct</code><br><img src="https://user-images.githubusercontent.com/73998546/182526444-b82c367d-ef01-4241-a43f-a6d82012efef.png" alt="细胞状态更新"></p></li><li><p>计算<strong>隐藏层</strong><br><code>输入：前一时刻隐藏状态ht-1,输入词Xt ，当前细胞状态Ct</code><br><code>输出：隐层状态ht</code><br><img src="https://user-images.githubusercontent.com/73998546/182526465-c75c0560-5471-4e96-8188-0d826f189c57.png" alt="最后输出"></p></li></ul><p>一顿操作下来，我们得到了和原始句子一样长的隐层状态序列[h0,h1…hn-1]</p><h5 id="BiLSTM框架"><a href="#BiLSTM框架" class="headerlink" title="BiLSTM框架"></a>BiLSTM框架</h5><p>知道了LSTM的计算流程，他是从一个方向得到状态序列。进一步想，我们如果从两个方向（从左到右，从右到左）进行LSTM的运算，并将两个结果合并，是否能得到更全面的语义信息呢</p><p>SMART GUY!这就是BiLSTM的思路。</p><p><img src="https://user-images.githubusercontent.com/73998546/182528230-0d562287-b91b-42eb-928b-660ed09b89f2.png" alt="BiLSTM框架"><br>我们对一句话进行两个方向的LSTM计算，最后将两者捏在一起。这样每个词和前后的词都存在关联性，在ner中能表现出更好的性能。</p><h4 id="CRF层"><a href="#CRF层" class="headerlink" title="CRF层"></a>CRF层</h4><p>CRF 用来分割和标记序列数据, 根据输入的观察序列来预测对应的状态序列, 同时考<br>虑输入的当前状态特征和各个标签类别转移特征, 被广泛应用于 NER 的问题中.</p><p><img src="https://user-images.githubusercontent.com/73998546/182520083-e46c0fd1-f27d-409a-8a49-b4a2d5ffb3de.png" alt="CRF层"><br>如上图可知，BiLSTM层输出全文的向量表示后，得到这个词对应每个标签的权重。<br>CRF层会选取权重较高的标签，注意不是最高。他还会从训练数据中学习约束，确保选取标签的合理性。<br>CRF 层可以为最终预测的标签添加一些约束（如句子中第一个单词的标签应该以“B-”或“O”开头，而不是“I-”、“B-label1 I-label2 I-label3 I-…”，<br>在这个模式中，label1、label2、label3…应该是同一个命名实体标签），以减少无效预测标签序列的数量。这些约束可以在训练过程中由 CRF 层自动从训练数据集中学习。<br><em>约束可能是：<br>句子中第一个单词的标签应该以“B-”或“O”开头，而不是“I-” “B-label1 I-label2 I-label3 I-…”，在这个模式中，label1、label2、label3…应该是同一个命名实体标签。例如，“B-Person I-Person”有效，但“B-Person I-Organization”无效。<br>“O I-label”无效。一个命名实体的第一个标签应该以“B-”而不是“I-”开头，换句话说，有效模式应该是“O B-label</em></p><p>再回头梳理一遍<strong>模型IO</strong><br><code>原始输入：语句文本</code><br><strong>BERT 层</strong>：<br><code>输入：</code><br>①由原始文本利用 word2Vector 等算法得到的原始字向量<br>②文本向量：该向量的取值在模型训练过程中自动学习，用于刻画文本的全局语义信息，<br>并与单字/词的语义信息相融合<br>③位置向量：刻画不同位置的字，对不同位置的字附加一个不同的向量加以区分<br><code>输出：文本中各个字融合了全文语义信息后的向量表示</code><br><strong>BiLSTM层</strong>：<br><code>输入：BERT 模型的输出序列</code><br><code>输出：每个字对应的标签权重</code><br><strong>CRF 层</strong>：<br><code>输入：每个字对应的标签权重</code><br><code>输出：预测的标签序列</code><br><img src="https://user-images.githubusercontent.com/73998546/182521959-df17f189-c427-4a99-a38b-1b52ce78de4e.png" alt="image"><br>复习一下前面的图~<br>over</p>]]></content>
    
    
    <categories>
      
      <category>NER</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NER</tag>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SAT问题及DPLL简述</title>
    <link href="/posts/935b2a8c.html"/>
    <url>/posts/935b2a8c.html</url>
    
    <content type="html"><![CDATA[<h2 id="聊聊SAT问题是什么"><a href="#聊聊SAT问题是什么" class="headerlink" title="聊聊SAT问题是什么"></a>聊聊SAT问题是什么</h2><blockquote><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3></blockquote><p>SAT问题又称命题逻辑公式的可满足性问题（satisfiability problem），是判断对合取范式形式给出的命题逻辑公式是否存在一个真值指派使得该逻辑公式为真。SAT问题是计算机科学与人工智能基本问题，是一个典型的NP完全问题。看似简单，却可广泛应用于许多实际问题如人工智能、电子设计自动化、自动化推理、硬件设计、安全协议验证等，具有重要理论意义与应用价值。对于SAT问题的研究从没有停止过，在1997年和2003年，H.Kautz与B.Selman两次列举出SAT搜索面临的挑战性问题，并于2011年和2007年，两度对当时的SAT问题研究现状进行了全面的综述。黄文奇提出的Solar算法在北京第三届SAT问题快速算法比赛中获得第一名。对SAT问题的求解主要有完备算法和不完备算法两大类。不完备算法主要是局部搜索算法，这种算法不能保证一定找到解，但是求解速度快，对于某些SAT问题的求解，局部搜索算法要比很多完备算法更有效。完备算法出现的时间更早，优点是可以正确判断SAT问题的可满足性，在算例无解的情况下可以给出完备的证明。对于求解SAT问题的优化算法主要有启发式算法、冲突子句学习算法、双文字监视法等。</p><blockquote><h3 id="研究意义"><a href="#研究意义" class="headerlink" title="研究意义"></a>研究意义</h3></blockquote><p>SAT问题是第一个被证明的NP完全问题，而NP完全问题由于其极大的理论价值和困难程度，破解后将会在许多领域得到广泛应用，从而在计算复杂性理论中具有非常重要的地位。由于所有的NP完全问题都能够在多项式时间内进行转换，那么如果SAT问题能够得到高效解决，所有的NP完全问题都能够在多项式时间内得到解决。对SAT问题的求解，可用于解决计算机和人工智能领域内的CSP问题（约束满足问题）、语义信息的处理和逻辑编程等问题，也可用于解决计算机辅助设计领域中的任务规划与设计、三维物体识别等问题。SAT问题的应用领域非常广泛，还能用于解决数学研究和应用领域中的旅行商问题和逻辑算数问题。许多实际问题，例如数据库检索、积木世界规划、超大规模集成电路设计、人工智能等都可以转换成SAT问题进而进行求解。可见对SAT问题求解的研究，具有重大意义。</p><blockquote><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3></blockquote><p>SAT问题即命题逻辑公式的可满足性问题（satisfiability problem），是计算机科学与人工智能基本问题，是一个典型的NP完全问题，可广泛应用于许多实际问题如硬件设计、安全协议验证等，具有重要理论意义与应用价值。SAT问题也是程序设计与竞赛的经典问题。<br>对于任一布尔变元x，x与其非“¬x”称为文字(literal)。对于多个布尔变元，若干个文字的或运算l1∨l2∨…∨lk称为子句(clause)。只含一个文字的子句称为单子句。不含任何文字的子句称为空子句，常用符号□表示。子句所含文字越多，越易满足，空子句不可满足。<br>SAT问题一般可描述为：给定布尔变元集合{x1, x2, …, xn}以及相应的子句集合{c1, c2, …, cm}，对于合取范式（CNF范式）：F = c1∧c2∧…∧cm，判定是否存在对每个布尔变元的一组真值赋值使F为真，当为真时（问题是可满足的，SAT），输出对应的变元赋值（一组解）结果。<br>一个CNF公式也可以表示成子句集合的形式：S={c1,c2,…,cm}.<br>例如，由三个布尔变元a,b,c所形成的一个CNF公式（¬a∨b）∧（¬b∨c）,可用集合表示为{¬a∨b,¬b∨c}，该公式是满足的，a=0, b=0,c=1是其一组解。 </p><blockquote><h3 id="cnf文件解读"><a href="#cnf文件解读" class="headerlink" title="cnf文件解读"></a>cnf文件解读</h3></blockquote><p>一个CNF SAT公式或算例的具体信息通常存储在一个.cnf文件中，下图是算例problem1.cnf文件前若干行的截图。</p><p><img src="https://user-images.githubusercontent.com/73998546/133534700-41b7c5f8-9448-4cea-a079-763b69aa4988.png" alt="1(1)"></p><p>在每个CNF文件的开始，由‘c’开头的是若干注释说明行；‘p’开头的行说明公式的总体信息，包括：范式为CNF；公式有200个布尔变元，由1到200的整数表示；320个子句。之后每行对应一个子句，0为结束标记。46表示第46号变元，且为正文字；-46则是对应的负文字，文字之间以空格分隔。</p><p>DPLL算法是经典的SAT完备型求解算法，对给定的一个SAT问题实例，理论上可判定其是否满足，满足时可给出对应的一组解。</p><h2 id="DPLL算法是什么呢"><a href="#DPLL算法是什么呢" class="headerlink" title="DPLL算法是什么呢"></a>DPLL算法是什么呢</h2><p>DPLL算法是基于树/二叉树的回溯搜索算法，主要使用两种基本处理策略：</p><p>单子句规则。如果子句集S中有一个单子句L,那么L一定取真值，于是可以从S中删除所有包含L的子句（包括单子句本身），得到子句集S1，如果它是空集，则S可满足。否则对S1中的每个子句，如果它包含文字¬L,则从该子句中去掉这个文字，这样可得到子句集合S2。S可满足当且仅当S2可满足。单子句传播策略就是反复利用单子句规则化简S的过程。</p><p>分裂策略。按某种策略选取一个文字L.如果L取真值，则根据单子句传播策略，可将S化成S2；若L取假值（即¬L成立）时，S可化成S1.</p><p>交错使用上述两种策略可不断地对公式化简，并最终达到终止状态，其执行过程可表示为一棵二叉搜索树,如下图所示。</p><p><img src="https://user-images.githubusercontent.com/73998546/133535483-b924184a-7b00-4034-9e67-5489e8e7cec1.png" alt="1(2)"></p><p>基于单子句传播与分裂策略的DPLL算法可以描述为一个如后所示的递归过程DPLL( S ), DPLL算法也可用非递归实现。</p><div class="hljs code-wrapper"><pre><code>DPLL( S) :/* S为公式对应的子句集。若其满足，返回TURE；否则返回FALSE. */&#123;while(S中存在单子句) &#123;//单子句传播在S中选一个单子句L；依据单子句规则，利用L化简S；if S = Φ return(TRUE);else if (S中有空子句 ) return（FALSE）；&#125;//while基于某种策略选取变元v；         //策略对DPLL性能影响很大if DPLL（S ∪v ）return(TURE);  //在第一分支中搜索return DPLL(S ∪¬v);//回溯到对v执行分支策略的初态进入另一分支&#125;</code></pre></div><p>对于公式{¬1∨2, ¬2，¬3∨4, 3∨¬5,3∨4, 3∨5，¬2∨¬5∨6} ,大家可以利用DPLL算法进行手动推理其搜索处理及回溯过程，获得求解结果。</p>]]></content>
    
    
    <categories>
      
      <category>由SAT问题引发的小思考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法重写</title>
    <link href="/posts/5504c575.html"/>
    <url>/posts/5504c575.html</url>
    
    <content type="html"><![CDATA[<p>发生在类的继承中，这个方法子和父名称一样，子生效<br><a name="44XsM"></a></p><h3 id="重写（override）规则："><a href="#重写（override）规则：" class="headerlink" title="重写（override）规则："></a>重写（override）规则：</h3><ol><li>参数列表必须完全与被重写方法相同</li><li>返回类型必须完全与被重写的返回类型相同</li><li>访问权限不能比父类中被重写的访问权限更低。例如：如果父类的一个方法被声明为public，name子类中重写该方法就不能声明为protected</li><li>父类的成员方法只能被他的子类重写</li><li>声明为static和private的方法不能被重写，但是能够被再次声明<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> stsic <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Student s = <span class="hljs-keyword">new</span> Student();<br>        s.say();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span>&#123;<br>        System.<span class="hljs-function">out <span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;锄禾日当午，汗滴禾下土&quot;</span>)</span></span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">class Student extends Person</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;床前明月光&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><p><a name="Gotao"></a></p><h4 id="注意：面试题：Java中重写（override）和重载（overland）的区别"><a href="#注意：面试题：Java中重写（override）和重载（overland）的区别" class="headerlink" title="注意：面试题：Java中重写（override）和重载（overland）的区别"></a>注意：面试题：Java中重写（override）和重载（overland）的区别</h4><ol><li>重写是发生在子父类中的操作</li><li>重载是一个类里面参数列表的长度、参数类型和参数类型顺序不同（分为构造方法重载和方法重载）</li></ol><p>a. 发生的位置<br />重载：一个类中<br />重写：子父类中<br />b. 参数列表限制<br />重载：必须不同<br />重写：必须相同<br />c. 返回值类型：<br />重载：与返回值类型无关<br />重写：返回值类型必须一致<br />d. 访问权限：<br />重载：与访问权限无关<br />重写： 子的方法权限 必须不能小于 父的方法权限<br />e.异常（bug）处理：<br />重载：与异常无关<br />重写：可以减少或删除（异常范围可以更小更精准，但是不能抛出新的异常）<br /><br><br /></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>final关键字</title>
    <link href="/posts/af55167d.html"/>
    <url>/posts/af55167d.html</url>
    
    <content type="html"><![CDATA[<p>final用于修饰属性、变量<br />变量成为了常量，无法对其再次进行赋值<br />final修饰的局部变量，只能赋值一次（可以先声明后赋值）<br />final修饰的是成员属性，必须在声明时赋值<br />全局常量（public static final）<br /><br><br />常量的命名规范：<br />由一个或多个单词组成，单词与单词之间必须使用下划线隔开，单词中所有字母大写<br />例如：SQL_INSET<br /><br><br /><br><br />final用于修饰类<br />final修饰的类，不可以被继承<br />final用于修饰方法<br />final修饰的方法，不能被子类重写<br />全局常量（public static final）<br /></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>异常处理</title>
    <link href="/posts/28877bf.html"/>
    <url>/posts/28877bf.html</url>
    
    <content type="html"><![CDATA[<p>情况描述：当程序出现bug时，Java虚拟机发现异常，虚拟机就会new出来一个新的对象，用类似返回的方式返回错误类型和异常原因，同时中断程序。</p><h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><p>对异常进行处理，捕获异常，避免异常返回使程序中断</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//有可能发生异常的代码</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">1</span> 对象名<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-comment">//异常的操作</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">1</span> 对象名<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-comment">//异常的操作</span><br>&#125;...<br><span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-comment">//异常的统一出口</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>catch语句相当于if语句<br />如果满足异常类型，则实现代码块里面的操作<br /><br><br />易错警告<br />eg1.</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.java.demo1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Person p =haha();<br>        System.out.println(p.age);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Person <span class="hljs-title">haha</span><span class="hljs-params">()</span></span>&#123;<br>        Person p = <span class="hljs-keyword">new</span> Person();<br>       <span class="hljs-keyword">try</span>&#123;<br>           p.age = <span class="hljs-number">18</span>;<br>           <span class="hljs-keyword">return</span> p;<br>       &#125;<span class="hljs-keyword">finally</span>&#123;<br>           p.age = <span class="hljs-number">28</span>;<br>       &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>        <span class="hljs-keyword">int</span> age;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//始终是一个对象，最后执行finally，p.age年龄被更改</span><br></code></pre></div></td></tr></table></figure><p>eg2.</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.java.demo1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> a =haha();<br>        System.out.println(a);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">haha</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;<span class="hljs-keyword">finally</span>&#123;<br>            a = <span class="hljs-number">20</span>;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//return a;中的a是被备份的那个</span><br><span class="hljs-comment">//实际上又开辟了一块内存空间，这是返回的a和finally中的赋值的a无关</span><br></code></pre></div></td></tr></table></figure><p>eg3.</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.java.demo1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        haha();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">haha</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;<br>            System.out.println(a/b);<br>        &#125;<br>        <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            <span class="hljs-comment">//退出JVM</span><br>            System.exit(<span class="hljs-number">0</span>);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;锄禾日当午，汗滴禾下土&quot;</span>);<br><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>唯一一种在代码中使finally不执行的代码就是上述eg3.<br /> System.exit(0);<br />总结：finally问题总绕不开两点：<br />1.finally必然执行<br />2.return的时机以及备份的具体内容</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>github访问加速</title>
    <link href="/posts/ceb1ca5c.html"/>
    <url>/posts/ceb1ca5c.html</url>
    
    <content type="html"><![CDATA[<h2 id="通过修改HOSTS文件进行加速"><a href="#通过修改HOSTS文件进行加速" class="headerlink" title="通过修改HOSTS文件进行加速"></a>通过修改HOSTS文件进行加速</h2><p>参考如下介绍</p><hr><h3 id="为什么github下载速度这么龟？"><a href="#为什么github下载速度这么龟？" class="headerlink" title="为什么github下载速度这么龟？"></a>为什么github下载速度这么龟？</h3><p>GitHub 我们都知道是世界上最大的开源及私有软件项目的托管平台，全世界每天有海量优秀的开源软件在这里产生，而 GitHub 在国内很多时候获取到的下载链接是亚马逊的服务器。</p><span id="more"></span><p>国内访问github，经常抽疯或龟速。</p><h3 id="如何提高github的下载速度？"><a href="#如何提高github的下载速度？" class="headerlink" title="如何提高github的下载速度？"></a>如何提高github的下载速度？</h3><p>手动把cdn和ip地址绑定。</p><h3 id="第一步：访问：这里-获取cdn和ip域名"><a href="#第一步：访问：这里-获取cdn和ip域名" class="headerlink" title="第一步：访问：这里 获取cdn和ip域名"></a>第一步：访问：<a href="http://github.global.ssl.fastly.net.ipaddress.com/#ipinfo">这里</a> 获取cdn和ip域名</h3><h3 id="第二步：获取github的global-ssl-fastly地址"><a href="#第二步：获取github的global-ssl-fastly地址" class="headerlink" title="第二步：获取github的global.ssl.fastly地址"></a>第二步：获取github的global.ssl.fastly地址</h3><p>得到：192.30.255.112</p><h3 id="第三步：获取github-com地址"><a href="#第三步：获取github-com地址" class="headerlink" title="第三步：获取github.com地址"></a>第三步：获取github.com地址</h3><p>得到：185.31.16.184</p><h3 id="第四步：修改host文件映射上面查找到的IP"><a href="#第四步：修改host文件映射上面查找到的IP" class="headerlink" title="第四步：修改host文件映射上面查找到的IP"></a>第四步：修改host文件映射上面查找到的IP</h3><p>windows系统：</p><p>找到C:\Windows\System32\drivers\etc\hosts<br>在<mark>最后写入 </p><p>192.30.255.112  github.com git</p><p>185.31.16.184 github.global.ssl.fastly.net</p><h3 id="第五步：在cmd中输入：ping-github-com即可"><a href="#第五步：在cmd中输入：ping-github-com即可" class="headerlink" title="第五步：在cmd中输入：ping github.com即可"></a>第五步：在cmd中输入：ping github.com即可</h3>]]></content>
    
    
    <categories>
      
      <category>github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实用技能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>build the drawing bed on github</title>
    <link href="/posts/96102aeb.html"/>
    <url>/posts/96102aeb.html</url>
    
    <content type="html"><![CDATA[<p>问题描述：在写第一篇博客时，图片在md文件中能够正常显示，而在网页上浏览时显示上传失败。查了资料发现原因是md中的文件路径使用相对路径，page到网页上时路径失效，找不到本地存图片的文件，因此加载失败。想解决这个问题，需要将本地图片page到网上生成网链（md可辨别的）。</p><span id="more"></span><p>做法：</p><p>1.在github上新建仓库作为图床<br>2.在issue中点击new issues<br><img src="https://user-images.githubusercontent.com/73998546/122338823-cdbeff80-cf72-11eb-98a0-c7af3504da7c.png" alt="1 (1)"></p><p>3.将图片拖入输入框</p><p>4.在preview中可以预览图片样式</p><p>5.在write中生成的链接可以再md中直接应用<br><img src="https://user-images.githubusercontent.com/73998546/122338817-cbf53c00-cf72-11eb-8527-09a51858866b.png" alt="1 (2)"></p><p>完成！撒花✿✿ヽ(°▽°)ノ✿</p>]]></content>
    
    
    <categories>
      
      <category>github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实用技能</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
