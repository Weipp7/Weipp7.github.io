<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ConfZNS分析</title>
    <link href="/posts/0.html"/>
    <url>/posts/0.html</url>
    
    <content type="html"><![CDATA[<p>最近的学校项目涉及ZNS（Zone NameSpace）SSD，需要我们了解ZNS的实现机制以及confZNS的原理，其中涉及的知识之庞杂，代码量之多，非我等小可所能完全吸收。在这里浅浅分析一下。</p><h2 id="SSD设备和ZNS协议-background"><a href="#SSD设备和ZNS协议-background" class="headerlink" title="SSD设备和ZNS协议 background"></a>SSD设备和ZNS协议 background</h2><p>当谈论SSD设备时，它是一种固态存储设备，全称为“Solid State Drive”，它不像传统的机械硬盘使用旋转的磁盘和机械臂来读写数据，而是使用闪存芯片来存储数据。SSD具有许多优点，例如更快的读写速度、更低的能耗、更小的体积和更高的抗震性能。它们在现代计算机和数据中心中广泛应用，能够显著提升系统性能和响应速度。</p><p>至于ZNS协议，它是“Zoned Namespace”（分区命名空间）的缩写。ZNS是一种NVMe（Non-Volatile Memory Express）协议的扩展，它允许SSD将存储空间划分为多个固定大小的分区或“Zone”。每个Zone内部的数据可以进行连续的顺序写入，但不能进行随机写入。ZNS协议的主要目的是优化SSD设备的写入性能，特别是在大规模数据写入场景下。</p><p>那么问题来了，NVMe协议是什么？他们和传统的SATA和SAS协议的异同点是什么？来一起看下</p><h3 id="传统协议和ZNS协议"><a href="#传统协议和ZNS协议" class="headerlink" title="传统协议和ZNS协议"></a>传统协议和ZNS协议</h3><p><strong>SATA协议（Serial ATA）</strong>：<br>SATA协议是一种用于连接计算机主板和存储设备（如硬盘和固态硬盘）之间的接口协议。它是一种串行传输的接口，用于替代传统的并行ATA（IDE）接口。SATA接口通常用于连接传统硬盘和低端固态硬盘，提供中等的数据传输速率和较低的延迟。</p><p><strong>SAS协议（Serial Attached SCSI）</strong>：<br>SAS协议是一种用于连接存储设备和服务器之间的接口协议。它是一种串行传输的接口，基于SCSI标准，并支持高可靠性和高性能的数据传输。SAS接口通常用于连接高性能的企业级硬盘和磁带库等设备，提供更高的数据传输速率和更低的延迟。</p><p><strong>NVMe协议（Non-Volatile Memory Express）</strong>：<br>NVMe协议是一种用于连接固态存储设备（如SSD）和计算机系统之间的接口协议。它是一种高性能、低延迟的接口，专门为固态存储设备而设计。NVMe接口采用PCI Express总线，并通过多队列和多核心技术来支持并发操作，提供更快的数据传输速率和更低的延迟。</p><p><strong>ZNS协议（Zoned Namespace）</strong>：<br>ZNS协议是在NVMe协议基础上扩展而来的，用于管理分区的固态存储设备。ZNS将物理存储空间划分为多个逻辑分区（命名空间），每个分区内的写入必须按照顺序进行，类似于磁带的顺序写。ZNS可以提高设备的写入效率，同时减少写入时的随机寻址，适用于写入密集型的工作负载。</p><p>有些晕了…来一个表格似乎更加直观</p><table><thead><tr><th></th><th>SATA</th><th>NVMe</th><th>ZNS</th></tr></thead><tbody><tr><td>传输接口</td><td>串行传输的接口协议</td><td>基于PCI Express的高速串行接口</td><td>在NVMe协议基础上进行扩展的，用于管理分区的固态存储设备</td></tr><tr><td>性能特点</td><td>适用于一般桌面应用和企业级应用，提供中等性能和可靠性</td><td>性能方面有显著优势，提供更高的数据传输速率和更低的延迟，适用于高性能计算和数据中心应用</td><td>同NVMe</td></tr><tr><td>适用场景</td><td>连接传统硬盘和低端固态硬盘，适用于一般桌面和中小型企业服务器</td><td>用于高性能计算和数据中心应用，连接高性能固态硬盘（SSD）</td><td>适用于写入密集型的工作负载，可以提高设备的写入效率。</td></tr><tr><td>命名空间</td><td>无</td><td>支持命名空间的概念，允许将物理存储空间划分为多个逻辑单元，每个命名空间都可以被视为一个独立的存储设备，提供更灵活的数据管理方式。</td><td>同NVMe</td></tr><tr><td>设备类型</td><td>用于连接传统硬盘和企业级硬盘</td><td>连接固态硬盘（SSD）</td><td>连接固态硬盘（SSD）</td></tr><tr><td>性价比</td><td>相对较便宜，适用于预算有限的用户</td><td>性能更高，但价格也相对较高</td><td>同NVMe</td></tr></tbody></table><h3 id="ZNS协议解决的问题"><a href="#ZNS协议解决的问题" class="headerlink" title="ZNS协议解决的问题"></a>ZNS协议解决的问题</h3><p>ZNS-SSD的出现主要是为了解决传统的Block Interface SSD（例如使用NVMe协议的Flash SSD）在某些场景下面临的一些问题。以下是一些传统Block Interface SSD存在的问题：</p><ol><li>写入效率不高：传统SSD使用固定大小的块（通常为4KB或8KB），在写入时必须按照块为单位进行写入。对于小于一个块大小的数据写入，需要进行块对齐和补齐操作，导致写入效率不高。</li><li>垃圾回收和写放大：由于传统SSD的块大小固定，写入和擦除操作都是以块为单位进行的。当进行部分块的更新或删除时，需要先将整个块读取到内存中，进行修改后再整块写回，导致写放大问题和垃圾回收的开销。</li><li>寿命问题：由于传统SSD的擦除操作是以块为单位进行的，频繁的小块写入和擦除会导致SSD的寿命缩短。</li><li>数据分布不均衡：传统SSD中的块分配和擦除管理策略可能导致数据在不同块之间的分布不均衡，称为写入热点问题。</li><li>随机写性能：传统SSD在随机写入操作时可能面临性能下降，尤其是在块擦除和写入操作频繁时。</li></ol><p>ZNS-SSD通过引入Zoned Namespace（分区命名空间）来解决这些问题。在ZNS-SSD中，存储空间被划分为多个Zone（区域），每个Zone内的写入操作必须按照顺序进行，从而避免了块对齐和补齐的问题。ZNS-SSD支持顺序写入，可以提高写入效率和减少写放大问题。此外，ZNS-SSD还通过合理规划Zone来均衡数据分布，提高随机写性能，并通过管理Zone的方式延长SSD的寿命。因此，ZNS-SSD可以更好地适应写入密集型的工作负载和大规模数据写入场景。</p><p>在随机写性能方面，我多查了一些资料。先说结论：在某些特定工作负载下，ZNS-SSD在随机写入性能方面可能会相对优于传统的Block Interface SSD，特别是当数据写入是以较大的连续块为单位进行时。然而，这并不意味着ZNS-SSD在所有随机写入场景下都优于传统SSD。对于小块随机写入，传统SSD可能仍然具有优势。</p><ol><li>随机写支持方式：<ul><li>Block Interface SSD：传统的Block Interface SSD使用逻辑块（Logical Block）作为最小的可寻址单元。随机写操作可以直接在逻辑块级别进行，即可以在任意逻辑块上写入数据，无需关心实际的物理布局。</li><li>ZNS SSD：ZNS SSD采用了Zoned Namespace技术，将存储空间划分为一系列称为Zone的连续区域。每个Zone都有固定的容量，且必须按照顺序写入，不支持随机写入。在随机写入数据时，需要将数据写入到当前活动的Zone中，并且在Zone被填满之后，才能切换到下一个Zone进行写入。</li></ul></li><li>随机写性能差异：<ul><li>Block Interface SSD：由于Block Interface SSD支持随机写入，因此在随机写入小块数据时表现较好。随机写性能通常以IOPS（每秒I/O操作数）和延迟（响应时间）为主要指标。</li><li>ZNS SSD：ZNS SSD在设计上更侧重于优化顺序写性能，因为随机写入会导致Zone切换和写入位置的变化，从而影响性能。在随机写入数据时，ZNS SSD的性能相对较差，尤其是在涉及多个Zone的情况下。因此，对于随机写入工作负载，传统的Block Interface SSD可能表现更好。</li></ul></li></ol><p>因此，ZNS SSD的设计是针对特定的工作负载场景，例如冷存储、日志记录等，对于需要大量随机写入的工作负载，传统的Block Interface SSD可能更适合。</p><h3 id="ZNS-architect"><a href="#ZNS-architect" class="headerlink" title="ZNS architect"></a>ZNS architect</h3><h4 id="1-核心架构"><a href="#1-核心架构" class="headerlink" title="1. 核心架构"></a>1. 核心架构</h4><p>Zoned Namespace (ZNS) 是一种新型的SSD架构，它将存储空间划分为一系列称为Zone的连续区域，每个Zone都有固定的容量。ZNS架构主要由以下几个组件构成：</p><ol><li><p>Zone：Zone是ZNS架构的基本单元，它是一段连续的存储空间，具有固定的容量。在ZNS中，数据必须按照顺序写入Zone，而不能随机写入。Zone通常比传统SSD中的块（Block）更大，这有助于减少读-修改-写（Read-Modify-Write）的操作，提高写入性能。</p></li><li><p>Zone Management：Zone Management负责管理Zone的状态和使用情况。每个Zone都有一个状态，包括空闲、打开（Open）、关闭（Closed）、读写保护（Read-Only）等状态。Zone Management可以实现自动打开和关闭Zone，以便在写入过程中实现数据的顺序写入。此外，Zone Management还负责处理Zone的空间回收和回收策略，以最大程度地减少擦除操作。</p></li><li><p>Zone Report：Zone Report是用于获取Zone信息的接口，它可以告知主机有关Zone的状态、容量和健康状况等信息。主机可以通过Zone Report来了解SSD的Zone布局，从而更好地进行数据管理和写入优化。</p></li><li><p>Zoned Block Device：Zoned Block Device是一个抽象层，用于将ZNS架构与主机系统的块设备接口对接。它负责将传统的块设备操作转换为Zone的顺序写入操作。Zoned Block Device可以通过读取Zone Report来确定Zone的写入状态，并将数据按照Zone的规则进行写入，以保证数据的顺序写入特性。</p><p><img src="../img/confZNS/zone.png" alt="zone"></p><p><img src="../img/confZNS/zns_architecture.png" title="zns_architecture"></p></li></ol><p>ZNS架构的工作原理是，主机系统通过Zoned Block Device进行数据的写入和读取操作，而Zoned Block Device则利用Zone Management来管理Zone的状态，并保证数据的顺序写入。在写入过程中，主机将数据写入当前打开的Zone，当Zone写满后，Zone Management会自动关闭当前Zone并打开下一个空闲的Zone，从而实现数据的连续写入。当Zone已经关闭且不再接受数据时，主机需要通过Zone Report获取新的可写Zone，并继续写入数据。</p><h4 id="2-软件层面的修改"><a href="#2-软件层面的修改" class="headerlink" title="2. 软件层面的修改"></a>2. 软件层面的修改</h4><p>为了评估ZNS带来的好处，对四个重要的软件项目进行的修改和开发工作。具体来说，首先对Linux内核进行了修改，以支持ZNS SSD。其次，修改了f2fs文件系统，以评估在更高级别的存储堆栈层面上进行区域集成的好处。第三，修改了fio基准测试工具，以支持新添加的ZNS特定属性。第四，开发了ZenFS，这是一个新颖的RocksDB存储后端，通过区域控制数据的放置，以评估区域存储的端到端集成的好处。</p><blockquote><p>We have added support to four major software projects to evaluate the benefits of ZNS. First, we made modifications to the Linux kernel to support ZNS SSDs. Second, we modified the f2fs file system to evaluate the benefits of zone integration at a higher-level storage stack layer. Third, we modified the fio [6] benchmark to support the newly added ZNS-specific attributes. Fourth, we developed ZenFS [25], a novel storage backend for RocksDB that allows control of data placement through zones, to evaluate the benefits of end-to-end integration for zoned storage. We describe the relatively few changes necessary to support ZNS when building upon the existing ZAC/ZBC support for the first three projects [5, 42, 52] (§4.1) and finally detail the architecture of ZenFS (§4.2).</p></blockquote><p>对以上四个层面的原理在参考论文中已经详细介绍，且跟后续的confZNS原理理解相互独立，在此不再赘述。<del>（我承认zenfs的组件好多，我有些看不下去了）</del></p><h2 id="ConfZNS"><a href="#ConfZNS" class="headerlink" title="ConfZNS"></a>ConfZNS</h2><h3 id="background"><a href="#background" class="headerlink" title="background"></a>background</h3><p>ConfZNS模拟器用于探索和理解ZNS固态硬盘（SSD）的设计空间。ConfZNS支持多种ZNS SSD的区域映射方式，并允许从内部设备结构到应用软件的完整堆栈探索。该模拟器具有时间精确性，对于存储研究社区来说是一个多功能工具。文章<a href="https://dl.acm.org/doi/pdf/10.1145/3579370.3594772">ConfZNS</a>通过与两个不同厂商的真实ZNS SSD进行实验，并与之前一项研究的测量结果进行验证，证明了ConfZNS的有效性。文章还探讨了ConfZNS在使用硬件和软件参数对各种软件（如F2FS、RocksDB和Docker）在不同ConfZNS配置下的性能进行评估和比较的潜力。ConfZNS预计将促进ZNS SSD硬件及其相关软件的优化。</p><blockquote><p>First, ConfZNS supports diverse zone mappings of ZNS SSD.</p><p>Second, ConfZNS is time-accurate.</p><p>Third, ConfZNS allows a full stack exploration from the internal device structure to the application software.</p></blockquote><p>那么confZNS和ZNS的区别是什么？</p><p>ConfZNS和ZNS之间的区别在于它们的功能和用途。ZNS 是一种新一代的固态硬盘，通过改变SSD和主机之间的存储管理责任分配，以及利用硬件和软件层面的内部并行性，来解决传统块状存储器的性能和资源相关问题。而ConfZNS是一个用于探索和理解ZNS SSD设计空间的仿真器，它支持各种ZNS SSD的区域映射配置，从SSD内部结构到应用软件的全栈探索，并且具有时间精确度，因此它是存储研究领域的一个多功能工具。</p><h3 id="ConfZNS-architect"><a href="#ConfZNS-architect" class="headerlink" title="ConfZNS architect"></a>ConfZNS architect</h3><p>ZNS的组成包括以下几个关键组件：</p><h4 id="1-ZNS配置器"><a href="#1-ZNS配置器" class="headerlink" title="1. ZNS配置器"></a>1. ZNS配置器</h4><p>用户通过提供配置文件来灵活配置ZNS固态硬盘的硬件参数，例如zone的大小、区域重置时间以及通道/路向区域的映射等。此外，还可以设置基本的SSD配置参数，如通道/路的数量、芯片的块/页大小、编程/读取/擦除时间、主机接口带宽限制等。</p><p>翻一下<a href="https://github.com/vtess/FEMU/blob/master/hw/femu/zns/zns.c">源码</a>：</p><ul><li><strong>初始化ZnSSD控制器</strong></li><li><strong>配置ZnSSD控制器参数和特性</strong></li><li><strong>初始化Zone的几何属性和标识信息</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><br><span class="hljs-comment">// 这个函数用于设置控制器的名称和序列号。在这里，名称设为&quot;FEMU ZNS-SSD Controller&quot;，序列号设为&quot;vZNSSD&quot;。</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">zns_set_ctrl_str</span><span class="hljs-params">(FemuCtrl *n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> fsid_zns = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *zns_mn = <span class="hljs-string">&quot;FEMU ZNS-SSD Controller&quot;</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *zns_sn = <span class="hljs-string">&quot;vZNSSD&quot;</span>;<br><br>    <span class="hljs-built_in">nvme_set_ctrl_name</span>(n, zns_mn, zns_sn, &amp;fsid_zns);<br>&#125;<br><span class="hljs-comment">// 这个函数用于设置控制器的PCI配置信息。将厂商ID设为Intel（PCI_VENDOR_ID_INTEL），设备ID设为0x5845。</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">zns_set_ctrl</span><span class="hljs-params">(FemuCtrl *n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">uint8_t</span> *pci_conf = n-&gt;parent_obj.config;<br><br>    <span class="hljs-built_in">zns_set_ctrl_str</span>(n);<br>    <span class="hljs-built_in">pci_config_set_vendor_id</span>(pci_conf, PCI_VENDOR_ID_INTEL);<br>    <span class="hljs-built_in">pci_config_set_device_id</span>(pci_conf, <span class="hljs-number">0x5845</span>);<br>&#125;<br><span class="hljs-comment">// 这个函数用于在控制器启动时设置Zoned Namespace的参数。</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">zns_start_ctrl</span><span class="hljs-params">(FemuCtrl *n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* Coperd: let&#x27;s fail early before anything crazy happens */</span><br>    <span class="hljs-built_in">assert</span>(n-&gt;page_size == <span class="hljs-number">4096</span>);<br><br>    <span class="hljs-keyword">if</span> (!n-&gt;zasl_bs) &#123;<br>        n-&gt;zasl = n-&gt;mdts;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (n-&gt;zasl_bs &lt; n-&gt;page_size) &#123;<br>            <span class="hljs-built_in">femu_err</span>(<span class="hljs-string">&quot;ZASL too small (%dB), must &gt;= 1 page (4K)\n&quot;</span>, n-&gt;zasl_bs);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        n-&gt;zasl = <span class="hljs-number">31</span> - <span class="hljs-built_in">clz32</span>(n-&gt;zasl_bs / n-&gt;page_size);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 这个函数用于初始化Zoned Namespace的控制器和命名空间。</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">zns_init</span><span class="hljs-params">(FemuCtrl *n, Error **errp)</span></span><br><span class="hljs-function"></span>&#123;<br>    NvmeNamespace *ns = &amp;n-&gt;namespaces[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-built_in">zns_set_ctrl</span>(n);<br><br>    <span class="hljs-built_in">zns_init_zone_cap</span>(n);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">zns_init_zone_geometry</span>(ns, errp) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">zns_init_zone_identify</span>(n, ns, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">zns_init_params</span>(n);<br>&#125;<br><span class="hljs-comment">// 这个函数在控制器退出时释放为Zoned Namespace模式分配的额外资源（例如Zones），但在此代码中函数体为空，表示并没有实际释放资源的操作。</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">zns_exit</span><span class="hljs-params">(FemuCtrl *n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Release any extra resource (zones) allocated for ZNS mode</span><br><span class="hljs-comment">     */</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>在代码中，<code>zns_exit</code>函数的函数体是空的，即没有实际的释放资源操作。这可能是因为在当前的代码实现中，并没有为 ZNS 模式分配额外的资源（例如 Zones），或者在控制器退出时不需要特定的资源清理操作。根据参考代码中的数据结构，合理补充 <code>zns_exit</code> 函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">zns_exit</span><span class="hljs-params">(FemuCtrl *n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zns_ssd</span> *<span class="hljs-title">zns</span> =</span> n-&gt;zns;<br>    <span class="hljs-keyword">if</span> (zns) &#123;<br>        <span class="hljs-comment">// 释放掉分配给每个 Zone 的资源</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; zns-&gt;num_ch; i++) &#123;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zns_ch</span> *<span class="hljs-title">ch</span> =</span> &amp;zns-&gt;ch[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; zns-&gt;num_lun; j++) &#123;<br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zns_fc</span> *<span class="hljs-title">fc</span> =</span> &amp;ch-&gt;fc[j];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">32</span>; k++) &#123;<br>                    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zns_blk</span> *<span class="hljs-title">blk</span> =</span> &amp;fc-&gt;blk[k];<br>                    <span class="hljs-comment">// 可根据实际分配情况来释放 Zone 相关资源</span><br>                    <span class="hljs-comment">// 例如 blk-&gt;data 指向的数据缓冲区等</span><br>                    <span class="hljs-built_in">g_free</span>(blk-&gt;data);<br>                &#125;<br>                <span class="hljs-built_in">g_free</span>(fc-&gt;blk);<br>            &#125;<br>            <span class="hljs-built_in">g_free</span>(ch-&gt;fc);<br>        &#125;<br>        <span class="hljs-built_in">g_free</span>(zns-&gt;ch);<br>        <span class="hljs-built_in">g_free</span>(zns);<br>        n-&gt;zns = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 清理其他需要释放的资源，例如控制器可能分配的其他数据结构等</span><br><br>    <span class="hljs-comment">// 取消特定设置，例如恢复控制器配置到默认状态</span><br><br>    <span class="hljs-comment">// 如果还有其他需要释放的资源，继续在此处添加相应的代码</span><br><br>    <span class="hljs-comment">// 最后，确保将所有可能导致资源泄漏的指针设置为 NULL，以避免悬挂指针的问题</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="2-ZNS结构"><a href="#2-ZNS结构" class="headerlink" title="2. ZNS结构"></a>2. ZNS结构</h4><h5 id="逻辑页和物理页的映射"><a href="#逻辑页和物理页的映射" class="headerlink" title="逻辑页和物理页的映射"></a>逻辑页和物理页的映射</h5><p>ZNS的映射是指在ZNS SSD中逻辑页与物理页之间的关联。ZNS SSD将存储空间划分为多个zone，每个区域包含一组逻辑页。映射关系决定了逻辑页如何映射到物理页，从而影响了ZNS设备的性能。</p><p>ZNS SSD的映射可以分为三种类型：单一并行单元映射（SU-zone）、多个并行单元映射（MU-zone）和全部并行单元映射（FU-zone）。在SU-zone映射中，一个区域仅映射到一个并行单元，而在FU-zone映射中，一个区域可以利用所有的并行单元。MU-zone映射介于两者之间，一个区域映射到多个并行单元。</p><p>ZNS SSD的映射由ZNS架构进行管理。首先，ZNS架构构建一个用户配置的通道-路组织结构。然后，它建立一个映射函数或表来关联区域和并行单元。大多数情况下，使用映射函数，但在映射比较复杂时，ConfZNS使用映射表。例如，当配置硬件以支持单个设备内的混合映射时，ConfZNS使用映射表。</p><p><img src="../img/confZNS/spectrum.png" alt="spectrum"></p><p>在ZNS SSD中，逻辑页和物理页之间的映射是通过通道（channels）和路（ways）进行的。通道表示SSD中的通道数量，路表示每个通道中的路数量。</p><p>假设有一个ZNS SSD设备由4个通道和2个路组成，则逻辑页的映射关系如下：</p><ul><li>第一个逻辑页（LPN）被映射到通道0和路0上的物理页（PPN）。</li><li>第二个LPN被映射到通道1和路0上的PPN。</li><li>第三个LPN被映射到通道2和路0上的PPN。</li><li>第四个LPN被映射到通道3和路0上的PPN。</li><li>第五个LPN被映射到通道0和路1上的PPN。</li><li>以此类推，映射规则循环重复。</li></ul><p>在这种映射方式下，逻辑页和物理页的映射关系能够最大化SSD的吞吐量，并且通过通道和路的方式实现。具体的映射方式和规则可以根据ZNS SSD设备的配置和设计来进行调整和修改。</p><p>翻一下<a href="https://github.com/vtess/FEMU/blob/master/hw/femu/zns/zns.c">源码</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 将逻辑页号（Logical Page Number, LPN）映射为物理页地址（Physical Page Address, PPA）。它会根据传入的控制器、命名空间和逻辑页号，计算得到相应的物理页地址。</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> struct ppa <span class="hljs-title">lpn_to_ppa</span><span class="hljs-params">(FemuCtrl *n, NvmeNamespace *ns, <span class="hljs-keyword">uint64_t</span> lpn)</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-keyword">uint32_t</span> zone_idx = <span class="hljs-built_in">zns_zone_idx</span>(ns, (lpn * <span class="hljs-number">4096</span>));<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zns_ssd</span> *<span class="hljs-title">zns</span> =</span> n-&gt;zns;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">write_pointer</span> *<span class="hljs-title">wpp</span> =</span> &amp;zns-&gt;wp;<br><span class="hljs-comment">//uint64_t num_ch = zns-&gt;num_ch;</span><br><span class="hljs-comment">//uint64_t num_lun = zns-&gt;num_lun;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ppa</span> <span class="hljs-title">ppa</span> =</span> &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-comment">//printf(&quot;OFFSET: %&quot;PRIu64&quot;\n\n&quot;, offset);</span><br><span class="hljs-comment">//wpp-&gt;ch,lun</span><br>ppa.g.ch = wpp-&gt;ch;<br>ppa.g.fc = wpp-&gt;lun;<br>ppa.g.blk = zone_idx;<br><br>    <span class="hljs-keyword">return</span> ppa;<br>&#125;<br><span class="hljs-comment">// 在进行随机读操作时，推进读取指针以提高性能。在 ZNS SSD 中，随机读操作可能需要在多个物理页上执行，通过推进读取指针可以减少寻址开销。</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">advance_read_pointer</span><span class="hljs-params">(FemuCtrl *n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zns_ssd</span> *<span class="hljs-title">zns</span> =</span> n-&gt;zns;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">write_pointer</span> *<span class="hljs-title">wpp</span> =</span> &amp;zns-&gt;wp;<br>    <span class="hljs-keyword">uint8_t</span> num_ch = zns-&gt;num_ch;<br>    <span class="hljs-keyword">uint8_t</span> num_lun = zns-&gt;num_lun;<br><br>    <span class="hljs-comment">//printf(&quot;NUM CH: %&quot;PRIu64&quot;\n&quot;, wpp-&gt;ch);</span><br>    <span class="hljs-built_in">check_addr</span>(wpp-&gt;ch, num_ch);<br>    wpp-&gt;ch++;<br><br>    <span class="hljs-keyword">if</span> (wpp-&gt;ch != num_ch) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* Wrap-up, wpp-&gt;ch == num_ch */</span><br>    wpp-&gt;ch = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">check_addr</span>(wpp-&gt;lun, num_lun);<br>    wpp-&gt;lun++;<br>    <span class="hljs-keyword">if</span> (wpp-&gt;lun == num_lun) &#123;<br>        wpp-&gt;lun = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">assert</span>(wpp-&gt;ch == <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">assert</span>(wpp-&gt;lun == <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>关于 <code>lpn_to_ppa</code>函数，首先，它通过调用zns_zone_idx函数计算LPN对应的区域索引（zone_idx）。然后，通过zns-&gt;wp结构体指针（写指针）获取当前通道和LUN，并将这些信息与区域索引合并成一个PPA。最后，将构建的PPA返回。在看 <code>zns_zone_idx</code>函数的时候其实是有些懵的：为什么要 <code>zone_size_log2</code> 来做判断条件？为什么分支计算分别是右移和做除法？<code>zone_size_log2</code> 和 <code>zone_size</code> 的区别是什么？为什么为什么为什么？后来我想通了：</p><p>如果 <code>zone_size_log2</code> 大于 0，则说明 Zone 大小是固定的，是以 2 为底的对数值，表示每个 Zone 的大小是 2 的多少次幂。例如，如果 <code>zone_size_log2</code> 等于 12，表示每个 Zone 的大小是 2^12 = 4096 个逻辑块（Logical Block）。在这种情况下，通过右移 <code>zone_size_log2</code> 位，可以快速计算逻辑块地址 <code>slba</code> 属于哪个 Zone。与此相对应的是，如果 <code>zone_size_log2</code> 小于等于 0，则说明 Zone 大小是固定的块数（block count），而不是以 2 为底的对数值。例如，如果 <code>zone_size</code> 等于 128，表示每个 Zone 的大小是 128 个逻辑块（Logical Block）。在这种情况下，直接通过除法运算来计算逻辑块地址 <code>slba</code> 属于哪个 Zone。</p><p>两种方式都可以用来确定逻辑块地址所属的 Zone，但方式不同。固定的 <code>zone_size_log2</code> 方式可以通过移位运算更高效地计算，而固定的块数方式则需要进行除法运算。妙啊！</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint32_t</span> <span class="hljs-title">zns_zone_idx</span><span class="hljs-params">(NvmeNamespace *ns, <span class="hljs-keyword">uint64_t</span> slba)</span></span><br><span class="hljs-function"></span>&#123;<br>    FemuCtrl *n = ns-&gt;ctrl;<br><br>    <span class="hljs-keyword">return</span> (n-&gt;zone_size_log2 &gt; <span class="hljs-number">0</span> ? slba &gt;&gt; n-&gt;zone_size_log2 : slba / n-&gt;zone_size);<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="实现Zone的管理和状态转换"><a href="#实现Zone的管理和状态转换" class="headerlink" title="实现Zone的管理和状态转换"></a>实现Zone的管理和状态转换</h5><p>通过检查读写操作是否在有效的 Zone 范围内、自动打开新的 Zone 以继续写入数据，并根据写入操作的块数更新 Zone 的写指针等操作，有效地管理和维护 Zoned Namespace 的状态。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 检查读取操作是否在有效的 Zone 范围内。如果不在有效范围内，则返回相应的错误码</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint16_t</span> <span class="hljs-title">zns_check_zone_read</span><span class="hljs-params">(NvmeNamespace *ns, <span class="hljs-keyword">uint64_t</span> slba, <span class="hljs-keyword">uint32_t</span> nlb)</span>｛｝</span><br><span class="hljs-function"><span class="hljs-comment">// 检查写入操作是否在有效的 Zone 范围内。如果不在有效范围内或不满足写入条件，则返回相应的错误</span></span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint16_t</span> <span class="hljs-title">zns_check_zone_write</span><span class="hljs-params">(FemuCtrl *n, NvmeNamespace *ns,NvmeZone *zone,<span class="hljs-keyword">uint64_t</span> slba,<span class="hljs-keyword">uint32_t</span> nlb, <span class="hljs-keyword">bool</span> append)</span>｛｝</span><br><span class="hljs-function"><span class="hljs-comment">// 自动打开 Zone。这个函数通常在写入操作时调用，用于检查 Zone 的状态并自动打开新的 Zone。如果 Zone 已经处于打开状态或不需要打开新 Zone，则该函数可能不执行任何操作。在某些场景下，如果 Zone 满了，可以自动打开新 Zone 来继续写入数据</span></span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint16_t</span> <span class="hljs-title">zns_auto_open_zone</span><span class="hljs-params">(NvmeNamespace *ns, NvmeZone *zone)</span>｛｝</span><br><span class="hljs-function"><span class="hljs-comment">// 根据写入操作的 NLB（写入的块数），更新 Zone 的写指针。并返回写入完成后 Zone 的新写指针</span></span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">zns_advance_zone_wp</span><span class="hljs-params">(NvmeNamespace *ns, NvmeZone *zone, <span class="hljs-keyword">uint32_t</span> nlb)</span>｛｝</span><br><span class="hljs-function"><span class="hljs-comment">// 完成 Zoned Namespace 的写操作。这个函数通常在写入操作完成后调用，用于更新 Zone 的元数据信息等。还可以执行一些额外的操作，如更新 Zone 状态、检查 Zone 是否满等</span></span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">zns_finalize_zoned_write</span><span class="hljs-params">(NvmeNamespace *ns, NvmeRequest *req, <span class="hljs-keyword">bool</span> append)</span>｛｝</span><br></code></pre></div></td></tr></table></figure><h5 id="实现Zone内数据的写入、读取和追加写入"><a href="#实现Zone内数据的写入、读取和追加写入" class="headerlink" title="实现Zone内数据的写入、读取和追加写入"></a>实现Zone内数据的写入、读取和追加写入</h5><p>可以根据读写操作的起始地址和块数，在 Zoned Namespace 中执行相应的读取和写入操作，并根据 Zone 的状态和数据分布进行相应的处理和管理。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint16_t</span> <span class="hljs-title">zns_do_write</span><span class="hljs-params">(FemuCtrl *n, NvmeRequest *req, <span class="hljs-keyword">bool</span> append, <span class="hljs-keyword">bool</span> implicit)</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint16_t</span> <span class="hljs-title">zns_read</span><span class="hljs-params">(FemuCtrl *n, NvmeNamespace *ns, NvmeCmd *cmd, NvmeRequest *req&#123;&#125;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint16_t</span> zns_write(FemuCtrl *n, NvmeNamespace *ns, NvmeCmd *cmd, NvmeRequest *req&#123;&#125;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">uint16_t</span> zns_zone_append(FemuCtrl *n, NvmeRequest *req)</span></span><br><span class="hljs-params"><span class="hljs-function">&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">return</span> zns_do_write(n, req, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br></code></pre></div></td></tr></table></figure><h5 id="实现Zone管理指令（Zone-Management-Command）的处理"><a href="#实现Zone管理指令（Zone-Management-Command）的处理" class="headerlink" title="实现Zone管理指令（Zone Management Command）的处理"></a>实现Zone管理指令（Zone Management Command）的处理</h5><p>这些函数用于处理 Zone 管理指令，根据传入的请求参数 req，执行相应的 Zone 管理操作。Zone 管理指令是 NVMe 协议中针对 Zoned Namespace 的特有指令，用于管理和控制 Zone 的状态和属性。在这些函数中，会根据不同的 Zone 管理指令的具体要求，对 Zoned Namespace 中的 Zone 进行相应的操作，例如打开 Zone、关闭 Zone、重置 Zone 等。这些操作是 Zoned Namespace 特有的管理功能，用于优化 Zoned SSD 设备的性能和寿命。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 处理 Zone 管理指令的发送</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint16_t</span> <span class="hljs-title">zns_zone_mgmt_send</span><span class="hljs-params">(FemuCtrl *n, NvmeRequest *req)</span></span>&#123;&#125;<br><span class="hljs-comment">// 处理 Zone 管理指令的接收</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint16_t</span> <span class="hljs-title">zns_zone_mgmt_recv</span><span class="hljs-params">(FemuCtrl *n, NvmeRequest *req)</span></span>&#123;&#125;<br></code></pre></div></td></tr></table></figure><h5 id="实现Zone报告指令（Zone-Report-Command）的处理"><a href="#实现Zone报告指令（Zone-Report-Command）的处理" class="headerlink" title="实现Zone报告指令（Zone Report Command）的处理"></a>实现Zone报告指令（Zone Report Command）的处理</h5><p>用于处理 Zone 报告指令，根据传入的请求参数 req，生成 Zone 报告数据并返回给主机。Zone 报告指令是 NVMe 协议中针对 Zoned Namespace 的特有指令，用于向主机报告当前 Zone 的状态和属性信息。在这个函数中，会根据 Zoned Namespace 的状态和当前 Zone 的信息，生成相应的 Zone 报告数据，并通过 NVMe 设备的数据传输功能将数据返回给主机。这样，主机就可以获取到 Zoned Namespace 中各个 Zone 的状态，从而进行合理的数据管理和优化策略。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint16_t</span> <span class="hljs-title">zns_zone_report</span><span class="hljs-params">(FemuCtrl *n, NvmeRequest *req)</span></span>&#123;&#125;<br></code></pre></div></td></tr></table></figure><h4 id="3-时间估算器"><a href="#3-时间估算器" class="headerlink" title="3. 时间估算器"></a>3. 时间估算器</h4><p>ConfZNS中的时间估算器负责管理整个仿真过程中的时间准确性。它通过考虑服务时间和排队延迟来评估I/O请求的延迟。服务时间由用户给出，而延迟时间取决于所请求的资源是否正在使用或可用，以及队列中有多少先前的请求。排队延迟是通过使用全局和局部时钟分析资源争用来估算的。</p><p>时间估算器通过层级时钟算法来识别资源争用和等待请求的数量。它使用两个时钟，一个是全局时钟（𝑔𝑐），一个是局部时钟（𝑙𝑐）。全局时钟以每个时钟周期递增，而局部时钟是为每个资源分配的。局部时钟被设置为相关资源的下一个可用时间。当请求到达资源时，将相关资源的局部时钟设置为𝑙𝑐 = 𝑚𝑎𝑥 (𝑔𝑐,𝑙𝑐) + service_time，即下一个可用时间。</p><p>全局时钟和局部时钟满足以下性质：如果局部时钟小于等于全局时钟，则与局部时钟相关的资源处于空闲状态。否则，该资源正在忙碌状态。我们还可以通过两个时钟的差异来确定等待请求的数量。例如，假设某个资源的服务时间为2，并且全局时钟和局部时钟都为0。经过1个时钟周期后，如果没有请求到达该资源，全局时钟变为1，而局部时钟仍为0，这意味着该资源处于空闲状态。如果有请求到达该资源，局部时钟变为3，这意味着该资源在全局时钟为3之前都处于忙碌状态。</p><p>以读取请求和写入请求的延迟估计为例，ConfZNS利用逻辑页号（LPN）和物理页号（PPN）来估算延迟时间。在不同的区域映射下，LPN和PPN的对应关系不同，从而影响延迟时间的估计。</p><p><img src="../img/confZNS/time_estimate.png" alt="time_estimate"></p><p>翻一下<a href="https://github.com/vtess/FEMU/blob/master/hw/femu/zns/zns.c">源码</a>，femu实现：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 用于计算NAND命令的执行时间。</span><br><span class="hljs-comment">// 根据传入的NAND命令类型（NAND_READ、NAND_WRITE或NAND_ERASE），以及SSD的读写延迟和擦除延迟，计算出NAND命令的执行时间（lat）。</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">zns_advance_status</span><span class="hljs-params">(FemuCtrl *n, struct nand_cmd *ncmd, struct ppa *ppa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> c = ncmd-&gt;cmd;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zns_ssd</span> *<span class="hljs-title">zns</span> =</span> n-&gt;zns;<br>    <span class="hljs-keyword">uint64_t</span> nand_stime;<br>    <span class="hljs-keyword">uint64_t</span> req_stime = (ncmd-&gt;stime == <span class="hljs-number">0</span>) ? \<br>        <span class="hljs-built_in">qemu_clock_get_ns</span>(QEMU_CLOCK_REALTIME) : ncmd-&gt;stime;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zns_fc</span> *<span class="hljs-title">fc</span> =</span> <span class="hljs-built_in">get_fc</span>(zns, ppa);<br><br>    <span class="hljs-keyword">uint64_t</span> lat = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">uint64_t</span> read_delay = n-&gt;zns_params.zns_read;<br>    <span class="hljs-keyword">uint64_t</span> write_delay = n-&gt;zns_params.zns_write;<br>    <span class="hljs-keyword">uint64_t</span> erase_delay = <span class="hljs-number">2000000</span>;<br><br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (c) &#123;<br>    <span class="hljs-keyword">case</span> NAND_READ:<br>        nand_stime = (fc-&gt;next_fc_avail_time &lt; req_stime) ? req_stime : \<br>                     fc-&gt;next_fc_avail_time;<br>        fc-&gt;next_fc_avail_time = nand_stime + read_delay;<br>        lat = fc-&gt;next_fc_avail_time - req_stime;<br>    <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> NAND_WRITE:<br>    nand_stime = (fc-&gt;next_fc_avail_time &lt; req_stime) ? req_stime : \<br>            fc-&gt;next_fc_avail_time;<br>    fc-&gt;next_fc_avail_time = nand_stime + write_delay;<br>    lat = fc-&gt;next_fc_avail_time - req_stime;<br>    <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> NAND_ERASE:<br>        nand_stime = (fc-&gt;next_fc_avail_time &lt; req_stime) ? req_stime : \<br>                        fc-&gt;next_fc_avail_time;<br>        fc-&gt;next_fc_avail_time = nand_stime + erase_delay;<br>        lat = fc-&gt;next_fc_avail_time - req_stime;<br>        <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">/* To silent warnings */</span><br>        ;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> lat;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>NAND闪存是SSD中常见的存储介质，其读写和擦除操作需要通过特定的NAND命令来执行。常见的NAND命令包括读取（NAND_READ）、写入（NAND_WRITE）和擦除（NAND_ERASE）。</p><p>计算NAND命令的执行时间是为了模拟SSD的读写延迟和擦除延迟，从而更真实地模拟SSD的性能表现。在实际的SSD中，NAND闪存芯片执行不同操作的时间存在差异，例如，读取速度通常较快，写入速度较慢，而擦除速度较为缓慢。这些延迟会影响到SSD的整体性能和数据访问效率。</p><p>通过计算NAND命令的执行时间，代码可以在模拟的SSD中引入实际的读写延迟和擦除延迟，以便更准确地模拟SSD的行为。</p><p>confZNS的实现<a href="https://github.com/DKU-StarLab/ConfZNS/blob/master/hw/femu/zns/zns.c">code</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">zns_advance_status</span><span class="hljs-params">(FemuCtrl *n, NvmeNamespace *ns, NvmeCmd *cmd, NvmeRequest *req)</span></span>&#123;<br>  <br>    NvmeRwCmd *rw = (NvmeRwCmd *)&amp;req-&gt;cmd;<br>    <span class="hljs-keyword">uint8_t</span> opcode = rw-&gt;opcode;<br>    <span class="hljs-keyword">uint32_t</span> dw13 = <span class="hljs-built_in">le32_to_cpu</span>(cmd-&gt;cdw13);<br><br>    <span class="hljs-keyword">uint8_t</span> action;<br>    action = dw13 &amp; <span class="hljs-number">0xff</span>;<br><br>    <span class="hljs-comment">// Zone Reset </span><br>    <span class="hljs-keyword">if</span> (action == NVME_ZONE_ACTION_RESET)&#123;<br>        <span class="hljs-comment">//reset zone-&gt;wp and zone-&gt;status=Empty</span><br>        <span class="hljs-comment">//reset zone, causing every chip lat +</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">znssd_reset_zones</span>(n-&gt;zns,req);<br>    &#125;<br>    <span class="hljs-comment">// Read, Write </span><br>    <span class="hljs-built_in">assert</span>(opcode == NVME_CMD_WRITE || opcode == NVME_CMD_READ || opcode == NVME_CMD_ZONE_APPEND);<br>    <span class="hljs-keyword">if</span>(req-&gt;is_write)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">znsssd_write</span>(n-&gt;zns, req);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">znsssd_read</span>(n-&gt;zns, req);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这段代码是针对 NVMe命名空间进行管理的函数，主要处理读写请求，并对 NVMe 命令进行处理以实现模拟的时延。具体功能如下：</p><p>首先，从 NVMe 命令结构中解析出相关信息，如读/写命令、操作码等。</p><p>根据操作码执行相应操作：</p><ul><li>如果是 <code>NVME_ZONE_ACTION_RESET</code>，则调用 <code>znssd_reset_zones</code> 函数来重置 zone，将 zone 的写指针（wp）和状态（status）重置，并将其状态设置为空（Empty）。</li><li>对于读（<code>NVME_CMD_READ</code>）和写（<code>NVME_CMD_WRITE</code>）命令，根据 <code>req-&gt;is_write</code> 来判断是执行读还是写操作，并调用相应的函数 <code>znsssd_write</code> 或 <code>znsssd_read</code> 来处理读写请求。</li></ul><p>为什么 ConfZNS 更加准确，而 FEMU 存在问题：</p><ul><li>ConfZNS 使用 NVMe 命名空间模拟，因此其时延模拟更加细粒度，同时根据请求的不同类型进行区分处理。这种精细的时延模拟可以更好地反映真实的 SSD 设备行为，因为现代 SSD 设备通常支持多种操作，如读、写、擦除、重置等，并且每种操作都有自己特定的时延特征。</li><li>FEMU 虽然提供了时延模拟，但其延迟设置是硬编码的，没有考虑实际 SSD 设备的特性和不同操作之间的时序关系。这可能导致模拟的结果与真实设备的行为不一致，特别是当 SSD 设备具有复杂的内部状态转换和时序要求时，FEMU 的模拟可能会产生不准确的结果。</li></ul><p>综上所述，尽管两者都提供了一种形式的时延模拟，但 ConfZNS 更加准确和灵活，因为它模拟了更细粒度的 NVMe 命令，并根据不同请求类型进行区分处理。而 FEMU 的模拟虽然可行，但在时延设置上相对简单且不够准确，可能无法完全符合真实 SSD 设备的行为。</p><ol start="4"><li>资源监视器</li></ol><p>资源监视器收集各种ZNS SSD内部的统计数据，如各通道和路的利用率，有助于分析SSD的I/O分布能力和功耗。此外，它还报告各个单位的块擦除计数和I/O请求的来源（NVMe提交队列标识符）等内部数据。<br>总之，ZNS的组成包括ZNS配置器、ZNS结构、时间估算器和资源监视器。这些组件共同构成了ConfZNS这个用于仿真和研究ZNS SSD的工具。</p><h2 id="运行confZNS"><a href="#运行confZNS" class="headerlink" title="运行confZNS"></a>运行confZNS</h2><p>主要操作就是拉取<a href="https://github.com/DKU-StarLab/ConfZNS/">ConfZNS源码</a>，按照readme来配置相关运行环境，成功运行该仿真器并能跑OS就可以了。（指能运行./run-zns.sh）。</p><p>然而呢，配置之路并不是一帆风顺的，在此简短记录一下我的采坑过程😭</p><p><strong>OS限制</strong></p><p>刚开始我用的平台是WSL编译femu，根据readme的123步都没有问题，成功编译femu并且有了.qcow2的映像。但是在最后一步运行run-zns.sh的时候，他会报错not support aio，说明wsl可能不支持异步输入输出。我还是不死心，故而专门去验证了一下：</p><ol><li><p>创建一个简单的测试程序来使用 <code>libaio</code> 库。创建一个名为 <code>aio_test.c</code> 的文件，并将以下代码粘贴到其中：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libaio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">io_context_t</span> ctx;<br>    <span class="hljs-keyword">int</span> ret = io_setup(<span class="hljs-number">1</span>, &amp;ctx);<br>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;AIO is not supported on this system.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    io_destroy(ctx);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;AIO is supported on this system.\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>在 WSL 终端中，使用以下命令编译测试程序：<code>gcc -o aio_test aio_test.c -laio </code></p></li><li><p>运行编译后的测试程序：<code>./aio_test </code></p><p>好嘛，输出的果真是 <code>AIO is not supported on this system.</code></p></li></ol><p>在这个时候其实我对FEMU还有些疑问，我既然已经成功编译了FEMU，导入.qcow2的镜像是为了什么呢？</p><p>本着面向问题学习的思路，我查了一些资料，终于豁然：</p><p>虽然我已经成功编译了FEMU，但编译后的FEMU本身并不包含任何操作系统或用户空间环境。它仅提供了一个执行虚拟化的平台。因此，为了能够在FEMU中运行操作系统和应用程序，还需要在虚拟机中安装操作系统，并通过.qcow2镜像将操作系统和相关环境导入到虚拟机中。</p><p>在虚拟机中安装操作系统后，我可以登录到FEMU虚拟机中，并在其中运行应用程序或进行测试。</p><p>所以，我需要在虚拟机上使用FEMU，因为FEMU本身是作为一个虚拟化平台来运行操作系统的。在虚拟机中配置的操作系统和环境将作为FEMU的客户机，运行在FEMU的虚拟化环境中。</p><p><strong>另辟蹊径</strong></p><p>这个时候我就想，既然我已经有了.qcow2的映像，我直接把这个映像导入虚拟机中不就行了。这个虚拟机就是使用镜像文件作为硬盘而工作的，bingo！</p><p>这个时候问题又来了，我用的是VMvare，他是不支持导入.qcow2后缀的disk的。这难不倒我，转换成他支持的格式就可以了。一行代码搞定：</p><p><code>qemu-img convert -f qcow2 file.qcow2 -O vmdk file.vmdk</code></p><p>然后就得到了如下结果：<br><img src="../img/confZNS/1.png"></p><p>看起来是成功了哈</p><p><strong>原始的方法</strong></p><p>做到这我还是有些心虚，毕竟没有按照官方的步骤做。还有就是<strong>在FEMU的环境下通过.qcow2镜像进入FEMU的虚拟机</strong>和我直接<strong>新建一个虚拟机导入.qcow2</strong>进入其中，这其中还是有所区别的。毕竟我在FEMU的环境下，需要使用它提供的一些自定义选项和功能（比如我可以选择运行zns模式或者nossd模式）。但是直接导入.qcow2就不知道我用的哪种模式仿真了。</p><p>那么我就选择在VMvare中用ubuntu 20.04的disk作为实验环境，再次按照readme的配置走一遍。这时候新问题出现了，在编译过程中报错 <code>Could not access KVM kernel module: No such file or directory. qemu-system-x86_64: failed to initialize kvm: No such file or directory</code>.原因是系统没有启用虚拟化，比如Intel的VT-x。需要在VWvare中启用一下虚拟化，我是参照这篇<a href="https://blog.csdn.net/qq_46106285/article/details/127745752">blog</a>把问题解决了。</p><p><img src="../img/confZNS/2.png"></p><p><img src="../img/confZNS/3.png"></p><p><img src="../img/confZNS/4.png"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.usenix.org/system/files/atc21-bjorling.pdf">ZNS: Avoiding the Block Interface Tax for Flash-based SSDs</a></li><li><a href="https://dl.acm.org/doi/pdf/10.1145/3579370.3594772">ConfZNS : A Novel Emulator for Exploring Design Space of ZNS SSDs</a></li><li><a href="https://github.com/DKU-StarLab/ConfZNS/">https://github.com/DKU-StarLab/ConfZNS/</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>SSD &amp; ZNS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023 first week</title>
    <link href="/posts/ae8aadc8.html"/>
    <url>/posts/ae8aadc8.html</url>
    
    <content type="html"><![CDATA[<p>稍稍记录一下2023繁忙的第一周</p><p><strong>1.1</strong> 郑州🚄武汉<br>十二月中下旬都在找实习，最后base和offer在武汉和北京纠结，一番权衡下去了武汉。当时面试这家公司那天正好是我生日，也是我🐑的第一天，也算是好事多磨。<br>提前准备入职需要的条件，在公司附近看房子租房子，定了一个离公司距离不远的房子，有了一个落脚的地方。<br><strong>1.2</strong><br>把宿舍东西搬到租的房子里，来回跑了两趟，都是体力活儿。</p><p>特别感谢comm_check和c_c的朋爹😊</p><p><strong>1.3</strong><br>入职第一天<br>大屏就是生产力，有了自己的工位，感觉不错</p><p><img src="https://user-images.githubusercontent.com/73998546/211153389-0b6d66d7-8dd3-478d-bb2a-307fa994db56.jpg">带我的chaojie哥人非常nice，为人热心讲解细致。关键是我顺口提了一嘴1.7要去深圳考托福，chaojie哥直接给我安排去深圳office工作两天。既能体会深圳office的环境，又不需要请假，还不耽误考试，一举三得。原本还想着入职第一周就请假太说不过去了，这属实是意外之喜了。<br>公司环境真的没得说，基本的设施都很齐全，关键是弹性工作制。只要工作够时间，啥时候下班都没人管。身边就有同事早上六点上班下午两点开溜，工作完成就行。之后的时间可以去游泳钓鱼划船，哇真是现充人生。在这之前我从没想过还能这么过，比我天天在家躺精彩多了。<br>下午开组会，最明显的感觉就是leader讲话英语和中文的使用频率相当，其中还夹杂着不少项目中的缩写和专有名词，听得我是一头雾水。以后对项目熟悉起来之后情况会有所好转。组会上每人会分享自己的任务进度以及讲解自己负责的部分，感觉大伙讨论的氛围很融洽。<br>晚上在公司附近溜达，因为这块是科技园区，有很多科技公司。看到HUAWEI送员工回家的大巴一辆接着一辆，少说得有二十辆，那场面真是壮观。<br><strong>1.4</strong><br>入职第二天<br>相对环境熟悉了一些，发现公司附近一家贼好吃的麻辣香锅。主要还是在熟悉和学习。<br>中午跟同事闲聊听说马上就年会了，年会好像还有抽奖活动，狠狠期待一把。<br>下午下班立马赶去机场，武汉✈深圳<br>公司距机场有六七十公里，打车去因为赶时间怕堵车特地绕了远路走四环，车费跟我武汉到郑州的高铁票一样贵了😭<br>到深圳已经十点了</p><p><img src="https://user-images.githubusercontent.com/73998546/211153549-f8ff4a2c-f85b-4785-abd0-ac7089a08d32.jpg"></p><p><strong>1.5</strong><br>上午办手续<br>下午到深圳office报道<br>第一感觉就是人好多大伙好忙地方好大。这边大伙似乎更喜欢讨论，氛围蛮好。在深圳也有华科的学长学姐，他乡遇故知吧算是。</p><p><img src="https://user-images.githubusercontent.com/73998546/211153555-cf06644d-53d2-4b01-9941-40c10936b26d.jpg"></p><p><strong>1.6</strong><br>周内最后一天工作日！<br>这边每日提供的水果很有想法，昨天小青果今日牛油果，当然还有较为常见的橘子香蕉葡萄，美滋滋。</p><p><img src="https://user-images.githubusercontent.com/73998546/211153595-82e42cda-df83-48ce-bb3f-e87f2622e89b.jpg"></p><p>下班前还收到了公司的小礼物，好像是新年礼物？）</p><p><img src="https://user-images.githubusercontent.com/73998546/211153642-c92d0bd4-b15e-41dd-bd68-847853a3bbbc.jpg"></p><p><strong>1.7</strong><br>考试考试考试😭<br>下午打卡世界之窗</p><p><img src="https://user-images.githubusercontent.com/73998546/211153716-dbbce52d-5f71-4466-adc4-2faf5b1a6807.jpg"></p><p>晚上在海边溜达</p><p><img src="https://user-images.githubusercontent.com/73998546/211153722-14e6d4f4-0fa5-43da-9e92-33948da057d7.jpg"></p><!-- (安全限制)坐在海边的石头上看🦆，🦆们咿呀咿呀游得慢悠悠。重点来了，我以为是🦆，结果过了一会其中一只受了惊，飞...飞起来了，剩下的“🦆”都一起飞起来了。大开眼界😮 --><p>还等到了一只蜥蜴，慌忙逃开）<br>从世界之窗骑到海边加之绕海岸线的距离一共有14.3公里，辛苦自己啦👏<br>哦对海边还有人玩音乐，cool guys!</p><p><video src="../img/2023-first-week/seaMusic.mp4" position= "absolute" width="100%" height="100%" controls="controls"></video></p><p><video src="../img/2023-first-week/seaMusic2.mp4" position= "absolute" width="100%" height="100%" controls="controls"></video></p><p>和闷闷约好了有机会去海边一起吃海鲜🍤喝啤酒🍺</p><p>明天就回武汉咯</p><p>我真的很喜欢这种滚烫的人生。</p>]]></content>
    
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>testing knowledge</title>
    <link href="/posts/7f101163.html"/>
    <url>/posts/7f101163.html</url>
    
    <content type="html"><![CDATA[<hr><p><strong>为什么选择测试开发</strong><br>答：首先，我认为的测开是测试和开发工作都在做的。一方面，据我了解，在近几年，国内对软件测试越来越重视，并且从用户角度来说，对于同类产品，可能会更加注重产品的质量和服务，所以我觉得测试的发展前景是非常好的。其次，测试在一个项目开发的过程中是非常重要的一环。测试人员的责任非常大，责任越大成就感就越大。我很喜欢这样的工作。另一方面，项目涉及…我很感兴趣</p><p><strong>作为测试人员，你的优势和劣势在哪儿？</strong></p><p>优势是测试思维全面，能从不同角度去测试需求，自学能力强，会编程语言python3java，劣势是，没有合适的工作环境能让我进行更多的实践和提升，缺乏真实的工程经验</p><p><img src="https://user-images.githubusercontent.com/73998546/210134863-a76da0dc-ccac-4096-ab1f-fed7e0d094fa.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134865-322494cb-5d25-47c4-b256-55e808335ab3.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134867-817211d3-5d3f-48d2-84d5-1e1c2e44a16e.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134869-72fe72e6-418c-4036-8ba2-8ef6d06c9791.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134872-8db47998-7ea7-4679-b5b7-610b15c0fb37.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134875-6745d6da-37f7-4bb9-ae31-15f63f0528d9.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134877-f744810d-4155-49f0-8026-eda38d366ac4.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134881-c85c3a9d-e469-4a0f-8d90-2fbd18ea3b99.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134883-238d9d1d-82a9-4cfd-abbb-2ebf896f01a0.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134886-dc8a14da-7da8-401b-875d-737ffe0ce832.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134888-c0384291-7b0c-4d7d-9d5c-44746630a64d.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134891-6d6919e6-95af-44ad-8fe2-abc75ac169e4.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134893-309f7167-b498-4e7d-98f4-9e1f0a16aec2.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134894-c7824ff9-387b-40fe-aeba-f421608a7141.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134895-0d77be20-00bd-4fe2-9604-af1063c0cad0.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134896-145087f6-b7f6-49cf-b099-c21ab8fe2d3a.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134897-c7b2092d-020c-4f31-a45a-85329ace0d22.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134899-5a617ba5-66b7-4d5f-b93c-ef9a79f1e218.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134900-f93f12c9-f6b5-43d9-bc14-2afeeccb42f7.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134901-ef32e2aa-1d51-46f7-b29a-80252b956922.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134902-48cdeb34-7fb4-4459-a814-3cf70270c4bb.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134903-7459bec7-c3d2-4330-acd0-9b73e5ecb0f1.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134906-5707ad55-36cc-41ec-8fd7-2bd4a9459eb4.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134908-46fa0ec7-dedc-4b18-a10f-65244bc2a342.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134909-84ae2842-704f-4dbf-97aa-75757c38cc39.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134910-888e989a-fc89-4ac2-a232-b86ce34107bb.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134911-a4d563ba-6f62-4b60-85c2-14e6a123ee6f.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134912-fee94a40-b6bc-430a-b018-c51e060a3191.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134913-0bcf5626-a6ef-44a1-8509-fbdd048fa2f0.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134916-adf2dea0-2623-48ba-b422-52084c315076.png"></p><p>特别鸣谢 <strong>@comm_check</strong></p><p><a href="https://commcheck396.github.io/2022/11/10/tester.html">以及</a></p>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>interview about java</title>
    <link href="/posts/d694644.html"/>
    <url>/posts/d694644.html</url>
    
    <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/73998546/210133299-427a0d0c-62e8-44d2-bf2d-ed8adc1797ec.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133301-f3f380a1-6679-4fe3-b022-a67c567fdac5.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133302-618506b4-d9b6-47f6-a892-a33d0d11299c.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133303-ec08964b-2757-46a1-890c-6b346d878ff4.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133304-ac891979-5038-4601-8794-64d2ae44b8d5.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133305-fea85e4e-14f2-4405-969e-e84a15b47e19.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133306-28af2df6-2c1b-485e-95ae-b5d8c6a7ea9b.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133308-f0eb881b-6190-4823-8823-7525afe6fbe1.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133309-a0ca7bea-94f0-4bd9-9450-1088cd866d2b.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133310-a76c5abe-75d7-4bb5-bf81-d19e72122f86.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133311-5490278b-986a-4389-8ab4-fcbd9aae5fb6.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133313-9abb67ad-0925-4202-9d79-395349fc329b.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133314-148f346f-0648-47b2-ae5d-93f72e532f94.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133316-fd2d9390-14cc-4782-b3f1-b77dedacfb5a.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133320-b0c8aa5d-be50-4c06-916a-a547d3c9003c.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133324-7040b485-18b1-4b28-91c6-125b1e8c0cda.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133325-8254d504-4e4d-4d8a-8f35-95498aa21557.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133334-3d0aa0f8-372b-4ead-ae6f-a060c126a1be.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133335-e4c6d09f-2dd5-404b-a293-25838faf4c0a.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133336-1e16e245-91ea-40be-993c-900b21cc12a3.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133338-4ab2901e-32c1-46c3-866a-e0c629285da3.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133340-b22749d2-899d-4e8f-8b1f-4733b9085595.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133342-d2b8d080-5dad-46ee-97e5-26fe765a59ae.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133344-45bf3d59-48b5-469e-9d38-85041d433166.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133346-9e165cf6-4e27-4d5e-ac7e-428527da4164.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133347-9532fbe8-ced6-4634-a477-1be4bfd774c0.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133348-64316e95-059f-4fc2-8246-dcd1b6fcdf02.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133349-2208cdbb-b7e6-4064-b8d3-12bb7d0c9a53.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133350-77088976-b592-48d4-9ca4-e21c145182df.png"></p><p><img src="https://user-images.githubusercontent.com/73998546/210134826-87a1247b-b3d6-4708-a5b8-950de9cfb0ef.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134827-e06cac6e-20b1-4ae3-bc7c-6f23453729d1.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134828-bdaf81a8-9343-47cc-b10d-2eb9fccadbb3.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134829-c22dcda0-5f0d-4491-b16e-ca0a737b9d21.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134830-222a075b-9baa-44d8-bae4-878ae7c0afe7.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134831-91fdce5a-a1b5-446f-a255-dfda44e60b96.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134832-06fdc83e-cacb-4db7-8f51-94cd438dfa01.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134834-6c944067-570e-4cba-b6a0-658f190f3253.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134836-990c934a-dd2f-494a-a4ce-08f33a005b7a.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134839-35c99f4a-7c67-4ce2-a80e-2f3d8ad2d57b.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134840-2f6a6de8-ab95-4195-999b-5f3942eff59a.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134842-9c41d2aa-c6ee-4868-97e7-7c03382eb031.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134843-3eba2e5c-e3b2-4d20-b2c0-58873edc8b20.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134844-ae10dcbe-ef2c-49c1-b3f2-edd802ff3ad4.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134845-c4a40d2a-11ee-4c76-bc6b-3bcb09ab04c6.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134847-c417597c-5f37-42a1-a8d1-ebab0698d291.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134849-1a04cf2a-e50c-41d7-88cc-4319913aef8a.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134851-b0d3903e-e91e-4602-876f-d5524a1f9f8c.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134853-39d399ae-96d1-4170-8507-e2497e54662a.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134855-9710039a-8e5d-4011-9977-841bf55ccd21.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134857-0d6ba1a7-6722-4422-a77a-30d93ded1fdc.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134858-0bd7e1d4-39d2-4301-9ae3-f7fa6ac126bb.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134860-13f12b5e-a370-4e69-a6f1-ccd47fd38239.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134861-9e59bc3f-691d-4161-b652-b711bacb8602.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134862-d2f22080-54d0-4f0f-afb7-7b96ff45c4dd.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134864-1d86e396-de1f-4c3c-9130-f92b06ff6c29.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134866-e5defb91-349b-4309-b10f-bee1af0fa22c.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134868-51e3c364-fbd5-47bb-9818-481653857f43.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134870-1faa2013-4b9d-48c0-bc86-ebc402cc7650.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134873-e78b11d7-869d-4662-aa2c-baf291ac1f05.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134876-17082ba5-7008-4b6c-96c1-55292df00507.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134878-29a4a7bc-1dd7-4d63-a1b8-7d5f5096bdca.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134882-743f7ab5-34d7-4be0-954f-1fdf69f283eb.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134885-72ca1186-8b7b-4485-b864-fdcd171ead4c.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134887-01e41650-33a3-4a65-97e5-18a2c849a40b.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134889-b8b38553-6935-484f-bde1-d0ad571377de.png"><br><img src="https://user-images.githubusercontent.com/73998546/210134892-aba3bab7-8825-4bac-ba23-3312e544831b.png"></p><p>特别鸣谢 <strong>@comm_check</strong></p><p><a href="https://commcheck396.github.io/2022/11/10/tester.html">以及</a></p>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Interview Preparation</title>
    <link href="/posts/60b6bee1.html"/>
    <url>/posts/60b6bee1.html</url>
    
    <content type="html"><![CDATA[<p><strong>网络中二层转发和三层转发的区别</strong></p><p>1.数据转发依靠的关键字不同，二层转发主要依靠MAC地址，而三层转发主要依靠IP地址。</p><p>2.数据交换的范围不同，二层交换指在同一网段内的通信，三层交换指跨网段的通信。</p><p>3.在三层转发的过程中，还要进行二层的封装。也就是说，在三层转发过程中二层帧头中的（源、目的）MAC地址是要改变的。但是IP数据报中的源IP和目的IP地址是不会改变的</p><p><strong>get 和post本质区别</strong></p><p>GET产生一个TCP数据包；POST产生两个TCP数据包。</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p><p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）</p><p> 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p><p>但是GET与POST都有自己的语义，不能随便混用。</p><p><img src="https://user-images.githubusercontent.com/73998546/210133222-28bdfae2-9a93-4389-9ae6-aa719443de7f.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133223-d61b2477-5395-4138-a5c7-66388fa95f09.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133224-cdc4c7bc-404b-4163-b677-a7a6dab101cc.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133226-ffb4367a-285a-4553-bea6-20e60a2020df.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133128-b3c9b1aa-8147-49d3-9ebf-998b6fdd485b.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133129-e62896fc-53c8-436d-8e78-f4c58bb1f952.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133130-815da40b-678e-4214-b428-9576b7da0006.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133133-c50eae3d-538d-4bbb-8767-eb9a6bb3369f.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133134-7c2237d9-dc95-460e-be41-25a5282227fc.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133135-f87a1de4-94e3-4fc3-80b8-9f9335b27a2d.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133136-a03ac2ad-56ec-4e91-a645-dbcf0cc6d73a.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133138-92e3557e-a64d-4065-b0bc-7647c6469de8.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133140-52a87764-d189-4fcb-b4a6-e0cf79bd43b6.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133142-b4c754ca-577e-4c14-aaab-22e5c423e71c.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133143-1169fb5b-2080-4092-9790-9bb40ca46236.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133144-ff048cac-e470-4a63-88df-fb16d0962f3b.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133146-e3b4f304-df44-47fe-8ce1-96a963dcfe74.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133147-8d132a14-efc2-484f-9452-1c681737b6b3.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133148-a7e35c3a-5585-45dd-86a7-8b9ec66896aa.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133149-a2da2ebd-6fe2-4937-aa80-2a3bfbfc02bb.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133151-f0af0d53-d291-402f-946b-e92ce5d3b20f.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133153-ddc0017b-4a83-418f-8e01-076b51c1787a.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133155-d41dbec2-4b93-4c68-a727-4d098b81562d.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133157-95c122f4-36f6-4eee-b54b-f6b26496b7fd.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133158-a572be45-4353-45b1-b939-22fc25e01ca7.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133159-ea495d99-b729-4d25-9295-4e417d341db2.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133160-867a2422-e0c2-4422-88e3-11e140f4fbb6.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133161-52be3be6-e6e6-4247-86c3-74130431cab6.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133162-ad2f2226-bb22-426b-b72e-2565109fc44c.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133165-b98c2268-d4f8-49b4-a2bf-8f8ab220cace.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133166-1bb3dd6a-941e-4f6f-b044-34b63e09ce9d.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133167-f5c6bb4d-d0ef-4e2a-badb-eee628eb3195.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133168-c600d9af-ff10-4d63-9141-153933b7beeb.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133169-f6e362d5-4793-4cc1-b074-e9509af9a6af.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133172-ed8fe076-57ea-4fb0-b799-734813b045fd.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133174-039d3e96-e8f3-40c9-9b22-ceb4698789aa.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133175-4d383e12-cef2-45aa-a62e-f059dad2ab8a.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133176-b31e9ba7-af76-4726-860e-528d8cf6471d.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133178-9436abe4-c8f4-48ed-b4fb-0e8c04e9be9e.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133180-b96214e7-9ac7-416c-98ec-8ca45005b2bf.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133182-74f7da61-390b-4330-8139-6ccec9f6a6b6.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133183-3e34e89b-7586-44df-84ab-9b10bc7346a6.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133184-ff2d5364-71c7-4520-ac2e-b66756d50a8f.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133186-d31cb2da-c120-4e5d-8d86-4b1d4a7639f4.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133187-950e6a0a-52d6-4702-b74c-308a57fe81eb.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133188-3c830bdc-f0d2-4bf9-8655-707e9f24b064.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133189-76d1cd09-dbfb-4644-9f93-77f102c0d0fd.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133190-8466baeb-095e-4c2f-a56e-127762abba88.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133191-56160d32-54bc-405f-84b3-6f373d70b61d.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133192-43bccfe8-0a5e-4af7-8e38-9824d04f1545.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133194-9a03979c-d7d3-4431-acfe-8f5b803ba321.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133195-15b46f3d-69a7-412d-93c3-c68f1ec5fd12.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133198-fe15736a-8f4f-4928-bbb9-8523bcaff82f.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133199-5f5babfc-fc9f-48d1-92b4-77927b287de4.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133201-143e87da-3dbc-4be0-932a-9f0ec1ca7e1f.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133202-e038118f-bdba-4437-8dc9-e6a2d62a79a4.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133204-7322c694-c9ac-402d-8177-eeadc5cb11fe.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133205-6d43cd67-2a2e-430a-b6f3-8a0f9f0a199c.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133206-01a2b0c4-782b-4123-9b6e-00b406589a32.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133207-9d56c55c-c9d5-4bd1-9672-7abf2c7578b2.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133208-018d03b1-c523-4fbc-89cb-6a834d53517e.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133210-aea5303d-fcf5-4ad1-8161-43fc1398d09f.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133211-1e47c73d-c2e8-4e5a-a5b8-a4e8794098f2.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133212-c264c2a3-0574-4f4d-835a-7945dc1bc825.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133213-4213b4ea-b1c0-41ed-b6ca-b9f3723cae6c.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133214-15843062-ec95-49d9-b225-09337374ff36.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133215-071f1c88-2f31-4625-a876-7de7edd729ff.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133216-e736055e-a5bd-4460-9b94-756e58b870bd.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133218-182ca05e-0f4d-462c-b516-cd517213091a.png"><br><img src="https://user-images.githubusercontent.com/73998546/210133219-d4d77f52-120d-4317-b4ef-e3b02fa1cffb.png"></p><p>上班去咯！😊</p><p>特别鸣谢 <strong>@comm_check</strong></p><p><a href="https://commcheck396.github.io/2022/11/10/tester.html">以及</a></p>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QtCreator中C++调用python的方法</title>
    <link href="/posts/cf8fcf19.html"/>
    <url>/posts/cf8fcf19.html</url>
    
    <content type="html"><![CDATA[<h2 id="QtCreator中C-调用python的方法"><a href="#QtCreator中C-调用python的方法" class="headerlink" title="QtCreator中C++调用python的方法"></a>QtCreator中C++调用python的方法</h2><blockquote><p>软工课程的界面使用QT做的，而其中核心的情感预测是python写的，模块融合的时候需要C++和python混合编程。在配置的过程中踩了不少坑，特此记录警醒后人😭</p></blockquote><h3 id="1-在qtcreator中创建-qt-application"><a href="#1-在qtcreator中创建-qt-application" class="headerlink" title="1. 在qtcreator中创建 qt application"></a>1. 在qtcreator中创建 qt application</h3><p>项目选择无所谓的，对是否成功配置没什么影响</p><p><img src="https://user-images.githubusercontent.com/73998546/200183295-909ed01a-b080-4fca-b398-b5f2b5665ae2.png"></p><h3 id="2-修改c-文件"><a href="#2-修改c-文件" class="headerlink" title="2. 修改c++文件"></a>2. 修改c++文件</h3><p>修改main.cpp文件如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;QCoreApplication&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Python.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QCoreApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br><br>    <span class="hljs-built_in">Py_Initialize</span>();<br>    <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">Py_IsInitialized</span>() )<br>    &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    PyObject* pModule = <span class="hljs-built_in">PyImport_ImportModule</span>(<span class="hljs-string">&quot;test_py&quot;</span>);  <span class="hljs-comment">// 这里的test_py就是创建的python文件</span><br>    <span class="hljs-keyword">if</span> (!pModule) &#123;<br>            cout&lt;&lt; <span class="hljs-string">&quot;Cant open python file!\n&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>   PyObject* pFunhello= <span class="hljs-built_in">PyObject_GetAttrString</span>(pModule,<span class="hljs-string">&quot;hello&quot;</span>);  <span class="hljs-comment">// 这里的hellow就是python文件定义的函数</span><br>    <span class="hljs-keyword">if</span>(!pFunhello)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;Get function hello failed&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">PyObject_CallFunction</span>(pFunhello,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">Py_Finalize</span>();<br>   <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">exec</span>();<br>&#125;<br><br><br></code></pre></div></td></tr></table></figure><h3 id="3-修改-pro文件"><a href="#3-修改-pro文件" class="headerlink" title="3. 修改.pro文件"></a>3. 修改.pro文件</h3><h6 id="pro"><a href="#pro" class="headerlink" title="pro"></a>pro</h6><p>这里有两种方式进行修改：</p><p>方法一 添加外部库进行修改</p><p>1.右键项目名称添加库</p><p><img src="https://user-images.githubusercontent.com/73998546/200183678-f22a0089-a0fa-49b3-ab05-508045349a52.png"></p><p>2.选择外部库</p><p><img src="https://user-images.githubusercontent.com/73998546/200183442-a9030c18-504f-4444-aa5a-09f4358a072d.png"></p><p>3.库文件和包含路径如图所示</p><p><img src="https://user-images.githubusercontent.com/73998546/200183758-8431c752-4b97-47b6-a7a8-71399942c432.png"></p><p>库文件是本地python文件夹下的lib文件，具体路径如图所示</p><p><img src="https://user-images.githubusercontent.com/73998546/200183933-d66b24ff-8d15-4443-90b1-db911fb906ca.png"></p><p>包含路径是这样的</p><p><img src="https://user-images.githubusercontent.com/73998546/200183943-cd65b362-2353-4c92-9e8e-17287733037e.png"></p><p>点击下一步，完成即可</p><p><img src="https://user-images.githubusercontent.com/73998546/200184028-a221b2b9-f54c-4151-8cf9-b659b27032d9.png"></p><p>此时你的.pro文件里增加了如下代码：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">win32:CONFIG(release, debug|release): LIBS += -L$<span class="hljs-variable">$PWD</span><span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>software<span class="hljs-regexp">/python3.9.15/</span>libs/ -lpython310<br><span class="hljs-keyword">else</span>:win32:CONFIG(debug, debug|release): LIBS += -L$<span class="hljs-variable">$PWD</span><span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>software<span class="hljs-regexp">/python3.9.15/</span>libs/ -lpython310d<br><br>INCLUDEPATH += $<span class="hljs-variable">$PWD</span><span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>software<span class="hljs-regexp">/python3.9.15/i</span>nclude<br>DEPENDPATH += $<span class="hljs-variable">$PWD</span><span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>software<span class="hljs-regexp">/python3.9.15/i</span>nclude<br><br>win32-g++:CONFIG(release, debug|release): PRE_TARGETDEPS += $<span class="hljs-variable">$PWD</span><span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>software<span class="hljs-regexp">/python3.9.15/</span>libs/libpython310.a<br><span class="hljs-keyword">else</span>:win32-g++:CONFIG(debug, debug|release): PRE_TARGETDEPS += $<span class="hljs-variable">$PWD</span><span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>software<span class="hljs-regexp">/python3.9.15/</span>libs/libpython310d.a<br><span class="hljs-keyword">else</span>:win32:!win32-g++:CONFIG(release, debug|release): PRE_TARGETDEPS += $<span class="hljs-variable">$PWD</span><span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>software<span class="hljs-regexp">/python3.9.15/</span>libs/python310.lib<br><span class="hljs-keyword">else</span>:win32:!win32-g++:CONFIG(debug, debug|release): PRE_TARGETDEPS += $<span class="hljs-variable">$PWD</span><span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>software<span class="hljs-regexp">/python3.9.15/</span>libs/python310d.lib<br></code></pre></div></td></tr></table></figure><p>但在这其中有些代码中涉及的库文件是本地不存在的，所以需要进行修改。只保留<strong>LIBS</strong>和<strong>INCLUDEPATH</strong>的路径，其余的注释掉。如图所示</p><p><img src="https://user-images.githubusercontent.com/73998546/200184083-54bd0925-bb4f-4e65-b62d-e95f5d5d9cc1.png"></p><p>方法二 手动添加代码</p><p>在.pro文件的最后加上：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">LIBS += -L$<span class="hljs-variable">$PWD</span><span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>software<span class="hljs-regexp">/python3.9.15/</span>libs/ -lpython310<br><br>INCLUDEPATH += $<span class="hljs-variable">$PWD</span><span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>software<span class="hljs-regexp">/python3.9.15/i</span>nclude<br></code></pre></div></td></tr></table></figure><p>注意这些路径要改为自己python的路径 </p><p>lpython310是libs文件夹下python310.dll库文件</p><p><img src="https://user-images.githubusercontent.com/73998546/200184141-a47394fe-57bd-4d53-a90a-2ec982de76e8.png"></p><h3 id="4-添加python文件"><a href="#4-添加python文件" class="headerlink" title="4. 添加python文件"></a>4. 添加python文件</h3><p>示例代码</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br>hello()<br></code></pre></div></td></tr></table></figure><h3 id="5-构建运行程序"><a href="#5-构建运行程序" class="headerlink" title="5.构建运行程序"></a>5.构建运行程序</h3><p>注意构建运行时一定要选对编译模式和对应机器的位数</p><p>（哥们选择的是64位和debug运行模式）</p><p><img src="https://user-images.githubusercontent.com/73998546/200184211-f9a17be5-442c-4f9c-97c1-56717ee4157b.png"></p><p>哥们的文件在32位gcc编译模式下就会报一堆错，切记切记！</p><p>至于选择debug还是release模式，网上参考的博客说release模式成功的可能性大。哥们两种模式都尝试了，全部构建成功。这个大伙自行斟酌。</p><p>此时程序会报一些错误，不要慌张，这些坑哥们都已经踩过了</p><p>在运行程序后，qt会自动构建debug文件夹</p><p>此时可以在项目中添加新文件，路径选择为debug文件夹，文件就是刚刚的python文件。换句话说，这一步就是将<strong>python文件放置于和exe文件相同的文件夹下</strong>。我的路径为</p><blockquote><p>D:\my_code\QTDemo\Python&amp;QT\SoftwareEngineering-NLP-Model\build-DEMO-Desktop_Qt_5_14_2_MinGW_64_bit-Debug\debug</p></blockquote><p>你以为只添加python文件就够了吗？非也非也</p><p>网上的博客通常讲到这一步就结束了，我跟到这一步后发现自己的python文件依旧跑不起来，而且报错显示的是python路径问题，长这个样子。</p><p><img src="https://user-images.githubusercontent.com/73998546/200184324-93b04493-e2f1-4ad1-9e1d-86168f2baaba.png"></p><p>仔细分析一下sys.path，发现所有路径文件中好像dll的库文件没有引入，故尝试将dll文件复制进debug文件夹，故障解决。呦吼！这些文件需要到下载的python文件夹中找。</p><p><img src="https://user-images.githubusercontent.com/73998546/200184347-778ce569-cf42-4fd9-bace-7ed4b1b3c192.png"></p><p>需要提醒一点的是，在进行上面的修改后，需要保存文件。然后需要执行<strong>qmake，构建，运行</strong>步骤。这样整个工程才会保留这些更改重新开始构建。</p><h2 id="可能遇到的问题及解决"><a href="#可能遇到的问题及解决" class="headerlink" title="可能遇到的问题及解决"></a>可能遇到的问题及解决</h2><h3 id="1-找不到python-h"><a href="#1-找不到python-h" class="headerlink" title="1. 找不到python.h"></a>1. 找不到python.h</h3><p>原因是我们在c++中使用了这个头文件，但没有添加相应的python动态链接库</p><p>解决方法：内容详情请见<a href="#pro">修改.pro文件</a></p><h3 id="2-error-C2238-意外的标记位于“-”之前"><a href="#2-error-C2238-意外的标记位于“-”之前" class="headerlink" title="2. error: C2238: 意外的标记位于“;”之前"></a>2. error: C2238: 意外的标记位于“;”之前</h3><p>原因是QT中定义了slots作为关键了，而python3中有使用slot作为变量，所以有冲突。</p><p>解决方法：在python的object.h中 slots冲突，因此修改object.h，我的object.h路径：</p><blockquote><p>D:\software\python3.9.15\include\object.h</p></blockquote><p>修改如下</p><p><img src="https://user-images.githubusercontent.com/73998546/200184529-fcdeb259-e1ce-425f-9b09-099ee566f0a1.png"></p><p><strong>3. 编译时没有错误，运行时出现“cant open python file!”</strong></p><p>可能原因</p><p>1.是生成的exe文件和test_py.py文件不在同一个文件夹里，只要手动将test_py.py拷贝到exe文件同级目录下即可。</p><p>2.前面的调用只引入了内部package的python程序是可以的，但是如果需要调用外部的package，那么就会出现无法打开py文件的情况。</p><p>如果需要引入别的一些package的话，就需要将所需要的package文件复制到QT工程目录的debug文件夹下（根据自身情况选择debug或者release），例如我的工程项目需要引入numpy，keras和tensorflow的包，如下：</p><p><img src="https://user-images.githubusercontent.com/73998546/200184585-2cc783b8-d2db-47a4-9f1c-68c918b6b477.png"></p><p>这些包来自于下载的python文件夹下，我的路径为：</p><blockquote><p>D:\software\python3.9.15\Lib\site-packages</p></blockquote><p>可以根据自己的工程需要进行添加</p><p>这玩意的配置就无限踩坑，还好最后成功啦！最后放上运行成功截图✨✨✨</p><p><img src="https://user-images.githubusercontent.com/73998546/200184611-256c330d-a253-43af-a0cb-23f5894ec4c6.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go入门与实战</title>
    <link href="/posts/4a79e44f.html"/>
    <url>/posts/4a79e44f.html</url>
    
    <content type="html"><![CDATA[<h1 id="GO-语言"><a href="#GO-语言" class="headerlink" title="GO 语言"></a>GO 语言</h1><h2 id="一、基本语法知识"><a href="#一、基本语法知识" class="headerlink" title="一、基本语法知识"></a>一、基本语法知识</h2><h3 id="1-Go语言的基本组成"><a href="#1-Go语言的基本组成" class="headerlink" title="1. Go语言的基本组成"></a>1. Go语言的基本组成</h3><p>先来看一段入门代码</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   fmt.Println(<span class="hljs-string">&quot;Hello, PP&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="1-1-包声明"><a href="#1-1-包声明" class="headerlink" title="1.1 包声明"></a>1.1 包声明</h4><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br></code></pre></div></td></tr></table></figure><p>定义了包名。通常需要在源文件第一行指明文件属于哪个包。</p><p>package main 表示一个可独立执行的程序，每个工程都应包含一个名为main的包。</p><h4 id="1-2-引入包"><a href="#1-2-引入包" class="headerlink" title="1.2 引入包"></a>1.2 引入包</h4><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br></code></pre></div></td></tr></table></figure><p>告诉编译器程序需要使用fmt包中的东东（函数、变量或其他元素）。</p><p>fmt包实现了格式化IO的函数</p><h4 id="1-3-函数"><a href="#1-3-函数" class="headerlink" title="1.3 函数"></a>1.3 函数</h4><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   fmt.Println(<span class="hljs-string">&quot;Hello, PP&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这是程序开始执行的函数。main（）函数式每一个可执行程序必须包含的，通常在程序启动后立即执行。</p><h4 id="1-4-变量"><a href="#1-4-变量" class="headerlink" title="1.4 变量"></a>1.4 变量</h4><p>变量的声明和初始化</p><p><strong>a.标准格式</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> &lt;name&gt; &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></div></td></tr></table></figure><p>var是关键字</p><p>使用 var ，虽然只指定了类型，但是 Go 会对其进行隐式初始化，比如 string 类型就初始化为空字符串，int 类型就初始化为0，float 就初始化为 0.0，bool类型就初始化为false，指针类型就初始化为 nil。</p><p>也可以在声明的同时初始化</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> num <span class="hljs-keyword">int</span> = <span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure><p>go会对右边的值进行类型判断，因此我们也可以在声明时省去类型，简写为</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> num = <span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure><p>内部变量（用在函数内部）和全局变量均适用</p><p><strong>b.同时声明多个变量</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span>(<br>    num <span class="hljs-keyword">int</span><br>    name <span class="hljs-keyword">string</span><br>    grade <span class="hljs-keyword">float32</span><br>)<br></code></pre></div></td></tr></table></figure><p>内部变量和全局变量均适用</p><p><strong>c.短类型声明法</strong></p><p>使用<code>:=</code><strong>声明</strong>变量，可以显式初始化。变量和常量通常都只能声明一次。也有例外，匿名变量可以多次声明。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">num := <span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure><p>只能用于函数内部</p><p>声明初始化多个变量</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">num, name := <span class="hljs-number">20</span>,<span class="hljs-string">&quot;weipp&quot;</span><br></code></pre></div></td></tr></table></figure><p><strong>d.声明指针变量</strong></p><p>go语言提供了new函数来声明指针变量</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-built_in">new</span>(Type)<br></code></pre></div></td></tr></table></figure><p>这将创建一个Type类型的匿名变量，初始化为Type类型的初始值（go语言默认），返回值为匿名变量地址，指针类型为<code>&amp;Type</code></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    ptr := <span class="hljs-built_in">new</span>(<span class="hljs-keyword">bool</span>)<br>    fmt.Println(<span class="hljs-string">&quot;ptr address: &quot;</span>, ptr)<br>    fmt.Println(<span class="hljs-string">&quot;ptr value: &quot;</span>, *ptr)  <span class="hljs-comment">// * 后面接指针变量，表示从内存地址中取出值</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">ptr address:  0xc000016088<br>ptr value:  false<br></code></pre></div></td></tr></table></figure><p>可以看出，用new创建指针变量和用&amp;创建指针变量能达到一样的效果，除了不需要使用具体的变量名。上面的代码用普通方法创建指针变量可以写为：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br>    <span class="hljs-keyword">var</span> boolean <span class="hljs-keyword">bool</span><br>    ptr := &amp;boolean<br>    fmt.Println(<span class="hljs-string">&quot;ptr address: &quot;</span>, ptr)<br>    fmt.Println(<span class="hljs-string">&quot;ptr value: &quot;</span>, *ptr)  <span class="hljs-comment">// * 后面接指针变量，表示从内存地址中取出值</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>匿名变量</strong></p><p>称作占位符，或者空白标识符，用下划线_表示。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。</p><p>特点：</p><p>1.不分配内存，不占用内存空间</p><p>2.可以多次声明</p><p>3.解决命名的烦恼</p><p>通常我们用匿名接收必须接收，但是又不会用到的值。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetData</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>, <span class="hljs-number">200</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    a, _ := GetData()<br>    _, b := GetData()<br>    fmt.Println(a, b)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">100 200<br></code></pre></div></td></tr></table></figure><h3 id="2-变量的作用域"><a href="#2-变量的作用域" class="headerlink" title="2.变量的作用域"></a>2.变量的作用域</h3><p>局部变量</p><p>在函数体内声明的，作用域只在函数体内。</p><p>局部变量不是一直存在的，它只在定义它的函数被调用后存在，函数调用结束后这个局部变量就会被销毁。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//声明局部变量 a 和 b 并赋值</span><br>a := <span class="hljs-number">3</span><br><span class="hljs-keyword">var</span> b <span class="hljs-keyword">int</span> = <span class="hljs-number">4</span><br><span class="hljs-comment">//声明局部变量 c 并计算 a 和 b 的和</span><br>c := a + b<br>fmt.Printf(<span class="hljs-string">&quot;a = %d, b = %d, c = %d\n&quot;</span>, a, b, c)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">a = 3, b = 4, c = 7<br></code></pre></div></td></tr></table></figure><p>全局变量</p><p>在函数体外声明的变量。全局变量的声明必须以关键字var开头，如果想要在外部包中使用全局变量的首字母必须大写。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-comment">//声明全局变量</span><br><span class="hljs-keyword">var</span> c <span class="hljs-keyword">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//声明局部变量</span><br>    <span class="hljs-keyword">var</span> a, b <span class="hljs-keyword">int</span><br>    <span class="hljs-comment">//初始化参数</span><br>    a = <span class="hljs-number">3</span><br>    b = <span class="hljs-number">4</span><br>    c = a + b<br>    fmt.Printf(<span class="hljs-string">&quot;a = %d, b = %d, c = %d\n&quot;</span>, a, b, c)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">a = <span class="hljs-number">3</span>, b = <span class="hljs-number">4</span>, c = <span class="hljs-number">7</span><br></code></pre></div></td></tr></table></figure><p>Go中全局变量和局部变量名称可以相同，但函数体内的局部变量会被优先考虑</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">//声明全局变量</span><br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">6</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//声明局部变量</span><br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">3</span><br>fmt.Printf(<span class="hljs-string">&quot;a = %d\n&quot;</span>, a)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">a = 3<br></code></pre></div></td></tr></table></figure><h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3. 数据类型"></a>3. 数据类型</h3><h4 id="3-1-布尔型"><a href="#3-1-布尔型" class="headerlink" title="3.1 布尔型"></a>3.1 布尔型</h4><p>取值只能是true或者false</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> b <span class="hljs-keyword">bool</span> = <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure><h4 id="3-2-数字类型"><a href="#3-2-数字类型" class="headerlink" title="3.2 数字类型"></a>3.2 数字类型</h4><p><strong>整型int</strong>和<strong>浮点型float32</strong>和<strong>float64</strong>，同时支持<strong>复数</strong>运算</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">//浮点数在声明的时候可以只写整数部分或者小数部分</span><br><span class="hljs-keyword">const</span> e = <span class="hljs-number">.3652</span> <span class="hljs-comment">// 0.3652 </span><br><span class="hljs-keyword">const</span> f = <span class="hljs-number">1.</span>     <span class="hljs-comment">// 1</span><br><span class="hljs-comment">//数值较大或较小可以采用科学计数法， e 或 E 来指定指数部分</span><br><span class="hljs-keyword">const</span> Avogadro = <span class="hljs-number">6.02214129e23</span>  <span class="hljs-comment">// 阿伏伽德罗常数</span><br><span class="hljs-keyword">const</span> Planck   = <span class="hljs-number">6.62606957e-34</span> <span class="hljs-comment">// 普朗克常数</span><br></code></pre></div></td></tr></table></figure><p>计算机中，复数是由两个浮点数表示的，其中一个表示实部（real），一个表示虚部（imag）。</p><p>Go语言中复数的类型有两种，分别是 complex128（64 位实数和虚数）和 complex64（32 位实数和虚数），其中 complex128 为复数的默认类型。</p><p>声明复数的语法格式</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> z <span class="hljs-keyword">complex128</span> = <span class="hljs-built_in">complex</span>(x, y)<br><span class="hljs-comment">//等价于</span><br>z := <span class="hljs-built_in">complex</span>(x, y)<br>x = <span class="hljs-built_in">real</span>(z)<span class="hljs-comment">//获取实部</span><br>y = <span class="hljs-built_in">imag</span>(z)<span class="hljs-comment">//获取虚部</span><br></code></pre></div></td></tr></table></figure><p>复数也可以用<code>==</code>和<code>!=</code>进行相等比较，只有两个复数的实部和虚部都相等的时候它们才是相等的。</p><h4 id="3-3-字符类型byte、rune及字符串类型"><a href="#3-3-字符类型byte、rune及字符串类型" class="headerlink" title="3.3 字符类型byte、rune及字符串类型"></a>3.3 字符类型byte、rune及字符串类型</h4><p>（a）byte</p><p>占用一个字节，8个bit位，表示ASCII表中的一个字符</p><p>（b）rune</p><p>占用4个字节，32个bit位，表示一个Unicode字符</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;unsafe&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a <span class="hljs-keyword">byte</span> = <span class="hljs-string">&#x27;A&#x27;</span><br>    <span class="hljs-keyword">var</span> b <span class="hljs-keyword">rune</span> = <span class="hljs-string">&#x27;B&#x27;</span><br>    fmt.Printf(<span class="hljs-string">&quot;a 占用 %d 个字节数\nb 占用 %d 个字节数&quot;</span>, unsafe.Sizeof(a), unsafe.Sizeof(b))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">a 占用 1 个字节数<br>b 占用 4 个字节数<br></code></pre></div></td></tr></table></figure><p>可以看出rune占用的字节数更多，表示的字符范围也比byte更广。</p><p>有一点需要注意，与python不同的是，Go中的单引号和双引号并不等价。单引号用来表示字符，双引号用来表示字符串，混用则会导致编译器报错。</p><p>（c）字符串</p><p>也就是string类型，它的实质就是一堆字符拼接起来的数组。</p><p>在初始化字符串时，可以用双引号<code>“”</code>或者反引号。大多情况下，二者并没有区别，但如果你的字符串中有转义字符<code>\</code> ，这里就要注意了，它们是有区别的。</p><p>使用反引号包裹的字符串，会忽略里面的转义。</p><p>比如表示 <code>\r\n</code> 这个 字符串，使用双引号是这样写的，这种叫解释型表示法</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mystr01 <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;\\r\\n&quot;</span><br></code></pre></div></td></tr></table></figure><p>而使用反引号，就方便多了，这种叫原生型表示法</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mystr02 <span class="hljs-keyword">string</span> = <span class="hljs-string">`\r\n`</span><br></code></pre></div></td></tr></table></figure><p>当你想打印解释型字符串的原型时，可以使用fmt 的 <code>%q</code> 来还原一下。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> mystr01 <span class="hljs-keyword">string</span> = <span class="hljs-string">`\r\n`</span><br>    fmt.Print(<span class="hljs-string">`\r\n`</span>)<br>    fmt.Printf(<span class="hljs-string">&quot;的解释型字符串是： %q&quot;</span>, mystr01)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出如下</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">\r\n的解释型字符串是： &quot;\\r\\n&quot;<br></code></pre></div></td></tr></table></figure><p>在反引号包裹的字符串中，无法用<code>\n</code>表示换行，那么可以直接回车进行换行</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> mystr <span class="hljs-keyword">string</span> = <span class="hljs-string">`hello</span><br><span class="hljs-string">weipp`</span><br>    fmt.Println(mystr)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">hello</span><br><span class="hljs-attribute">weipp</span><br></code></pre></div></td></tr></table></figure><h5 id="字符串的常见操作"><a href="#字符串的常见操作" class="headerlink" title="字符串的常见操作"></a>字符串的常见操作</h5><h6 id="1-拼接字符串"><a href="#1-拼接字符串" class="headerlink" title="1.拼接字符串 +"></a>1.拼接字符串 <code>+</code></h6><p>两个字符串 s1 和 s2 可以通过 s := s1 + s2 拼接在一起。将 s2 追加到 s1 尾部并生成一个新的字符串 s。</p><p>也可以使用“+=”来对字符串进行拼接：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">s := <span class="hljs-string">&quot;hel&quot;</span> + <span class="hljs-string">&quot;lo,&quot;</span><br>s += <span class="hljs-string">&quot;world!&quot;</span><br>fmt.Println(s) <span class="hljs-comment">//output “hello, world!”</span><br></code></pre></div></td></tr></table></figure><h6 id="2-字符串比较"><a href="#2-字符串比较" class="headerlink" title="2.字符串比较"></a>2.字符串比较</h6><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"> <span class="hljs-comment">// Compare 函数，用于比较两个字符串的大小，如果两个字符串相等，返回为 0。如果 a 小于 b ，返回 -1 ，反之返回 1 。不推荐使用这个函数，直接使用 == != &gt; &lt; &gt;= &lt;= 等一系列运算符更加直观。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Compare</span><span class="hljs-params">(a, b <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> <br><span class="hljs-comment">//   EqualFold 函数，计算 s 与 t 忽略字母大小写后是否相等。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">EqualFold</span><span class="hljs-params">(s, t <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span><br></code></pre></div></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">a := <span class="hljs-string">&quot;hello weipp&quot;</span><br>b := <span class="hljs-string">&quot;hello world&quot;</span><br>fmt.Println(strings.Compare(a, b)) <span class="hljs-comment">//-1</span><br>fmt.Println(strings.Compare(a, a)) <span class="hljs-comment">//0</span><br>fmt.Println(strings.Compare(b, a)) <span class="hljs-comment">//1</span><br>fmt.Println(a == b)                <span class="hljs-comment">//false</span><br>fmt.Println(a &gt;= b)                <span class="hljs-comment">//false</span><br>fmt.Println(a &lt;= b)                <span class="hljs-comment">//true 字典序比较</span><br><br>fmt.Println(strings.EqualFold(<span class="hljs-string">&quot;GO&quot;</span>, <span class="hljs-string">&quot;go&quot;</span>)) <span class="hljs-comment">//true</span><br>fmt.Println(strings.EqualFold(<span class="hljs-string">&quot;壹&quot;</span>, <span class="hljs-string">&quot;一&quot;</span>))   <span class="hljs-comment">//false</span><br></code></pre></div></td></tr></table></figure><h6 id="3-是否存在某个字符或子串"><a href="#3-是否存在某个字符或子串" class="headerlink" title="3.是否存在某个字符或子串"></a>3.是否存在某个字符或子串</h6><p>有三个函数能实现相关功能</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 子串 substr 在 s 中，返回 true</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Contains</span><span class="hljs-params">(s, substr <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-comment">// chars 中任何一个 Unicode 代码点在 s 中，返回 true</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ContainsAny</span><span class="hljs-params">(s, chars <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-comment">// Unicode 代码点 r 在 s 中，返回 true</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ContainsRune</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>, r <span class="hljs-keyword">rune</span>)</span> <span class="hljs-title">bool</span></span><br></code></pre></div></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">//1.func Contains(s, substr string) bool</span><br>fmt.Println(strings.Contains(<span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-string">&quot;ab&quot;</span>))       <span class="hljs-comment">//true</span><br><span class="hljs-comment">//2.func ContainsAny(s, chars string) bool</span><br>fmt.Println(strings.ContainsAny(<span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>))     <span class="hljs-comment">//false</span><br>fmt.Println(strings.ContainsAny(<span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-string">&quot;a &amp; c&quot;</span>)) <span class="hljs-comment">//true</span><br>fmt.Println(strings.ContainsAny(<span class="hljs-string">&quot;ab cd&quot;</span>, <span class="hljs-string">&quot;s g&quot;</span>))  <span class="hljs-comment">//true</span><br>fmt.Println(strings.ContainsAny(<span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))      <span class="hljs-comment">//false</span><br>fmt.Println(strings.ContainsAny(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))          <span class="hljs-comment">//false</span><br><span class="hljs-comment">//3.func ContainsRune(s string, r rune) bool</span><br>fmt.Println(strings.ContainsRune(<span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-string">&#x27;a&#x27;</span>))    <span class="hljs-comment">//true</span><br></code></pre></div></td></tr></table></figure><p>查看源码可以发现这些函数都是调用了Index函数，Index函数通过子串（字符）与原串的索引进行比较，返回-1，0，1三个数。将这三个数与0比较，返回true或false</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Contains reports whether substr is within s.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Contains</span><span class="hljs-params">(s, substr <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">return</span> Index(s, substr) &gt;= <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// ContainsAny reports whether any Unicode code points in chars are within s.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ContainsAny</span><span class="hljs-params">(s, chars <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">return</span> IndexAny(s, chars) &gt;= <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// ContainsRune reports whether the Unicode code point r is within s.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ContainsRune</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>, r <span class="hljs-keyword">rune</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">return</span> IndexRune(s, r) &gt;= <span class="hljs-number">0</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h6 id="4-大小写转换"><a href="#4-大小写转换" class="headerlink" title="4.大小写转换"></a>4.大小写转换</h6><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ToLower</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ToLowerSpecial</span><span class="hljs-params">(c unicode.SpecialCase, s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ToUpper</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ToUpperSpecial</span><span class="hljs-params">(c unicode.SpecialCase, s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span><br></code></pre></div></td></tr></table></figure><p>大小写转换包含了 4 个相关函数，ToLower,ToUpper 用于大小写转换。ToLowerSpecial,ToUpperSpecial 可以转换特殊字符的大小写。 请看例子：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">fmt.Println(strings.ToUpper(<span class="hljs-string">&quot;hello world&quot;</span>))<span class="hljs-comment">//HELLO WORLD</span><br>fmt.Println(strings.ToUpper(<span class="hljs-string">&quot;ā á ǎ à&quot;</span>))<span class="hljs-comment">//Ā Á Ǎ À       汉字拼音有效</span><br>fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, <span class="hljs-string">&quot;一&quot;</span>))<span class="hljs-comment">//一     汉字无效</span><br>fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, <span class="hljs-string">&quot;hello world&quot;</span>))<span class="hljs-comment">//HELLO WORLD</span><br>fmt.Println(strings.ToUpper(<span class="hljs-string">&quot;örnek iş&quot;</span>))<span class="hljs-comment">//ÖRNEK IŞ</span><br>fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, <span class="hljs-string">&quot;örnek iş&quot;</span>))<span class="hljs-comment">//ÖRNEK İŞ 有细微差别</span><br></code></pre></div></td></tr></table></figure><h4 id="3-4-派生类型"><a href="#3-4-派生类型" class="headerlink" title="3.4 派生类型"></a>3.4 派生类型</h4><h5 id="a-指针类型（Pointer）"><a href="#a-指针类型（Pointer）" class="headerlink" title="(a) 指针类型（Pointer）"></a>(a) 指针类型（Pointer）</h5><p><strong>指针声明格式</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> var_name *<span class="hljs-keyword">var</span>-<span class="hljs-keyword">type</span><br></code></pre></div></td></tr></table></figure><p>var-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。看下示例：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ip *<span class="hljs-keyword">int</span>        <span class="hljs-comment">//指向整型</span><br><span class="hljs-keyword">var</span> fp *<span class="hljs-keyword">float32</span>    <span class="hljs-comment">//指向浮点型</span><br><span class="hljs-keyword">var</span> sp *<span class="hljs-keyword">string</span><span class="hljs-comment">//指向字符串</span><br></code></pre></div></td></tr></table></figure><p><strong>指针创建</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 方法1.先定义对应的变量，再通过变量取得内存地址，创建指针</span><br>age := <span class="hljs-number">1</span><br>ptr := &amp;age<br><br><span class="hljs-comment">// 方法2.用new创建指针，之后赋值</span><br>ptr := <span class="hljs-built_in">new</span>(<span class="hljs-keyword">int</span>)<br>*ptr = <span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure><p><strong>打印指针指向的内存地址</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 第一种</span><br>fmt.Printf(<span class="hljs-string">&quot;%p&quot;</span>, ptr)<br><br><span class="hljs-comment">// 第二种</span><br>fmt.Println(ptr)<br></code></pre></div></td></tr></table></figure><p><strong>Go空指针</strong></p><p>当一个指针被定义后没有分配到任何变量时，它的值为 nil。</p><p>nil 指针也称为空指针。</p><p>nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span>  ptr1 *<span class="hljs-keyword">int</span><br>fmt.Printf(<span class="hljs-string">&quot;ptr1 的值为 : %x\n&quot;</span>, ptr1  )<br><br>ptr2 := <span class="hljs-built_in">new</span>(<span class="hljs-keyword">int</span>)<br>fmt.Printf(<span class="hljs-string">&quot;ptr2 的值为 : %x\n&quot;</span>, ptr2)<br></code></pre></div></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">ptr1 的值为 : <span class="hljs-number">0</span><br>ptr2 的值为 : c000016088<br></code></pre></div></td></tr></table></figure><p>奇怪的事情的发生了，第一种声明方式是空指针，而第二种声明方式显然不是。其实用new方法创建指针的时候，返回值是type初始值的地址，在此例中int的初始值为0，因此返回0值的地址。</p><p>可以简单验证下：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">ptr2 := <span class="hljs-built_in">new</span>(<span class="hljs-keyword">int</span>)<br>fmt.Printf(<span class="hljs-string">&quot;ptr2 的值为 : %x\n&quot;</span>, ptr2)<br><span class="hljs-comment">//ptr2 的值为 : c000016088</span><br>fmt.Printf(<span class="hljs-string">&quot;ptr2 指向的值为 : %x\n&quot;</span>, *ptr2)<br><span class="hljs-comment">//ptr2 指向的值为 : 0</span><br></code></pre></div></td></tr></table></figure><h5 id="b-数组类型"><a href="#b-数组类型" class="headerlink" title="(b) 数组类型"></a>(b) 数组类型</h5><p>数组是具有相同唯一类型的一组长度固定的数据项序列，这种类型可以是任意的原始类型例如整型、字符串或者自定义类型。</p><p><strong>数组声明格式</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> variable_name [SIZE] variable_type<br></code></pre></div></td></tr></table></figure><p>看下示例：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ages [<span class="hljs-number">10</span>] <span class="hljs-keyword">int</span><br></code></pre></div></td></tr></table></figure><p>初始化</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 方法1</span><br><span class="hljs-keyword">var</span> ages = [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><span class="hljs-comment">// 方法2</span><br>ages := [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><span class="hljs-comment">//数组长度不确定，用...替代元素个数，编译器会自行推断长度并分配空间</span><br><span class="hljs-keyword">var</span> ages = [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br>ages := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><span class="hljs-comment">//通过指定下标来初始化元素。此时数组长度必须确定。</span><br><span class="hljs-comment">//初始化索引为1，3的元素</span><br>ages := [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>:<span class="hljs-number">2</span>,<span class="hljs-number">3</span>:<span class="hljs-number">4</span>&#125;<br></code></pre></div></td></tr></table></figure><p><code>[3]int</code> 和 <code>[4]int</code> 虽然都是数组，但他们却是不同的类型，使用 fmt 的 <code>%T</code> 可以查到。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    arr01 := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>    arr02 := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>    fmt.Printf(<span class="hljs-string">&quot;%d 的类型是: %T\n&quot;</span>, arr01, arr01)<br>    fmt.Printf(<span class="hljs-string">&quot;%d 的类型是: %T&quot;</span>, arr02, arr02)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight angelscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-string">[1 2 3]</span> 的类型是: [<span class="hljs-number">3</span>]<span class="hljs-built_in">int</span><br><span class="hljs-string">[1 2 3 4]</span> 的类型是: [<span class="hljs-number">4</span>]<span class="hljs-built_in">int</span><br></code></pre></div></td></tr></table></figure><h5 id="c-切片类型（slice）"><a href="#c-切片类型（slice）" class="headerlink" title="(c) 切片类型（slice）"></a>(c) 切片类型（slice）</h5><p>Go 语言切片是对数组的抽象。</p><p>事实上切片是一种引用类型，这个片段可以是一整个数组，也可以是数组中的一段，另外，这是左闭右开的区间。</p><p>Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(“动态数组”)，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。很像python中的list。</p><p><strong>切片的声明和初始化</strong></p><p>1.对数组进行片段截取</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">myarr := [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;myarr 的长度为：%d，容量为：%d\n&quot;</span>, <span class="hljs-built_in">len</span>(myarr), <span class="hljs-built_in">cap</span>(myarr))<br><br>mysli1 := myarr[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br>fmt.Printf(<span class="hljs-string">&quot;mysli1 的长度为：%d，容量为：%d\n&quot;</span>, <span class="hljs-built_in">len</span>(mysli1), <span class="hljs-built_in">cap</span>(mysli1))<br>fmt.Println(mysli1)<br><br>mysli2 := myarr[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>:<span class="hljs-number">4</span>]<br>fmt.Printf(<span class="hljs-string">&quot;mysli2 的长度为：%d，容量为：%d\n&quot;</span>, <span class="hljs-built_in">len</span>(mysli2), <span class="hljs-built_in">cap</span>(mysli2))<br>fmt.Println(mysli2)<br></code></pre></div></td></tr></table></figure><p>输出 说明切片的第三个数，影响的只是切片的容量，而不会影响长度</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">myarr 的长度为：5，容量为：5<br>mysli1 的长度为：2，容量为：4<br>[2 3]<br>mysli2 的长度为：2，容量为：3<br>[2 3]<br></code></pre></div></td></tr></table></figure><p>可以发现mysli1和mysli2的打印结果是一样的。那<code>mysli1 := myarr[1:3]</code>和<code>mysli2 := myarr[1:3:4]</code>的区别在哪呢</p><p>在切片时，若不指定第三个数，那么切片终止索引会一直到原数组的最后一个数。而如果指定了第三个数，那么切片终止索引只会到原数组的该索引值。</p><p>好绕是不是，举个例子，<code>mysil := myarr[x:y:z]</code>意思是我将myarr[x,z）的所有值给切片mysil，切片mysil的容量大小为（z-x）。但我打印mysil时，只打印myarr[x,y)，切片mysil的长度大小为（y-x）。</p><p>代码验证一下</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> numbers4 = [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;<br>myslice := numbers4[<span class="hljs-number">4</span>:<span class="hljs-number">6</span>:<span class="hljs-number">8</span>]<br>fmt.Printf(<span class="hljs-string">&quot;myslice为 %d,其容量为：%d,其长度为: %d\n&quot;</span>, myslice, <span class="hljs-built_in">cap</span>(myslice), <span class="hljs-built_in">len</span>(myslice))<br>myslice = myslice[:<span class="hljs-built_in">cap</span>(myslice)]<br>fmt.Printf(<span class="hljs-string">&quot;myslice的第四个元素为: %d&quot;</span>, myslice[<span class="hljs-number">3</span>])<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight ldif"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ldif"><span class="hljs-attribute">myslice为 [5 6],其容量为：4,其长度为</span>: 2<br><span class="hljs-attribute">myslice的第四个元素为</span>: 8<br></code></pre></div></td></tr></table></figure><p>2.仅声明</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 声明字符串切片</span><br><span class="hljs-keyword">var</span> strList []<span class="hljs-keyword">string</span><br><br><span class="hljs-comment">// 声明整型切片</span><br><span class="hljs-keyword">var</span> numList []<span class="hljs-keyword">int</span><br><br><span class="hljs-comment">// 声明一个空切片</span><br><span class="hljs-keyword">var</span> numListEmpty = []<span class="hljs-keyword">int</span>&#123;&#125;<br></code></pre></div></td></tr></table></figure><p>3.make函数构造</p><p><code>make( []Type, size, cap )</code></p><p>我们只需要提供切片所需的三个要素，类型type，长度size和容量cap。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">a := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">2</span>)<br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>)<br>fmt.Println(a, b)<span class="hljs-comment">//[0 0] [0 0]</span><br>fmt.Println(<span class="hljs-built_in">len</span>(a), <span class="hljs-built_in">len</span>(b))<span class="hljs-comment">//2 2</span><br>fmt.Println(<span class="hljs-built_in">cap</span>(a), <span class="hljs-built_in">cap</span>(b))<span class="hljs-comment">//2 10</span><br></code></pre></div></td></tr></table></figure><p>4.用<code>:=</code>直接声明</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">a := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">4</span>:<span class="hljs-number">2</span>&#125;<br>fmt.Println(a)<span class="hljs-comment">//[0 0 0 0 2]</span><br>fmt.Println(<span class="hljs-built_in">len</span>(a), <span class="hljs-built_in">cap</span>(a))<span class="hljs-comment">//5 5</span><br></code></pre></div></td></tr></table></figure><p>注意在声明时数组和切片的区别：</p><p>数组一定要指明长度，如果没有确切数字也必须要写上<code>...</code></p><p><code>arr := [5]int&#123;1,2,3,4,5&#125;</code></p><p><code>arr := [...]int&#123;1,2,3,4,5&#125;</code></p><p>切片长度不固定，不需要指明长度</p><p><code>sli := []int&#123;1,2,3,4,5&#125;</code></p><p>由于切片是引用类型，所以你不对它进行赋值的话，它的零值（默认值）是 nil</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> myarr []<span class="hljs-keyword">int</span><br>fmt.Println(myarr == <span class="hljs-literal">nil</span>)<br><span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure><p>数组和切片都是可以容纳若干类型相同的元素的容器。</p><p>不同点在于，数组容器大小固定，而切片作为引用类型，大小不固定，可以在里面随意添加删除元素。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">    myarr := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>&#125;<br>    <span class="hljs-comment">// 追加一个元素</span><br>    myarr = <span class="hljs-built_in">append</span>(myarr, <span class="hljs-number">2</span>)<br>    <span class="hljs-comment">// 追加多个元素</span><br>    myarr = <span class="hljs-built_in">append</span>(myarr, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>    <span class="hljs-comment">// 追加一个切片, ... 表示解包，不能省略</span><br>    myarr = <span class="hljs-built_in">append</span>(myarr, []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;...)<br>    <span class="hljs-comment">// 在第一个位置插入元素</span><br>    myarr = <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>&#125;, myarr...)<br>    <span class="hljs-comment">// 在中间插入一个切片(两个元素)</span><br>    myarr = <span class="hljs-built_in">append</span>(myarr[:<span class="hljs-number">5</span>], <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;, myarr[<span class="hljs-number">5</span>:]...)...)<br>    fmt.Println(myarr)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出 如下</p><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap">[0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>4<span class="hljs-number"> 5 </span>6<span class="hljs-number"> 7 </span>8]<br></code></pre></div></td></tr></table></figure><h5 id="d-Channel-类型"><a href="#d-Channel-类型" class="headerlink" title="(d) Channel 类型"></a>(d) Channel 类型</h5><p>它是一个数据管道，可以往里面写数据，从里面读数据。</p><p>channel 遵循先进先出原则。</p><p>写入，读出数据都会加锁,因此线程是安全的。</p><p><strong>channel 可以分为 3 种类型：</strong></p><ul><li>只读 channel，单向 channel</li><li>只写 channel，单向 channel</li><li>可读可写 channel</li></ul><p><strong>channel 还可按是否带有缓冲区分为：</strong></p><ul><li>带缓冲区的 channel，定义了缓冲区大小，可以存储多个数据</li><li>不带缓冲区的 channel，只能存一个数据，并且只有当该数据被取出才能存下一个数据</li></ul><p><strong>声明和初始化</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 只读 channel</span><br><span class="hljs-keyword">var</span> readOnlyChan &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>  <span class="hljs-comment">// channel 的类型为 int</span><br><br><span class="hljs-comment">// 只写 channel</span><br><span class="hljs-keyword">var</span> writeOnlyChan <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int</span><br><br><span class="hljs-comment">// 可读可写</span><br><span class="hljs-keyword">var</span> ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span><br><br><span class="hljs-comment">// 或者使用 make 直接初始化</span><br>readOnlyChan1 := <span class="hljs-built_in">make</span>(&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">// 只读且带缓存区的 channel</span><br>readOnlyChan2 := <span class="hljs-built_in">make</span>(&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)   <span class="hljs-comment">// 只读且不带缓存区 channel</span><br><br>writeOnlyChan3 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// 只写且带缓存区 channel</span><br>writeOnlyChan4 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int</span>) <span class="hljs-comment">// 只写且不带缓存区 channel</span><br><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>)  <span class="hljs-comment">// 可读可写且带缓存区</span><br><br>ch &lt;- <span class="hljs-number">20</span>  <span class="hljs-comment">// 写数据</span><br>i := &lt;-ch  <span class="hljs-comment">// 读数据</span><br>i, ok := &lt;-ch  <span class="hljs-comment">// 还可以判断读取的数据</span><br></code></pre></div></td></tr></table></figure><p><strong>基本操作方式</strong></p><ul><li><p>读 &lt;-ch</p><p><code>i := &lt;-ch</code></p></li><li><p>写 ch&lt;-</p><p><code>ch &lt;- 20</code></p></li><li><p>关闭 close(ch)</p><p><code>close(ch)</code></p></li></ul><p><strong>带缓冲和不带缓冲的 channel</strong></p><p><strong>不带缓冲区 channel</strong></p><p>看个例子吧</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>) <span class="hljs-comment">// 无缓冲的channel</span><br>    <span class="hljs-keyword">go</span> unbufferChan(ch)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        fmt.Println(<span class="hljs-string">&quot;receive &quot;</span>, &lt;-ch) <span class="hljs-comment">// 读出值</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">unbufferChan</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        fmt.Println(<span class="hljs-string">&quot;send &quot;</span>, i)<br>        ch &lt;- i <span class="hljs-comment">// 写入值</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">send  <span class="hljs-number">0</span><br>send  <span class="hljs-number">1</span><br>receive  <span class="hljs-number">0</span><br>receive  <span class="hljs-number">1</span><br>send  <span class="hljs-number">2</span><br>send  <span class="hljs-number">3</span><br>receive  <span class="hljs-number">2</span><br>receive  <span class="hljs-number">3</span><br>send  <span class="hljs-number">4</span><br>send  <span class="hljs-number">5</span><br>receive  <span class="hljs-number">4</span><br>receive  <span class="hljs-number">5</span><br>send  <span class="hljs-number">6</span><br>send  <span class="hljs-number">7</span><br>receive  <span class="hljs-number">6</span><br>receive  <span class="hljs-number">7</span><br>send  <span class="hljs-number">8</span><br>send  <span class="hljs-number">9</span><br>receive  <span class="hljs-number">8</span><br>receive  <span class="hljs-number">9</span><br></code></pre></div></td></tr></table></figure><p>对于不带缓冲区的channel，只能存一个数据。当读入一个数据后，会加锁，当这个数据被读出时，才会解锁。一个数据的读入和读出一一对应，线程是安全的。那么输出结果为什么是两个send两个receive呢？</p><p>我画了一张图讲下我的理解：</p><p><img src="https://user-images.githubusercontent.com/73998546/185968696-29c51f2e-bf5e-4568-ac51-a839e4b7d277.png"></p><p>首先运行线程1：打印出send 0，将0送入channel，此时lock，之后打印出send 1。再往下无法继续读入，需要读出数据，因此切换至线程2：读出0，打印receive 0。这里解释下为什么线程2读出0后没有直接切换到线程1读入1：因为线程切换需要时间，在准备切换时，已经接到了打印receive 0的命令，此时先打印receive 0，之后再切换到线程1。线程1：将1送入channel，此时函数在改变for循环变量i，这段时间线程2抢到进程。线程2：读出1，打印receive 1。</p><p><strong>带缓冲区 channel</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">3</span>)<br>ch &lt;- <span class="hljs-string">&quot;tom&quot;</span><br>ch &lt;- <span class="hljs-string">&quot;jimmy&quot;</span><br>ch &lt;- <span class="hljs-string">&quot;cate&quot;</span><br><br>fmt.Println(&lt;-ch)<br>fmt.Println(&lt;-ch)<br>fmt.Println(&lt;-ch)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">tom<br>jimmy<br>cate<br></code></pre></div></td></tr></table></figure><p><strong>判断 channel 是否关闭</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">v, ok := &lt;-ch<br></code></pre></div></td></tr></table></figure><p>ok 为 true，读到数据，管道没有关闭</p><p>ok 为 false，管道已关闭，没有数据可读</p><p>浅浅试一下：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><span class="hljs-keyword">go</span> test(ch)<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">if</span> v, ok := &lt;-ch; ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;get val: &quot;</span>, v, ok)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>ch &lt;- i<br>&#125;<br><span class="hljs-built_in">close</span>(ch)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">get val:  0 true<br>get val:  1 true<br>get val:  2 true<br>get val:  3 true<br>get val:  4 true<br></code></pre></div></td></tr></table></figure><p>读已经关闭的 channel 会读到零值，如果不确定 channel 是否关闭，可以用这种方法来检测。</p><p><strong>遍历channel</strong></p><p>通常用<code>for range</code>遍历channel，，如果发送者没有关闭 channel 或在 range 之后关闭，都会导致 deadlock(死锁)。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>ch &lt;- i<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">for</span> val := <span class="hljs-keyword">range</span> ch &#123;<br>fmt.Println(val)<br>&#125;<br><span class="hljs-built_in">close</span>(ch) <span class="hljs-comment">// 这里关闭channel已经”通知“不到range了，会触发死锁。</span><br>              <span class="hljs-comment">// 不管这里是否关闭channel，都会报死锁，close(ch)的位置就不对。</span><br>              <span class="hljs-comment">// 且关闭channel的操作者也错了，只能是发送者关闭channel</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br><span class="hljs-number">6</span><br><span class="hljs-number">7</span><br><span class="hljs-number">8</span><br><span class="hljs-number">9</span><br>fatal error: <span class="hljs-keyword">all</span> goroutines <span class="hljs-keyword">are</span> asleep <span class="hljs-operator">-</span> deadlock<span class="hljs-operator">!</span><br></code></pre></div></td></tr></table></figure><p>把 <code>close(ch)</code> 移到 <code>go func()&#123;&#125;()</code> 里进行修改，像这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        ch &lt;- i<br>    &#125;<br>    <span class="hljs-built_in">close</span>(ch)<br>&#125;()<br></code></pre></div></td></tr></table></figure><p><strong>select 使用</strong></p><p>Go中的select和channel配合使用，通过select可以监听多个channel的I/O读写事件，当 IO操作发生时，触发相应的动作。</p><p>基本用法：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">//select基本用法</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;- chan1:<br><span class="hljs-comment">// 如果chan1成功读到数据，则进行该case处理语句</span><br><span class="hljs-keyword">case</span> chan2 &lt;- <span class="hljs-number">1</span>:<br><span class="hljs-comment">// 如果成功向chan2写入数据，则进行该case处理语句</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// 如果上面都没有成功，则进入default处理流程</span><br></code></pre></div></td></tr></table></figure><p>看个例子</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// https://go.dev/tour/concurrency/5</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(ch, quit <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br>x, y := <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> ch &lt;- x:<br>x, y = y, x+y<br><span class="hljs-keyword">case</span> &lt;-quit:<br>fmt.Println(<span class="hljs-string">&quot;quit&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>quit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Println(&lt;-ch)<br>&#125;<br>quit &lt;- <span class="hljs-number">0</span><br>&#125;()<br><br>fibonacci(ch, quit)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">0<br>1   <br>1   <br>2   <br>3   <br>5   <br>8   <br>13  <br>21  <br>34  <br>quit<br></code></pre></div></td></tr></table></figure><h5 id="e-函数类型"><a href="#e-函数类型" class="headerlink" title="(e) 函数类型"></a>(e) 函数类型</h5><p>函数是基本的代码块，负责执行不同的功能。</p><p>Go 语言至少需要有个 main() 函数。</p><p>函数声明告诉了编译器函数的名称，返回类型，和参数</p><p>函数定义</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function_name</span><span class="hljs-params">( [parameter list] )</span> [<span class="hljs-title">return_types</span>]</span> &#123;<br>   函数体<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>func：函数由 func 开始声明</li><li>function_name：函数名称，参数列表和返回值类型构成了函数签名。</li><li>parameter list：参数列表</li><li>return_types：返回类型，函数返回一列值。</li><li>函数体：函数定义的代码集合。</li></ul><p>函数调用实例</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">/* 定义局部变量 */</span><br>   <span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">100</span><br>   <span class="hljs-keyword">var</span> b <span class="hljs-keyword">int</span> = <span class="hljs-number">200</span><br>   <span class="hljs-keyword">var</span> ret <span class="hljs-keyword">int</span><br><br>   <span class="hljs-comment">/* 调用函数并返回最大值 */</span><br>   ret = max(a, b)<br><br>   fmt.Printf( <span class="hljs-string">&quot;最大值是 : %d\n&quot;</span>, ret )<br>&#125;<br><br><span class="hljs-comment">/* 函数返回两个数的最大值 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(num1, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>   <span class="hljs-comment">/* 定义局部变量 */</span><br>   <span class="hljs-keyword">var</span> result <span class="hljs-keyword">int</span><br><br>   <span class="hljs-keyword">if</span> (num1 &gt; num2) &#123;<br>      result = num1<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      result = num2<br>   &#125;<br>   <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">最大值是 : 200<br></code></pre></div></td></tr></table></figure><p><strong>值传递&amp;引用传递</strong></p><p>值传递：值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p><p>引用传递：引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p><h5 id="f-结构化类型-struct"><a href="#f-结构化类型-struct" class="headerlink" title="(f) 结构化类型(struct)"></a>(f) 结构化类型(struct)</h5><p>在结构体中我们可以为不同项定义不同的数据类型。</p><p><strong>定义结构体</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> struct_variable_type <span class="hljs-keyword">struct</span> &#123;<br>   member1 definition1<br>   member2 definition2<br>   ...<br>   memberX definitionX<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>结构体变量声明</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">variable_name := structure_variable_type &#123;value1, value2...valuen&#125;<br><span class="hljs-comment">//或</span><br>variable_name := structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125;<br></code></pre></div></td></tr></table></figure><p>看个例子</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Blogs <span class="hljs-keyword">struct</span> &#123;<br>title  <span class="hljs-keyword">string</span><br>author <span class="hljs-keyword">string</span><br>date   <span class="hljs-keyword">string</span><br>id     <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 创建一个新的结构体</span><br>fmt.Println(Blogs&#123;<span class="hljs-string">&quot;Go入门与实战&quot;</span>, <span class="hljs-string">&quot;weipp&quot;</span>, <span class="hljs-string">&quot;23/8/2022&quot;</span>, <span class="hljs-number">429761</span>&#125;)<br><span class="hljs-comment">// 也可以使用 key =&gt; value 格式</span><br>fmt.Println(Blogs&#123;title: <span class="hljs-string">&quot;Go入门与实战&quot;</span>, author: <span class="hljs-string">&quot;weipp&quot;</span>, date: <span class="hljs-string">&quot;23/8/2022&quot;</span>, id: <span class="hljs-number">429761</span>&#125;)<br><span class="hljs-comment">//忽略的字段为0或空</span><br>fmt.Println(Blogs&#123;title: <span class="hljs-string">&quot;Go入门与实战&quot;</span>, author: <span class="hljs-string">&quot;weipp&quot;</span>&#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">&#123;Go入门与实战 weipp <span class="hljs-number">23</span><span class="hljs-regexp">/8/</span><span class="hljs-number">2022</span> <span class="hljs-number">429761</span>&#125;<br>&#123;Go入门与实战 weipp <span class="hljs-number">23</span><span class="hljs-regexp">/8/</span><span class="hljs-number">2022</span> <span class="hljs-number">429761</span>&#125;<br>&#123;Go入门与实战 weipp  <span class="hljs-number">0</span>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>访问结构体成员</strong></p><ul><li>结构体.成员名</li></ul><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> blog1 Blogs<br>blog1.title = <span class="hljs-string">&quot;Go入门与实战&quot;</span><br>blog1.author = <span class="hljs-string">&quot;weipp&quot;</span><br></code></pre></div></td></tr></table></figure><ul><li>结构体指针.成员名</li></ul><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> blog2_ptr *Blogs<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">var</span> blog2 Blogs<br>blog2_ptr := &amp;blog2<br><br>blog2_ptr.title = <span class="hljs-string">&quot;Go入门与实战&quot;</span><br>blog2_ptr.author = <span class="hljs-string">&quot;weipp&quot;</span><br></code></pre></div></td></tr></table></figure><h5 id="g-接口类型（interface）"><a href="#g-接口类型（interface）" class="headerlink" title="(g) 接口类型（interface）"></a>(g) 接口类型（interface）</h5><p>接口把所有的具有共性的方法定义在一起，其他函数想要使用这些方法时调用接口即可。降低代码的耦合性。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">/* 定义接口 */</span><br><span class="hljs-keyword">type</span> interface_name <span class="hljs-keyword">interface</span> &#123;<br>   method_name1 [return_type]<br>   method_name2 [return_type]<br>   method_name3 [return_type]<br>   ...<br>   method_namen [return_type]<br>&#125;<br><span class="hljs-comment">/* 实现接口方法 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(struct_name_variable struct_name)</span> <span class="hljs-title">method_name1</span><span class="hljs-params">()</span> [<span class="hljs-title">return_type</span>]</span> &#123;<br>   <span class="hljs-comment">/* 方法实现 */</span><br>&#125;<br>...<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(struct_name_variable struct_name)</span> <span class="hljs-title">method_namen</span><span class="hljs-params">()</span> [<span class="hljs-title">return_type</span>]</span> &#123;<br>   <span class="hljs-comment">/* 方法实现*/</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>示例</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Phone <span class="hljs-keyword">interface</span> &#123;<br>    call()<br>&#125;<br><br><span class="hljs-keyword">type</span> NokiaPhone <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(nokiaPhone NokiaPhone)</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;I am Nokia, I can call you!&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> IPhone <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(iPhone IPhone)</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;I am iPhone, I can call you!&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> phone Phone<br><br>    phone = <span class="hljs-built_in">new</span>(NokiaPhone)<br>    phone.call()<br><br>    phone = <span class="hljs-built_in">new</span>(IPhone)<br>    phone.call()<br><br>&#125;<br><span class="hljs-comment">//我们定义了一个接口Phone，接口里面有一个方法call()。然后我们在main函数里面定义了一个Phone类型变量，并分别为之赋值为NokiaPhone和IPhone。然后调用call()方法</span><br></code></pre></div></td></tr></table></figure><p>输出结果：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">I</span> am Nokia, <span class="hljs-selector-tag">I</span> can call you!<br><span class="hljs-selector-tag">I</span> am iPhone, <span class="hljs-selector-tag">I</span> can call you!<br></code></pre></div></td></tr></table></figure><h5 id="h-Map-类型"><a href="#h-Map-类型" class="headerlink" title="(h) Map 类型"></a>(h) Map 类型</h5><ul><li>map是无序的键值对集合，很像python中的字典，是key-value结构。因为是map是用hash表实现的，所以每次打印出来的map都不一样，而且只能通过key获取。</li><li>map是一种引用类型，长度不固定，和slice一样</li><li>map的值可以通过重新赋值直接修改</li></ul><p><strong>声明和初始化</strong></p><p>声明格式</p><p><code>var mapName map[key] value</code></p><p>key为键类型，value为值类型</p><p>其中value既可以是基本数据类型，也可以为自定义数据类型</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">//值类型为int</span><br><span class="hljs-keyword">var</span> numbers <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>] <span class="hljs-keyword">int</span><br><span class="hljs-comment">//自定义数据类型</span><br><span class="hljs-keyword">var</span> myMap <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>] personInfo<br><span class="hljs-keyword">type</span> personInfo <span class="hljs-keyword">struct</span> &#123;<br>    ID <span class="hljs-keyword">string</span><br>    Name <span class="hljs-keyword">string</span><br>    Address <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>初始化</p><ol><li> <code>:=</code>直接创建</li></ol><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">rating := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>] <span class="hljs-keyword">float32</span> &#123;<span class="hljs-string">&quot;C&quot;</span>:<span class="hljs-number">5</span>, <span class="hljs-string">&quot;Go&quot;</span>:<span class="hljs-number">4.5</span>, <span class="hljs-string">&quot;Python&quot;</span>:<span class="hljs-number">4.5</span>, <span class="hljs-string">&quot;C++&quot;</span>:<span class="hljs-number">2</span> &#125;<br>myMap := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>] personInfo&#123;<span class="hljs-string">&quot;1234&quot;</span>: personInfo&#123;<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-string">&quot;Room 101,...&quot;</span>&#125;,&#125;<br></code></pre></div></td></tr></table></figure><ol start="2"><li><p>make方法构造map</p><p><code>mapName := make(map[key] value)</code></p></li></ol><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">numbers := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>] <span class="hljs-keyword">int</span>)<br>numbers[<span class="hljs-string">&quot;one&quot;</span>] = <span class="hljs-number">1</span> <br></code></pre></div></td></tr></table></figure><p><strong>元素查找</strong></p><p>这里的查找功能很巧妙，不需要像别的语言那样检查取到的值是否为空，而是返回两个参数。判断第二个参数<code>ok</code>的值0/1即可。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">value, ok := numbers[<span class="hljs-string">&quot;one&quot;</span>]<br><span class="hljs-keyword">if</span> ok&#123;<br>    <span class="hljs-comment">//处理找到的value</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>元素修改</strong></p><p>非常简单，定位需要修改的key-value对，直接改变value即可</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">numbers[<span class="hljs-string">&quot;one&quot;</span>] = <span class="hljs-number">11</span><br></code></pre></div></td></tr></table></figure><p>注意：map是引用类型，如果两个map同时指向一个对象，那么一个改变,另一个也相应改变。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">numbersTest := numbers<br>numbersTest[<span class="hljs-string">&quot;one&quot;</span>] = <span class="hljs-string">&quot;111&quot;</span><br><span class="hljs-comment">//此时numbers[&quot;one&quot;]的值变为&quot;111&quot;了。</span><br></code></pre></div></td></tr></table></figure><p><strong>元素删除</strong></p><p>可以使用Go的内置函数delete（），用于删除容器内的元素。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">//delete(map,key)</span><br><span class="hljs-built_in">delete</span>(number, <span class="hljs-string">&quot;one&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>上面的代码将从myMap中删除键为“one”的键值对。如果“one”这个键不存在，那么这个调用将什么都不发生，也不会有什么副作用。但是如果传入的map变量的值是nil，该调用将导致程序抛出异常（panic）。</p><p>示例</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Blogs <span class="hljs-keyword">struct</span> &#123;<br>title  <span class="hljs-keyword">string</span><br>author <span class="hljs-keyword">string</span><br>date   <span class="hljs-keyword">string</span><br>id     <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   //声明一个map变量numbers,键名为string,值为int</span><br><span class="hljs-comment">   var numbers map[string] int</span><br><span class="hljs-comment">   //给map变量创建值,同时指定最多可以存储3个int值</span><br><span class="hljs-comment">   numbers = make(map[string] int, 3)</span><br><span class="hljs-comment">   //map元素赋值</span><br><span class="hljs-comment">   numbers[&quot;one&quot;] = 1</span><br><span class="hljs-comment">   numbers[&quot;two&quot;] = 2</span><br><span class="hljs-comment">   numbers[&quot;three&quot;] = 3</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//上面方式的简写方法</span><br>numbers := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>&#123;<br><span class="hljs-string">&quot;one&quot;</span>:   <span class="hljs-number">1</span>,<br><span class="hljs-string">&quot;two&quot;</span>:   <span class="hljs-number">2</span>,<br><span class="hljs-string">&quot;three&quot;</span>: <span class="hljs-number">3</span>,<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">var myBlogs map[string] Blogs</span><br><span class="hljs-comment">myBlogs = make(map[string] Blogs)</span><br><span class="hljs-comment">myBlogs[&quot;blog1&quot;] = Blogs&#123;&quot;Day1&quot;,&quot;weipp&quot;,&quot;25/8&quot;,001&#125;</span><br><span class="hljs-comment">myBlogs[&quot;blog2&quot;] = Blogs&#123;&quot;Day2&quot;,&quot;weipp&quot;,&quot;26/8&quot;,002&#125;</span><br><span class="hljs-comment">myBlogs[&quot;blog2&quot;] = Blogs&#123;&quot;Day3&quot;,&quot;weipp&quot;,&quot;27/8&quot;,003&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//上面方式的简写方法</span><br>myBlogs := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]Blogs&#123;<br><span class="hljs-string">&quot;blog1&quot;</span>: &#123;<span class="hljs-string">&quot;Day1&quot;</span>, <span class="hljs-string">&quot;weipp&quot;</span>, <span class="hljs-string">&quot;25/8&quot;</span>, <span class="hljs-number">001</span>&#125;,<br><span class="hljs-string">&quot;blog2&quot;</span>: &#123;<span class="hljs-string">&quot;Day2&quot;</span>, <span class="hljs-string">&quot;weipp&quot;</span>, <span class="hljs-string">&quot;26/8&quot;</span>, <span class="hljs-number">002</span>&#125;,<br><span class="hljs-string">&quot;blog3&quot;</span>: &#123;<span class="hljs-string">&quot;Day3&quot;</span>, <span class="hljs-string">&quot;weipp&quot;</span>, <span class="hljs-string">&quot;27/8&quot;</span>, <span class="hljs-number">003</span>&#125;,<br>&#125;<br><br><span class="hljs-comment">//元素打印</span><br>fmt.Println(numbers)<br>fmt.Println(numbers[<span class="hljs-string">&quot;two&quot;</span>])<br>fmt.Println(myBlogs)<br>fmt.Println(myBlogs[<span class="hljs-string">&quot;blog1&quot;</span>])<br><br><span class="hljs-comment">//元素查找</span><br>_, ok := myBlogs[<span class="hljs-string">&quot;blog&quot;</span>]<br><span class="hljs-keyword">if</span> ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;Found&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Not found&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//元素删除</span><br><span class="hljs-built_in">delete</span>(numbers, <span class="hljs-string">&quot;one&quot;</span>)<br>fmt.Println(numbers)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight dust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dust"><span class="xml">map[one:1 three:3 two:2]</span><br><span class="xml">2</span><br><span class="xml">map[blog1:</span><span class="hljs-template-variable">&#123;Day1 weipp 25/8 1&#125;</span><span class="xml"> blog2:</span><span class="hljs-template-variable">&#123;Day2 weipp 26/8 2&#125;</span><span class="xml"> blog3:</span><span class="hljs-template-variable">&#123;Day3 weipp 27/8 3&#125;</span><span class="xml">]</span><br><span class="xml"></span><span class="hljs-template-variable">&#123;Day1 weipp 25/8 1&#125;</span><span class="xml"></span><br><span class="xml">Not found</span><br><span class="xml">map[three:3 two:2]</span><br></code></pre></div></td></tr></table></figure><h3 id="4-循环控制"><a href="#4-循环控制" class="headerlink" title="4.循环控制"></a>4.循环控制</h3><h4 id="4-1条件语句"><a href="#4-1条件语句" class="headerlink" title="4.1条件语句"></a>4.1条件语句</h4><h5 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h5><p>基本格式</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">if</span> 条件 <span class="hljs-number">1</span> &#123;<br>  分支 <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> 条件 <span class="hljs-number">2</span> &#123;<br>  分支 <span class="hljs-number">2</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> 条件 ... &#123;<br>  分支 ...<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  分支 <span class="hljs-keyword">else</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>Go的编译器，对于<code>&#123;</code>和<code>&#125;</code>的位置要求十分严格，在编写代码的时候，<code>else if</code>或<code>else</code>和两边的花括号，必须在同一行，否则编译器报错。</p><p>另外需要注意的是，<code>if</code>后面的条件表达式必须严格返回布尔型的数据（0/1/nil均不行）</p><p>进阶用法</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">if</span> 表达式 ; 条件 <span class="hljs-number">1</span> &#123;<br>  分支 <span class="hljs-number">1</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以先运行一个表达式，再对条件进行判断（<del>这样看起来是不是牛逼点</del>）</p><p>例如</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> year := <span class="hljs-number">2020</span>;year &gt;= <span class="hljs-number">2000</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;现在进入二十一世纪&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h5><p>基本格式</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> var0 &#123;<br>    <span class="hljs-keyword">case</span> val1:<br>        ...<br>    <span class="hljs-keyword">case</span> val2:<br>        ...<br>    <span class="hljs-keyword">default</span>:<br>        ...<br>&#125;<br><span class="hljs-comment">//变量 var 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。</span><br><span class="hljs-comment">//还可以同时测试多个可能的值，使用逗号分隔</span><br><span class="hljs-keyword">switch</span> var0 &#123;<br>    <span class="hljs-keyword">case</span> val1,var2,var3:<br>        ...<br>    <span class="hljs-keyword">case</span> val4:<br>        ...<br>    <span class="hljs-keyword">default</span>:<br>        ...<br>&#125;<br></code></pre></div></td></tr></table></figure><p>switch语句从上到下执行，直到找到匹配。</p><p>默认情况下每个case最后都自带break，匹配成功后即跳出循环，不会向下执行。如果需要匹配后面的case，需要加上语句<code>fallthrough</code></p><ul><li>switch后的var0是变量</li></ul><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> year <span class="hljs-keyword">int</span> = <span class="hljs-number">2020</span><br><span class="hljs-keyword">switch</span> year &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2020</span>:<br>fmt.Println(<span class="hljs-string">&quot;Welcome class of 2020!&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">2021</span>:<br>fmt.Println(<span class="hljs-string">&quot;Welcome class of 2021!&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">2022</span>:<br>fmt.Println(<span class="hljs-string">&quot;Welcome class of 2022!&quot;</span>)<br>&#125;<br><span class="hljs-comment">//Welcome class of 2020!</span><br></code></pre></div></td></tr></table></figure><ul><li>switch后的var0是函数</li></ul><p>此时case必须是函数的合理返回值</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> year <span class="hljs-keyword">int</span> = <span class="hljs-number">2020</span><br><span class="hljs-keyword">switch</span> Welcome(year) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-literal">true</span>:<br>fmt.Println(<span class="hljs-string">&quot;Welcome class of 2020 and after new students!&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-literal">false</span>:<br>fmt.Println(<span class="hljs-string">&quot;Welcome old students!&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Welcome</span><span class="hljs-params">(year <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">return</span> year &gt;= <span class="hljs-number">2020</span><br>&#125;<br><span class="hljs-comment">////Welcome class of 2020!</span><br></code></pre></div></td></tr></table></figure><ul><li>switch后什么都不接</li></ul><p>此时相当于 if - elseif - else</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">score := <span class="hljs-number">30</span><br><br><span class="hljs-keyword">switch</span> &#123;<br>    <span class="hljs-keyword">case</span> score &gt;= <span class="hljs-number">95</span> &amp;&amp; score &lt;= <span class="hljs-number">100</span>:<br>        fmt.Println(<span class="hljs-string">&quot;优秀&quot;</span>)<br>    <span class="hljs-keyword">case</span> score &gt;= <span class="hljs-number">80</span>:<br>        fmt.Println(<span class="hljs-string">&quot;良好&quot;</span>)<br>    <span class="hljs-keyword">case</span> score &gt;= <span class="hljs-number">60</span>:<br>        fmt.Println(<span class="hljs-string">&quot;合格&quot;</span>)<br>    <span class="hljs-keyword">case</span> score &gt;= <span class="hljs-number">0</span>:<br>        fmt.Println(<span class="hljs-string">&quot;不合格&quot;</span>)<br>    <span class="hljs-keyword">default</span>:<br>        fmt.Println(<span class="hljs-string">&quot;输入有误...&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>switch 的 default 不论放在哪都是最后执行</li></ul><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">//写法1</span><br>a := <span class="hljs-number">10</span><br><br><span class="hljs-keyword">switch</span> &#123;<br>   <span class="hljs-keyword">default</span> : &#123;<br>      fmt.Println(<span class="hljs-string">&quot;default&quot;</span>)<br>   &#125;<br>   <span class="hljs-keyword">case</span> a &gt; <span class="hljs-number">0</span> : &#123;<br>      fmt.Println(<span class="hljs-string">&quot;a &gt; 0&quot;</span>)<br>   &#125;<br>   <span class="hljs-keyword">case</span> a &gt;<span class="hljs-number">5</span> : &#123;<br>      fmt.Println(<span class="hljs-string">&quot;a &gt; 5&quot;</span>)<br>   &#125;<br>&#125;<br><span class="hljs-comment">//写法2</span><br>a := <span class="hljs-number">10</span><br><span class="hljs-keyword">switch</span> &#123;<br>   <span class="hljs-keyword">case</span> a &gt; <span class="hljs-number">0</span> : &#123;<br>      fmt.Println(<span class="hljs-string">&quot;a &gt; 0&quot;</span>)<br>   &#125;<br>   <span class="hljs-keyword">case</span> a &gt;<span class="hljs-number">5</span> : &#123;<br>      fmt.Println(<span class="hljs-string">&quot;a &gt; 5&quot;</span>)<br>   &#125;<br>               <span class="hljs-keyword">default</span> : &#123;<br>      fmt.Println(<span class="hljs-string">&quot;default&quot;</span>)<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>写法1和写法2没有区别</p><h5 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h5><p>select是一种控制结构，类似于用于通信的switch语句。</p><p>select里面的所有case语句要求是对channel操作，无论是在channel中写入数据还是从channel中读出数据。</p><p>select随机执行一个可运行的case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。</p><p>直接看例子</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">1</span>)<br>c2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">1</span>)<br>c2 &lt;- <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> msg1 := &lt;-c1:<br>fmt.Println(<span class="hljs-string">&quot;c1 received: &quot;</span>, msg1)<br><span class="hljs-keyword">case</span> msg2 := &lt;-c2:<br>fmt.Println(<span class="hljs-string">&quot;c2 received: &quot;</span>, msg2)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在运行 select 时，会遍历所有（如果有机会的话）的 case 表达式，只要有一个信道有接收到数据，那么 select 就结束，所以输出如下</p><figure class="highlight ldif"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ldif"><span class="hljs-attribute">c2 received</span>:  hello<br></code></pre></div></td></tr></table></figure><p><strong>关于<code>deadlock</code></strong></p><p>如果有多个case可以运行，select会随机选出一个执行。其他不会执行。</p><p>如果没有一个case可以运行，则会运行default子句。但若没有写default子句，select将阻塞，直到某个通信可以运行。Go 不会重新对 channel 或值进行求值。若一直没有通信能够运行，select就会抛出<code>deadlock</code>错误。如下</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    c1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">1</span>)<br>    c2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment">// c2 &lt;- &quot;hello&quot;</span><br><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> msg1 := &lt;-c1:<br>        fmt.Println(<span class="hljs-string">&quot;c1 received: &quot;</span>, msg1)<br>    <span class="hljs-keyword">case</span> msg2 := &lt;-c2:<br>        fmt.Println(<span class="hljs-string">&quot;c2 received: &quot;</span>, msg2)<br>        <span class="hljs-comment">// default:</span><br>        <span class="hljs-comment">//  fmt.Println(&quot;No data received.&quot;)</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight vhdl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vhdl">fatal <span class="hljs-literal">error</span>: <span class="hljs-keyword">all</span> goroutines are asleep - deadlock!<br><br>goroutine <span class="hljs-number">1</span> [<span class="hljs-keyword">select</span>]:<br>main.main()<br>        d:/my_code/go_code/<span class="hljs-literal">text</span>/<span class="hljs-literal">text</span>.go:<span class="hljs-number">13</span> +<span class="hljs-number">0</span>xbbexit status <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>如何解决呢？来看一哈</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">//方法1 写defalt 哪怕是空的</span><br>c1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">1</span>)<br>    c2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">1</span>)<br><br>  <span class="hljs-comment">// c2 &lt;- &quot;hello&quot;</span><br><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> msg1 := &lt;-c1:<br>        fmt.Println(<span class="hljs-string">&quot;c1 received: &quot;</span>, msg1)<br>    <span class="hljs-keyword">case</span> msg2 := &lt;-c2:<br>        fmt.Println(<span class="hljs-string">&quot;c2 received: &quot;</span>, msg2)<br>    <span class="hljs-keyword">default</span>:<br><br>    &#125;<br><span class="hljs-comment">//方法2 让至少一个case可执行</span><br>c1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">1</span>)<br>    c2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">1</span>)<br><br>    c2 &lt;- <span class="hljs-string">&quot;hello&quot;</span><br><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> msg1 := &lt;-c1:<br>        fmt.Println(<span class="hljs-string">&quot;c1 received: &quot;</span>, msg1)<br>    <span class="hljs-keyword">case</span> msg2 := &lt;-c2:<br>        fmt.Println(<span class="hljs-string">&quot;c2 received: &quot;</span>, msg2)<br>   &#125;<br></code></pre></div></td></tr></table></figure><p><strong>关于随机性和持续执行</strong></p><p>select是随机选择case语句，有满足则执行并退出，否则将一直持续检测。随机选择是为了避免饥饿问题（这是网上一个xd说的，有些道理）</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span>   <span class="hljs-string">&quot;time&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Chann</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, stopCh <span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)</span></span> &#123;<br>   <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++ &#123;<br>      ch &lt;- j<br>      time.Sleep(time.Second)<br>   &#125;<br>   stopCh &lt;- <span class="hljs-literal">true</span>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>   ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>   c := <span class="hljs-number">0</span>   stopCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)<br><br>   <span class="hljs-keyword">go</span> Chann(ch, stopCh)<br><br>   <span class="hljs-keyword">for</span> &#123;<br>      <span class="hljs-keyword">select</span> &#123;<br>      <span class="hljs-keyword">case</span> c = &lt;-ch:<br>         fmt.Println(<span class="hljs-string">&quot;Receive C&quot;</span>, c)<br>      <span class="hljs-keyword">case</span> s := &lt;-ch:<br>         fmt.Println(<span class="hljs-string">&quot;Receive S&quot;</span>, s)<br>      <span class="hljs-keyword">case</span> _ = &lt;-stopCh:<br>         <span class="hljs-keyword">goto</span> end<br>      &#125;<br>   &#125;<br>end:<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输出</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>第一次输出<br>Receive C <span class="hljs-number">0</span><br>Receive C <span class="hljs-number">1</span><br>Receive S <span class="hljs-number">2</span><br><span class="hljs-regexp">//</span>第二次输出<br>Receive S <span class="hljs-number">0</span><br>Receive S <span class="hljs-number">1</span><br>Receive S <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>综上，select跟switch有相同点也有不同：</p><ol><li>select 只能用于 channel 的操作(写入/读出/关闭)，而 switch 则更通用一些，switch后面可以接函数、其他表达式或不接；</li><li>select 的 case 是随机的，而 switch 里的 case 是顺序执行；</li></ol><h5 id="goto-无条件跳转语句"><a href="#goto-无条件跳转语句" class="headerlink" title="goto 无条件跳转语句"></a>goto 无条件跳转语句</h5><p>goto后接一个标签，作用是告诉go程序下一步要执行哪里的代码</p><p><code>goto</code> 用于 <strong>跳出多层循环</strong> 或者 <strong>跳到多层循环的指定层</strong> 很好用</p><p>easy example</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">    <span class="hljs-keyword">goto</span> flag<br>    fmt.Println(<span class="hljs-string">&quot;B&quot;</span>)<br>flag:<br>    fmt.Println(<span class="hljs-string">&quot;A&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>执行结果，并不会输出 B ，而只会输出 A</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">A<br></code></pre></div></td></tr></table></figure><p>注意：goto语句与标签之间不能有变量声明，否则编译错误。</p><h5 id="defer-延迟执行"><a href="#defer-延迟执行" class="headerlink" title="defer 延迟执行"></a>defer 延迟执行</h5><p>未完待续…</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://go.dev/tour/welcome/1">A Tour of Go</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://golang.iswbm.com/">Go编程时光</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.runoob.com/go/go-tutorial.html">RUNOOB</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://www.cnblogs.com/jiujuan/p/16014608.html#2090222360">九卷技术录</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用DCT实现对音频水印的添加和提取</title>
    <link href="/posts/e1e00902.html"/>
    <url>/posts/e1e00902.html</url>
    
    <content type="html"><![CDATA[<h3 id="关于数字水印"><a href="#关于数字水印" class="headerlink" title="关于数字水印"></a>关于数字水印</h3><p>数字⽔印技术是⼀种信息隐藏技术。所谓⾳频数字⽔印算法就是将数字⽔印通过⽔印嵌⼊算法嵌⼊到⾳频⽂件中（如 .wav、.mp3、.avi 等），但对原⾳质没有影响。也就是说，嵌入前后的音频人耳无法识别。水印提取的过程与前面正相反，我们需要从嵌入水印的音频中完整的提取出水印。</p><p>同时，水印嵌入音频需要对攻击和其他类型的失真具有鲁棒性，以防止篡改和伪造。典型的攻击包括添加噪声、数据压缩、过滤、重采样、混响等。</p><h3 id="DCT思想"><a href="#DCT思想" class="headerlink" title="DCT思想"></a>DCT思想</h3><p>DCT变换的全称是离散余弦变换(Discrete Cosine Transform)，DCT是一个特殊的DFT，也就是说，DCT变换就是输入信号为实偶函数的DFT变换。</p><p>我的想法是通过DCT变换将音频从时域转换到频域，在频域中寻找引起整体改变最小的数据块，并将其用我们的水印进行覆盖。</p><p><img src="https://user-images.githubusercontent.com/73998546/183948742-8ab26ae2-45a9-41cd-990a-84d0750eae4e.png" alt="DCT变换"></p><p>DCT和逆DCT的公式：</p><p><del>水平有限，只能不求甚解了</del>😭</p><p><img src="https://user-images.githubusercontent.com/73998546/183949971-1f784650-743d-4b79-9908-0ec9bf7fea7d.png" alt="DCT和逆DCT"></p><h3 id="对音频添加音频水印"><a href="#对音频添加音频水印" class="headerlink" title="对音频添加音频水印"></a>对音频添加音频水印</h3><p>DCT水印算法思想</p><hr><p>1：将原始音频统一转换为双声道数组（m行2列），对数组进行分块</p><p>2：假设我们得到n个这样的块</p><p>3：随机生成k秘钥。k的纬度和块纬度相同</p><p>4：水印的大小为w*h，因此水印中有feature=w*h个特征点</p><p>5：如果n≤feature，则无法嵌入水印</p><p>6：对水印中的每一个特征点，重复7-10：</p><p>7：计算第i个原始音频块的DCT，称其为dct block。</p><p>8：计算change[i] = k[i] × watermark[h][w]</p><p>9：将change[i]和当前dct block的最后一列相加，dct block[i, collum − 1]+ = change[i]</p><p>10：计算dct block的逆DCT并保存</p><p>11：得到嵌入水印的音频</p><hr><h3 id="关键代码思路"><a href="#关键代码思路" class="headerlink" title="关键代码思路"></a>关键代码思路</h3><ul><li><p>初始化对象</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, background, watermark, block_size, alpha</span>):</span><br>        b_h, b_w = background.shape[:<span class="hljs-number">2</span>]<br>        w_h, w_w = watermark.shape[:<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">assert</span> w_h &lt;= b_h / block_size, \<br>            <span class="hljs-string">&quot;\r\n请确保您的的水印音频尺寸 不大于 原有音频尺寸的1/&#123;:&#125;\r\nbackground尺寸&#123;:&#125;\r\nwatermark尺寸&#123;:&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<br>                block_size, background.shape, watermark.shape<br>            )<br>        <span class="hljs-comment"># 块大小保存</span><br>        self.block_size = block_size<br>        self.block_size_y = b_w<br>        <span class="hljs-comment"># 水印强度控制</span><br>        self.alpha = alpha<br>        <span class="hljs-comment"># 随机序列</span><br>        self.k1 = np.random.randn(block_size)<br></code></pre></div></td></tr></table></figure><p>这里有一个强条件：水印音频是原有音频大小的1/n。否则水印块和原有块的映射关系被破坏，水印音频将无法完全插入到原有音频中。</p></li><li><p>分块&amp;DCT变换</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dct_blk</span>(<span class="hljs-params">self, background</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        对background进行分块，然后进行dct变换，得到dct变换后的矩阵</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br><br>        background_dct_blocks_h = background.shape[<span class="hljs-number">0</span>]//self.block_size<br>        background_dct_blocks = np.zeros(shape=(<br>            (background_dct_blocks_h,<br>             self.block_size, background.shape[<span class="hljs-number">1</span>])<br>        ))  <br>        <span class="hljs-comment"># 前2个维度用来遍历所有block，后2个维度用来存储每个block的DCT变换的值</span><br>        <span class="hljs-comment"># 垂直方向分成background_dct_blocks_h个块</span><br>        h_data = np.vsplit(background, background_dct_blocks_h)<br>        <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(background_dct_blocks_h):<br>            a_block = h_data[h]<br>            <span class="hljs-comment"># dct变换</span><br>            background_dct_blocks[h, ...] = dct(a_block, <span class="hljs-built_in">type</span>=<span class="hljs-number">3</span>, norm=<span class="hljs-string">&quot;ortho&quot;</span>)<br>        <span class="hljs-keyword">return</span> background_dct_blocks<br></code></pre></div></td></tr></table></figure></li><li><p>水印嵌入</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dct_embed</span>(<span class="hljs-params">self, dct_data, watermark</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;_summary_</span><br><span class="hljs-string">        嵌入水印到original audio的dct系数中</span><br><span class="hljs-string">        Args:</span><br><span class="hljs-string">            dct_data (_type_): original audio的dct系数</span><br><span class="hljs-string">            watermark (_type_): 音频数组</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--------dct_embed start-----------------&quot;</span>)<br>        temp = watermark.flatten()<br>        result = dct_data.copy()<br>        <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(watermark.shape[<span class="hljs-number">0</span>]):<br>            <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(watermark.shape[<span class="hljs-number">1</span>]):   <br>                <span class="hljs-comment"># 查询块(h,w)并遍历对应块的最后一列（影响最小的部分），进行修改</span><br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.block_size):<br>                    result[h, i, self.block_size_y-<span class="hljs-number">1</span>] = dct_data[h,<br>                                                                 i, self.block_size_y-<span class="hljs-number">1</span>]+self.alpha*watermark[h][w]<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--------dct_embed end-----------------&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br></code></pre></div></td></tr></table></figure></li><li><p>IDCT(DCT逆变换)</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">idct_embed</span>(<span class="hljs-params">self, dct_data</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        进行对dct矩阵进行idct变换，完成从频域到空域的变换</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--------idct_embed start-----------------&quot;</span>)<br>        row = <span class="hljs-literal">None</span><br>        result = <span class="hljs-literal">None</span><br>        h = dct_data.shape[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(h):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--------Round:&quot;</span>, i, <span class="hljs-string">&quot;-----------------&quot;</span>)<br>            block = idct(dct_data[i, ...], <span class="hljs-built_in">type</span>=<span class="hljs-number">3</span>, norm=<span class="hljs-string">&quot;ortho&quot;</span>)<br>            result = block <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> np.vstack((result, block))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--------idct_embed end-----------------&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br></code></pre></div></td></tr></table></figure></li><li><p>水印提取</p><p>在每一个块中，遍历对应的加密区域（每个块最后一列），进行加密的逆操作，得到提取出的水印。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dct_extract</span>(<span class="hljs-params">self, synthesis, watermark_size, background</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        从嵌入水印的音频中提取水印</span><br><span class="hljs-string">        :param synthesis: 嵌入水印的空域音频</span><br><span class="hljs-string">        :param watermark_size: 水印大小</span><br><span class="hljs-string">        :return: 提取的空域水印</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        w_h, w_w = watermark_size<br>        recover_watermark = np.zeros(shape=watermark_size)<br>        synthesis_dct_blocks = self.dct_blk(background=synthesis)<br>        background_dct_blocks = self.dct_blk(background=background)<br>        p = np.zeros(self.block_size)<br>        <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(w_h):<br>            <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(w_w):<br>                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.block_size):<br>                    recover_watermark[h, w] = (<br>                        synthesis_dct_blocks[h, k, self.block_size_y-<span class="hljs-number">1</span>] - background_dct_blocks[h, k, self.block_size_y-<span class="hljs-number">1</span>])/self.alpha<br>        <span class="hljs-keyword">return</span> recover_watermark<br></code></pre></div></td></tr></table></figure></li><li><p>绘制频谱图像</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_time</span>(<span class="hljs-params">path, filename</span>):</span><br>    f = wave.<span class="hljs-built_in">open</span>(path, <span class="hljs-string">&#x27;rb&#x27;</span>)<br>    params = f.getparams()<br>    params = f.getparams()<br>    <span class="hljs-comment"># 通道数、采样字节数、采样率、采样帧数</span><br>    nchannels, sampwidth, framerate, nframes = params[:<span class="hljs-number">4</span>]<br>    voiceStrData = f.readframes(nframes)<br>    waveData = np.fromstring(voiceStrData, dtype=np.short)  <span class="hljs-comment"># 将原始字符数据转换为整数</span><br>    <span class="hljs-comment"># 音频数据归一化</span><br>    waveData = waveData * <span class="hljs-number">1.0</span>/<span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>(waveData))<br>    <span class="hljs-comment"># 将音频信号规整乘每行一路通道信号的格式，即该矩阵一行为一个通道的采样点，共nchannels行</span><br>    waveData = np.reshape(waveData, [nframes, nchannels]).T  <span class="hljs-comment"># .T 表示转置</span><br>    f.close()<br><br>    time = np.arange(<span class="hljs-number">0</span>, nframes)*(<span class="hljs-number">1.0</span>/framerate)<br>    plt.plot(time, waveData[<span class="hljs-number">0</span>, :], c=<span class="hljs-string">&#x27;b&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;time&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;am&#x27;</span>)<br>    plt.savefig(<span class="hljs-string">&#x27;./%s.jpg&#x27;</span> % filename)<br>    plt.show()<br></code></pre></div></td></tr></table></figure></li><li><p>主函数</p><p>两个if：</p><p><code>if((np.shape(data_bg)[0] % block_size) != 0)</code></p><p>如果数组大小无法平均分块，也就是说数组大小不是块的大小的整数倍，给数组后面加适当的零，使其变成块大小的整数倍</p><p><code>if(data_bg.ndim == 1)</code></p><p>声道有单声道和立体声之分，单声道振幅数据为n*1矩阵点，立体声为n*2矩阵点</p><p>在单声道和双声道的处理上有所不同，要加特判</p><p>当音频为单声道时，相当于右耳或左耳其中一个通道是静音的，因此这里做的处理是将<code>n*1矩阵点</code>-&gt;<code>n*2矩阵点</code>,即在数组后面加一列0（我的理解）。还有一种处理是将左右耳的通道变为一样的，即在数组后面加一列原数组。（这是另一种想法，我只尝试了前者）</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>   <br>    alpha = <span class="hljs-number">0.1</span><br>    block_size = <span class="hljs-number">4</span><br>    <span class="hljs-comment"># 1.数据读取</span><br>    samplerate_wm, data_wm = wavfile.read(<span class="hljs-string">&quot;piano_3s.wav&quot;</span>)<br>    samplerate_bg, data_bg = wavfile.read(<span class="hljs-string">&quot;buddy_19s.wav&quot;</span>)<br>    <span class="hljs-comment">#若无法平均分块，也就是说数组大小不是块的大小的整数倍，给数组加一列0，使其变成块大小的整数倍</span><br>    <span class="hljs-keyword">if</span>((np.shape(data_bg)[<span class="hljs-number">0</span>] % block_size) != <span class="hljs-number">0</span>):<br>        data_bg = np.r_[data_bg, np.zeros(<br>            block_size-(np.shape(data_bg)[<span class="hljs-number">0</span>] % block_size))]<br>    <span class="hljs-comment">#将单声道音频转为双声道，方便统一处理</span><br>    <span class="hljs-keyword">if</span>(data_bg.ndim == <span class="hljs-number">1</span>):<br>        a = np.array(np.zeros(data_bg.shape[<span class="hljs-number">0</span>])).T<br>        data_bg = np.c_[np.array([data_bg]).T, a]<br>    <span class="hljs-built_in">print</span>(np.shape(data_wm), np.shape(data_bg))<br><br>    <span class="hljs-comment"># 2.分块&amp;dct</span><br>    dct_embed = DCT_Embed(background=data_bg, watermark=data_wm,<br>                          block_size=block_size, alpha=alpha)<br>    background_dct_blocks = dct_embed.dct_blk(background=data_bg)<br>    <span class="hljs-comment"># print(np.shape(background_dct_blocks))</span><br>    <span class="hljs-comment"># 3.嵌入水印到频域</span><br>    embed_wm_blocks = dct_embed.dct_embed(<br>        dct_data=background_dct_blocks, watermark=data_wm)<br>    <span class="hljs-comment"># 4.idct 从频域变换到时域</span><br>    synthesis = dct_embed.idct_embed(dct_data=embed_wm_blocks)<br>    data = normalizeForWav(synthesis)<br>    wavfile.write(<span class="hljs-string">&quot;piano_dct.wav&quot;</span>, samplerate_bg, data)<br>    draw_time(<span class="hljs-string">&quot;piano_3s.wav&quot;</span>,<span class="hljs-string">&quot;piano_3s&quot;</span>)<br>    draw_time(<span class="hljs-string">&quot;buddy_19s.wav&quot;</span>,<span class="hljs-string">&quot;buddy_19s&quot;</span>)<br>    draw_time(<span class="hljs-string">&quot;piano_dct.wav&quot;</span>,<span class="hljs-string">&quot;piano_dct&quot;</span>)<br><br>    <span class="hljs-comment"># 5.提取水印</span><br>    samplerate_syn, data_syn = wavfile.read(<span class="hljs-string">&quot;bunny_compress.wav&quot;</span>)<br>    <span class="hljs-keyword">if</span>((np.shape(data_syn)[<span class="hljs-number">0</span>] % block_size) != <span class="hljs-number">0</span>):<br>        data_syn = np.r_[data_syn, np.zeros(<br>            block_size-(np.shape(data_syn)[<span class="hljs-number">0</span>] % block_size))]<br>    <span class="hljs-keyword">if</span>(data_syn.ndim == <span class="hljs-number">1</span>):<br>        a = np.array(np.zeros(data_syn.shape[<span class="hljs-number">0</span>])).T<br>        data_syn = np.c_[np.array([data_syn]).T, a]<br>    <span class="hljs-built_in">print</span>(np.shape(data_syn))<br>    extract_watermark = dct_embed.dct_extract(<br>        synthesis=data_syn, watermark_size=data_wm.shape, background=data_bg)<br>    data = normalizeForWav(extract_watermark)<br>    wavfile.write(<span class="hljs-string">&quot;compress_ext.wav&quot;</span>, samplerate_wm, data)<br>    draw_time(<span class="hljs-string">&quot;piano_3s.wav&quot;</span>, <span class="hljs-string">&quot;piano_3s&quot;</span>)<br>    draw_time(<span class="hljs-string">&quot;compress_ext.wav&quot;</span>, <span class="hljs-string">&quot;compress_ext&quot;</span>)<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">normalizeForWav</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-keyword">return</span> np.int16(data.real)<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h3><p>是时候展示真正的实力了！</p><ul><li>原始音频</li></ul><audio id="audio" controls="" preload="none">      <source id="mp3" src="/img/audio/buddy_19s.mp3"></audio><p><img src="https://user-images.githubusercontent.com/73998546/184077279-c343a937-b749-42d8-8d64-f43358169f44.png" alt="原始音频频谱"></p><ul><li>水印音频</li></ul><audio id="audio" controls="" preload="none">      <source id="mp3" src="/img/audio/piano_3s.mp3"></audio><p><img src="https://user-images.githubusercontent.com/73998546/184077537-2ca091f7-b7d2-4e9e-8d30-ad1661d61375.jpg" alt="水印音频频谱"></p><ul><li>嵌入水印的音频</li></ul><audio id="audio" controls="" preload="none">      <source id="mp3" src="/img/audio/piano_dct.mp3"></audio><p><img src="https://user-images.githubusercontent.com/73998546/184077542-b48290ae-c1b1-4420-bcfb-fa8c0d8f3794.jpg" alt="嵌入水印的音频频谱"></p><ul><li>提取出的水印音频</li></ul><audio id="audio" controls="" preload="none">      <source id="mp3" src="/img/audio/piano_ext.mp3"></audio><p><img src="https://user-images.githubusercontent.com/73998546/184077559-6f4013fa-3b32-4cf4-94c3-caccb8deef6e.jpg" alt="提取出的水印音频频谱"></p><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>经过图像比对和相关性分析，可以看出提取出的水印和原水印还是有一些差别的。主要原因是将.wav格式的音频转为数组的时候，是int型数组。而在做DCT，IDCT变换后，数组变为float型。最后为了符合.wav格式，需要把float型强制转换为int型，这导致部分精度丢失。😭</p><h3 id="对音频添加图像水印"><a href="#对音频添加图像水印" class="headerlink" title="对音频添加图像水印"></a>对音频添加图像水印</h3><p>跟前面的DCT算法思想类似，不同的就是将图片作为水印插入到音频中。与音频水印转换为的数组（m*2）不同，图片水印转换为的数组更大（m*n）。图片的像素点可以进行二值归一化，1表示黑色像素，0表示白色像素。</p><ul><li><p>分块&amp;DCT变换&amp;水印嵌入</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dct_embed</span>(<span class="hljs-params">audio0,leng,img</span>):</span><br>    numFrames = math.ceil(audio0.shape[<span class="hljs-number">0</span>] / leng)<br>    frames = <span class="hljs-built_in">list</span>()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numFrames):<br>        frames.append(audio0[i * leng: (i * leng) + leng])<br>    ary_frames=np.asarray(frames)<br>    DCTCoeffs = np.copy(ary_frames)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(ary_frames.shape[<span class="hljs-number">0</span>]):<br>        DCTCoeffs[i] = DCT(ary_frames[i])<br><br>    width, height = img.size<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(DCTCoeffs)):<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<br>            audio = DCTCoeffs[i]<br>        <span class="hljs-keyword">else</span>:<br>            audio = np.concatenate((audio, DCTCoeffs[i]), axis=<span class="hljs-number">0</span>)<br>    embedded = audio.copy()<br>    <span class="hljs-comment"># Embedding width and heigth</span><br>    embedded[<span class="hljs-number">0</span>][-<span class="hljs-number">1</span>] = width<br>    embedded[<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>] = height<br>    <span class="hljs-comment"># Embedding watermark</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(width):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(height):<br>            value = img.getpixel(xy=(i, j))<br>            value = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> value == <span class="hljs-number">255</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br>            x = i * height + j<br>            embedded[x + <span class="hljs-number">32</span>][<span class="hljs-number">0</span>] = setLastBit(embedded[x + <span class="hljs-number">32</span>][<span class="hljs-number">0</span>], value)<br>            <br>    <span class="hljs-keyword">return</span> embedded<br></code></pre></div></td></tr></table></figure></li><li><p>IDCT变换</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">idct_embed</span>(<span class="hljs-params">audio,leng</span>):</span><br>    numFrames = math.ceil(audio.shape[<span class="hljs-number">0</span>] / leng)<br>    frames = <span class="hljs-built_in">list</span>()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numFrames):<br>        frames.append(audio[i * leng: (i * leng) + leng])<br>    ary_frames = np.asarray(frames)<br>    iDCTCoeffs = np.copy(ary_frames)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(ary_frames.shape[<span class="hljs-number">0</span>]):<br>        iDCTCoeffs[i] = iDCT(ary_frames[i])<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(iDCTCoeffs)):<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<br>            synthesis = iDCTCoeffs[i]<br>        <span class="hljs-keyword">else</span>:<br>            synthesis = np.concatenate((synthesis, iDCTCoeffs[i]), axis=<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> synthesis<br></code></pre></div></td></tr></table></figure></li><li><p>水印提取</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dct_extract</span>(<span class="hljs-params">audio,leng</span>):</span><br>    numFrames = math.ceil(audio.shape[<span class="hljs-number">0</span>] / leng)<br>    frames = <span class="hljs-built_in">list</span>()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numFrames):<br>        frames.append(audio[i * leng: (i * leng) + leng])<br>    ary_frames = np.asarray(frames)<br>    DCTCoeffs = np.copy(ary_frames)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(ary_frames.shape[<span class="hljs-number">0</span>]):<br>        DCTCoeffs[i] = DCT(ary_frames[i])<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(DCTCoeffs)):<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<br>            audio = DCTCoeffs[i]<br>        <span class="hljs-keyword">else</span>:<br>            audio = np.concatenate((audio, DCTCoeffs[i]), axis=<span class="hljs-number">0</span>)<br><br>    width, heigth = (<span class="hljs-number">112</span>, <span class="hljs-number">112</span>)  <span class="hljs-comment"># sizeExtraction(joinAudio)</span><br>    image = Image.new(<span class="hljs-string">&quot;1&quot;</span>, (width, heigth))<br>    <span class="hljs-comment"># Embedding watermark</span><br>    <span class="hljs-comment"># Extraction watermark</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(width):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(heigth):<br>            x = i * heigth + j<br>            value = getLastBit(audio[x + <span class="hljs-number">32</span>][<span class="hljs-number">0</span>])<br>            image.putpixel(xy=(i, j), value=value)<br><br>    <span class="hljs-keyword">return</span> image<br></code></pre></div></td></tr></table></figure></li><li><p>主函数</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    root = <span class="hljs-string">&quot;..&quot;</span><br><br>    <span class="hljs-comment"># 0. 超参数设置</span><br><br>    length_frame = <span class="hljs-number">4</span> <span class="hljs-comment"># 每段长度</span><br><br>    <span class="hljs-comment"># 1. 数据读取</span><br><br>    <span class="hljs-comment"># watermak</span><br>    img = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;lock.png&quot;</span>)<br>    img = img.convert(mode=<span class="hljs-string">&quot;1&quot;</span>,dither=<span class="hljs-number">0</span>)<br>    samplerate, data = wavfile.read(<span class="hljs-string">&quot;test.wav&quot;</span>)<br>    <span class="hljs-comment"># print(data)</span><br>    <span class="hljs-comment"># print((np.asarray(data)).shape)</span><br><br>    <span class="hljs-comment"># 2. 嵌入水印图像</span><br>    embed_watermak_audio = dct_embed(audio0=data,leng=length_frame,img=img)  <span class="hljs-comment"># 在dct块中嵌入水印图像</span><br><br>    <span class="hljs-comment"># 3. 将图像转换为空域形式</span><br>    synthesis = idct_embed(audio=embed_watermak_audio,leng=length_frame)  <span class="hljs-comment"># idct变换得到空域图像</span><br>    <span class="hljs-comment"># print(synthesis)</span><br>    <span class="hljs-comment"># print((np.asarray(synthesis)).shape)</span><br>    wavfile.write(<span class="hljs-string">&quot;Output.wav&quot;</span>, samplerate, synthesis)<br>    <span class="hljs-comment"># 4. 提取水印</span><br>    extract_watermark = dct_extract(audio=synthesis, leng=length_frame)<br>    extract_watermark = extract_watermark.convert(<span class="hljs-string">&#x27;RGBA&#x27;</span>)<br>    <span class="hljs-comment"># extract_watermark.show()</span><br><br>    images = [img, extract_watermark]<br>    titles = [<span class="hljs-string">&quot;Watermark&quot;</span>, <span class="hljs-string">&quot;Extract_Watermark&quot;</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>        plt.subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, i + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span>:<br>            plt.imshow(images[i], cmap=plt.cm.gray)<br>        <span class="hljs-keyword">else</span>:<br>            plt.imshow(images[i])<br>        plt.title(titles[i])<br>        plt.axis(<span class="hljs-string">&quot;off&quot;</span>)<br>    plt.show()<br><br>    show_wav(<span class="hljs-string">&quot;test.wav&quot;</span>)<br>    show_wav(<span class="hljs-string">&quot;Output.wav&quot;</span>)<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="结果展示-1"><a href="#结果展示-1" class="headerlink" title="结果展示"></a>结果展示</h3><ul><li>原始音频</li></ul><audio id="audio" controls="" preload="none">      <source id="mp3" src="/img/audio/buddy_19s.mp3"></audio><p><img src="https://user-images.githubusercontent.com/73998546/184400801-7e5838e1-b394-44fa-ae83-05d6940dc6ae.png" alt="原始音频频谱"></p><ul><li>嵌入水印的音频</li></ul><audio id="audio" controls="" preload="none">      <source id="mp3" src="/img/audio/Output.mp3"></audio><p><img src="https://user-images.githubusercontent.com/73998546/184400834-1ba5c222-3cc1-4435-9bbb-cbdfbb753377.png" alt="嵌入水印的音频频谱"></p><ul><li>水印（肉眼看确实差点意思）</li></ul><p><img src="https://user-images.githubusercontent.com/73998546/184400847-dbae0a01-ad3b-4018-9d27-129fb3705aa7.png" alt="水印"></p><h3 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a>结果分析</h3><p>同上，DCT,IDCT前后转换数据精度丢失的问题。</p><p>就这样吧</p><p>具体代码实现在这里</p><a class="btn" href="https://github.com/Weipp7/NUS-Project-Audio-Watermarking"  target="_blank">DCT-AUDIO</a><a class="btn" href="https://github.com/Eipi15926/Audio-Steganography-and-Watermark/tree/DCT-Image"  target="_blank">DCT-IMAGE</a><p><a href="https://github.com/Weipp7/NUS-Project-Audio-Watermarking"> </a></p>]]></content>
    
    
    
    <tags>
      
      <tag>DCT</tag>
      
      <tag>Audio Watermark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NUS暑校实验记录</title>
    <link href="/posts/1f6f5090.html"/>
    <url>/posts/1f6f5090.html</url>
    
    <content type="html"><![CDATA[<p>把任务书和实验分析过程(部分)放在这里,以此纪念我逝去的半个暑假</p><p>有些分析过程搞丢了，找到了lab4的全尸<br><a href="https://github.com/Weipp7/NUS-Project-Audio-Watermarking/blob/main/lab/Lab4InfrastructureAndMachines.pdf">任务书</a></p><h2 id="LAB-4-1-Creating-a-certificate-authority"><a href="#LAB-4-1-Creating-a-certificate-authority" class="headerlink" title="LAB 4-1 Creating a certificate authority"></a>LAB 4-1 Creating a certificate authority</h2><p><b>What is the purpose of the extra information in the (CA) certificate you created? </b></p>I don't know what means of the extra information,after I search the internet for extra information.And I found this answer :<br>A digital certificate usually contains:</br><br>public key;</br><br>holder information;</br><br>Information about the Certificate Authority (CA);</br><br>The CA's digital signature of this document and the algorithm used;</br><br>certificate validity period;</br><br>the extra information;</br><br>According to the above information and the testCA.crt,I think the extra information are fingerprints in testCA.crt.And it is used to authenticate the identity and determine whether the document has been tampered with</br><img src="https://user-images.githubusercontent.com/73998546/180237472-09f7d5fd-e483-4536-a402-be504971273f.png"><img src="https://user-images.githubusercontent.com/73998546/180237482-7b7b61ee-fc6c-46f8-a6ff-40bf86f06e7c.png"><img src="https://user-images.githubusercontent.com/73998546/180237506-b9764add-f550-4f89-bae0-1fa25c2d1290.png"><p><b>Explain the files you created. What is each file used for?</b></p><br>In the experiment, we mainly do two things:</br><br>1.Use openssl to create a root certificate</br><br>2.create the certificate for the server</br><img src="https://user-images.githubusercontent.com/73998546/180237635-52d2a7f9-9582-4c9b-bca6-614d7912ecf7.png"><br>On step 1:</br><br>localhost.cnf:Store some configuration files for simplifying parameters</br><br>testCA.key:private key file</br><br>testCA.crt:Credential crt file</br><p><br>On step 2:</br><br><br>localhost.key:key for the server</br><br><br>localhost.csr:certificate signing request csr file for the client key</br><br><br>localhost.crt:Use the key of the CA certificate to sign the client key and generate a signature file</br><br><br>testCA.srl:Record the serial number of the certificate generated by the current CA</br></p><p><b>Why is the webserver using both the certificate and private key? (What does it use each for?)</b></p><br>In most protocols, client and server indicate that both parties want to establish an encrypted session.</br><br>1. The server transmits the digital certificate to the client. The certificate contains the public key of the server. The client uses the public key to parse the digital signature in the certificate, which can verify the identity of the server.</br><br>2. The client generates a symmetric encryption key for encrypted transmission of actual data, encrypts it with the server's public key, and transmits the generated key to the server. Also carry a "client finished" encrypted with the encryption key just generated.</br><br>3. The server receives the symmetric encryption key and tries to decrypt the encrypted field with the key. If the plaintext "client finished" can be obtained, the key is considered valid and can be used for subsequent data encryption transmission. At the same time, "server finished" is encrypted with this key and passed to the client.</br><br>4. The client decrypts with the symmetric secret key. If the plaintext "server finished" can be obtained, the client believes that the server has correctly received the symmetric key.</br><br>Using both certificates and private keys at the same time can greatly improve security and prevent data from being decrypted during transmission</br><br>The specific running example is as follows:</br><img src="https://user-images.githubusercontent.com/73998546/180237587-34cdc0d9-4144-41ed-b31a-1eb096290805.png"><img src="https://user-images.githubusercontent.com/73998546/180237602-ad0db595-8558-4879-b85b-92fb164a1ec9.png"><h2 id="LAB-4-2-SEED-Buffer-Overflow-Vulnerability-Lab"><a href="#LAB-4-2-SEED-Buffer-Overflow-Vulnerability-Lab" class="headerlink" title="LAB 4-2 SEED Buffer-Overflow Vulnerability Lab"></a>LAB 4-2 SEED Buffer-Overflow Vulnerability Lab</h2><p><p1><b>Task 1: Getting Familiar with Shellcode</b></p1><br><br>typing make in terminal,then Two binaries will be created, a32.out (32-bit) and a64.out (64-bit).Run them and we observe that we get the root shell.</br><br><img src="https://user-images.githubusercontent.com/73998546/180107462-523e17bd-07d2-462a-96e8-111c749c182f.png"></p><p><br><p1><b>Task 2:Understanding the Vulnerable Program</b></p1></br><br><br>Since the  compilation and setup commands are already included in Makefile,we just need to type make to execute those commands.</br></p><p><p1><b>Task 3:Launching Attack on 32-bit Program </b><p1><br><br>Our purpose is to implement malicious code by exploiting buffer overflows and eventually gain root privileges.</br><br><br>We can see that in the exploit.py file, we need to fill in several parts, namely shellcode, start, ret and offset.</br><br><br>First, we fill in the 32-bit corresponding malicious code to obtain root shell.</br><br><img src="https://user-images.githubusercontent.com/73998546/180107547-06916f1c-958f-42ee-96d6-a1df1fc6f3fd.png"><br><br>Then we analyze the stack frame structure in the function bof:</br><br><img src="https://user-images.githubusercontent.com/73998546/180107561-1b604e81-edcd-4550-bbf3-441ecda45872.jpg"><br><br>We consider putting shellcode at the end of badfile, so “start = 517-len(shellcode)”</br><br><br>After that we need to determine the position of ret in badfile, that is offset. We consider offset = ebp - &amp;buffer + 4 , so the first step is to determine the values of ebp and &amp;buffer.</br><br><br>We print out the ebp value and the buffer’s address through the gdb debugging tool.</br></p><p><br>According to the note1 in the task book,we need to use next to execute a few instructions and stop after the ebp register is modified to point to the stack frame of the bof() function.</br><br><img src="https://user-images.githubusercontent.com/73998546/180107567-85507cee-1612-4d98-baf6-f9344891191f.png"><br><br>buff = 0xffffca7c</br><br><br>ebp = 0xffffcae8</br></p><p><br>The value of ret (return address) should jump after new ret and before shellcode. This ensures that the shellcode is executed.</br><br><br>so ret = ebp + n(n&gt;=8)</br><br><br>But I found that when n=8, the program reported an error:segmentation fault.</br><br><br>According to the note2 in the task book,the real stack frame value is larger than the value of the gdb runtime,so we should add an offset.</br><br><br>After many attempts, I found that offsets between 200-300 can get a root shell.</br><br><br>Now let’s check it!</br><br><img src="https://user-images.githubusercontent.com/73998546/180107577-1284062f-b37b-4c0a-8919-e0621ccebf57.png"><br><br>OK!I obtain the root shell!</br></p><h2 id="LAB-4-3-SEED-Return-to-libc-Attack-lab"><a href="#LAB-4-3-SEED-Return-to-libc-Attack-lab" class="headerlink" title="LAB 4-3 SEED Return-to-libc Attack lab"></a>LAB 4-3 SEED Return-to-libc Attack lab</h2><p><p1><b>Task 1:Finding out the Addresses of libc Functions</b></p1><br><br>We used the p command to print the addresses of system() and exit() functions.</br><br><br>As follow:</br><br><br><img src="https://user-images.githubusercontent.com/73998546/180268460-177875dd-b562-4422-b566-bb3b745c60f3.png"></br></p><p><br><p1><b>Task 2: Putting the shell string in the memory</b></p1></br><br>I uesd the method inntask 2 to put the shell string in the memory.<br>First define a new shell variable MYSHELL = /bin/sh,then I will use the addresses of this variable as an argument to system() call.<br>Following the code in task3.2, we could compile the code and print the addresses of MYSHELL.<br><br><img src="https://user-images.githubusercontent.com/73998546/180268512-55e72405-0c67-4d06-ad70-26dafff3ab36.png"></br></p><p><p1><b>Task 3: Launching the Attack </b></p1><br>According to the above two tasks,we get thses informations:<br>0xf7e12420 <system><br>0xf7e04f80 <exit><br>0xffffd3f6 bin/sh<br>So it is natural to fill them in the corresponding address.<br>After we should consider the stack frame structure to figure out X,Y and Z.<br>I think the stack frame as this:<br><br><img src="https://user-images.githubusercontent.com/73998546/180268579-bb65767b-38ef-46f6-a582-a8ae28ab4e1e.jpg"></br><br>Since we are going to excute the function system(),the return address should be loaded the system_addr.<br>So Y should be the relative offset of ret,Y = ebp - buff + 4.<br>And then, considering the addresses of the variable MYSHELL as an argument to system() call,I put it behind the system().<br>So X = ebp - buff + 8<br>Then execute function exit(),I put it behind MYSHELL.<br>So Z = ebp - buff + 12<br>Let’s try to run<br><br><img src="https://user-images.githubusercontent.com/73998546/180268633-efae3337-cbbf-4afa-a968-71db83adbc03.png"></br><br><br><img src="https://user-images.githubusercontent.com/73998546/180268664-3961c817-d295-4d7f-8ec5-24cb980a16fc.png"></br><br>Opps maybe something wrong.We check it.I think the system_addr won’t be wrong,that’s the start of the execution programm.<br>So maybe X or Z is wrong.At present I have no idea,so we could try to change X and Z.<br>I first tried swapping the values of X and Z, after that I ran the program.Then it works!<br><br><img src="https://user-images.githubusercontent.com/73998546/180268686-d0fa33b2-2ddd-4603-b275-6b592eb9e446.png"></br><br><br><img src="https://user-images.githubusercontent.com/73998546/180268698-01b52cc2-00e2-4320-84ad-974f4fef5bd7.png"></br><br>It’s amazing,I wonder how.After I search on Internet about the stack frame structure,then I find this:<br><br><img src="https://user-images.githubusercontent.com/73998546/180268707-6095327f-d6bf-409c-a99f-add9f052684a.png"></br><br>So the position “ebp - buff + 8” to be filled in is the return address of the system.<br>The return address of system is followed by the parameters,and MYSHELL is passed as a parameter to system.</p><p><p1><b>Attack variation 1: Is the exit() function really necessary?</b></p1><br><br>I think it’s not really necessary.<br>Actually, I found that whether it is to remove the exit, or to change the position of the exit, such as making Z = ebp - buff + 4 or Z = ebp - buff + 16,<br>can successfully obtain root privileges.<br>My idea is that the main function of this experiment is to pass MYSHELL as a parameter and run the system function at the same time.<br>This has little to do with exit. As long as the previous steps are successfully executed, root privileges can be obtained.<br>Even if I remove exit, it still gets root shell and exits successfully, this is what I have observed.<br>According to the paper,the function exit() seems to help the shellcode to quit without a trace,but I could not find somewhere different with the previous.</br></p><p><p1><b>Attack variation 2: change the file name of retlib to a different name,Repeat the attack (without changing the content of badfile). Will your attack succeed or not?</b></p1><br><br>After rename the file name , my attack failed.<br>In fact, when the program is executed, the name of the program is passed on the stack first,<br> and then the other variables in the program are passed on the stack. So when we only change the length of the program name,<br> the addresses of the other environment variables will be extended backwards,and our badfile isn’t changeg, which will cause us to be unable to access the correct environment variables<br> , so the attack fails.</br></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基于TABLE FILLING的NER&amp;RE</title>
    <link href="/posts/d92671ff.html"/>
    <url>/posts/d92671ff.html</url>
    
    <content type="html"><![CDATA[<p>在以往的NER&amp;RE的任务中，很多方法都是基于复杂的手工特征和神经网络架构，这导致训练的时间和基于历史的预测时间较长。</p><p>现在呢，有大佬提出了一种新颖而简单的方法：基于<strong>表格表示</strong>从<strong>非结构化文本</strong>中提取命名实体和关系</p><p><code>输入：单词序列w1,w2 ... wn（n 是输入中的单词数）</code></p><blockquote><p>Johanson Smith lives in London</p></blockquote><p><code>输出：关系三元组（arg0type0，relation，arg1type1）</code></p><blockquote><p>（Johanson_B-PER,LiveIn,London_U-LOC）<br>（Smith_B-PER,LiveIn,London_U-LOC）</p></blockquote><p>具体怎么整呢。我们定义一个 n×n 上三角矩阵 Y ，其中对角元素 <strong>Yi,i</strong> ∈ E (1 ≤ i ≤ n) 表示<strong>词wi</strong>，非对角元素 <strong>Yi,j</strong> ∈ R(1 ≤ i &lt; j ≤ n) 表示有向关系单词 wi 和 wj 之间的**<strong>标签</strong>。</p><p>此模型可以看做将一系列单词 w1w,2 · · · wn映射到上三角矩阵</p><p><img src="https://user-images.githubusercontent.com/73998546/183257257-ea3bf94f-a5c2-4fd8-b974-0157fd4c382c.png" alt="上三角矩阵"></p><h2 id="模型框架"><a href="#模型框架" class="headerlink" title="模型框架"></a>模型框架</h2><p>该模型分为并行的两块，在到达Entity Representation层后，分别用不同的方法进行ner和re。也就是说，我们在 BERT 编码器之上执行 RE<br>识别实体之后，NER 模型填充 Y 中的所有对角线元素，RE 模型预测所有非对角元素。</p><p><img src="https://user-images.githubusercontent.com/73998546/183257289-9735816a-8a38-45c0-9dc0-f6a1783e326f.png" alt="模型框架"></p><h3 id="Named-Entity-Recognition"><a href="#Named-Entity-Recognition" class="headerlink" title="Named Entity Recognition"></a>Named Entity Recognition</h3><h4 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h4><p>BERT 分词器使用 WordPiece 拆分单词在 BPE 的帮助下转化为子词标记</p><blockquote><p>“Johanson” –&gt; “Johan”和”##son”</p></blockquote><p><code>输入：经WordPiece处理过的子词序列</code><br><code>输出：文本中各个子词融合了全文语义信息后的向量表示</code></p><h4 id="Word-level-Embedding"><a href="#Word-level-Embedding" class="headerlink" title="Word-level Embedding"></a>Word-level Embedding</h4><p>由于 NE 是在单词级别注释的，我们在训练和预测两个过程中都需要它在单词级别的表示。<br>计算方法如下：<br>Bert嵌入的子词标记组成词（eti,1,eti,2…eti,s）作为输入,ewi作为输出</p><p><img src="https://user-images.githubusercontent.com/73998546/183257538-c90f3dcd-f3cb-4b72-9259-ffd6fbbfc1ef.png" alt=" "></p><p>f表示一个最大池化操作，即对（eti,1,eti,2…eti,s）进行降维压缩，以某种方式取最大值</p><p><code>输入：子词向量</code><br><code>输出：池化后的word level的单词向量</code></p><h4 id="Entity-Representation"><a href="#Entity-Representation" class="headerlink" title="Entity Representation"></a>Entity Representation</h4><p><img src="https://user-images.githubusercontent.com/73998546/183257819-75c634af-abf8-434f-8043-2d8ce3f8b6aa.png" alt="Entity Representation"></p><p>计算方法如下：<br>①词wi的表示ewi<br>②上一个标签yi-1的embedding lyi−1<br>③<del>出现在时间步长上的前一个 NE 跨度的 BERT 嵌入的最大池化</del>（翻译成人话：上一个实体的向量表示）</p><blockquote><p>如上图的示例，③为上一个实体”Johanson Smith”的向量表示</p></blockquote><p>其中⊕代表向量连接。</p><p><img src="https://user-images.githubusercontent.com/73998546/183257900-65e248b0-e492-4753-be11-89dd8104c897.png" alt=" "></p><p>输入：①⊕②⊕③<br>输出：关系隐藏向量h</p><h4 id="Softmax-Classifier-of-NER"><a href="#Softmax-Classifier-of-NER" class="headerlink" title="Softmax Classifier of NER"></a>Softmax Classifier of NER</h4><p>之后应用一个全连接层，然后是一个softmax 函数 σ 在时间步 i 处获得所有可能的 NE 标签的概率分布，之后选择概率最高的y^i填充Yi,i (= yi)</p><p><img src="https://user-images.githubusercontent.com/73998546/183258044-c7e1f768-6904-42b7-86c3-15dbd23e1016.png" alt=" "></p><p><code>输入：关系隐藏向量h、矩阵w、线性变换的偏置向量b</code><br><code>输出：概率最高的标签y</code></p><h3 id="Relation-Extraction"><a href="#Relation-Extraction" class="headerlink" title="Relation Extraction"></a>Relation Extraction</h3><p>RE模型利用实体跨度和他们的NE标签以获得关系表示，用于预测关系标签。</p><p><img src="https://user-images.githubusercontent.com/73998546/183258323-bb980bfa-6fdb-4e98-bc91-a0acbf05084b.png" alt="RE模型"></p><h4 id="Word-Representation"><a href="#Word-Representation" class="headerlink" title="Word Representation"></a>Word Representation</h4><p>实体跨度特征 zi（在时间点 i）是使用实体跨度中组成词的表示来计算的：</p><p><img src="https://user-images.githubusercontent.com/73998546/183258388-b9770e0d-eb0e-4ed9-a724-b626b91a3728.png" alt=" "></p><p>换个说法，zi是从 first(i) 开始的,last（i）结束的实体跨度的单词表示的最大池化。<br>在数学上，单词表示，即 RE 模型的输入，是实体跨度和实体标签特征的串联，</p><p><img src="https://user-images.githubusercontent.com/73998546/183258558-8d424d6e-f6e2-49ed-a848-1020db450fba.png" alt=" "></p><p>生成qk矩阵张量</p><p><img src="https://user-images.githubusercontent.com/73998546/183259054-97cd14b3-0c2a-4c31-8338-07a0b2aa45eb.png" alt=" "></p><p><code>输入：实体跨度zi和实体标签特征lyi的串联</code><br><code>输出：qk矩阵张量</code></p><h4 id="Tensor-Dot-Product"><a href="#Tensor-Dot-Product" class="headerlink" title="Tensor Dot-Product"></a>Tensor Dot-Product</h4><p><code>输入：qk矩阵张量</code><br><code>输出：qk张量的点积</code></p><h4 id="Softmax-Classifier-of-RE"><a href="#Softmax-Classifier-of-RE" class="headerlink" title="Softmax Classifier of RE"></a>Softmax Classifier of RE</h4><p>Softmax 函数σ 计算所有的概率分布关系标签 R。我们用产生最高概率的关系标签记为y^i,j 。</p><p><img src="https://user-images.githubusercontent.com/73998546/183259181-b700d4d0-a49b-43ce-9483-e823811aa2d2.png" alt=" "></p><p><code>输入：qk张量的点积</code><br><code>输出：产生最高概率的关系标签y^i,j</code></p><p>参考论文<br><a href="https://www.jstage.jst.go.jp/article/jnlp/29/1/29_187/_pdf/-char/ja">Named Entity Recognition and Relation Extraction using Enhanced Table Filling by Contextualized Representations</a></p>]]></content>
    
    
    <categories>
      
      <category>NER</category>
      
      <category>RE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NER</tag>
      
      <tag>RE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AESINER模型分析</title>
    <link href="/posts/a8e0d3dd.html"/>
    <url>/posts/a8e0d3dd.html</url>
    
    <content type="html"><![CDATA[<p>NER 的主要方法传统上被认为是具有隐马尔可夫模型 (HMM) 和条件随机场 (CRF) 等模型的序列标记任务学习。而神经模型也占据主导地位。原因是他们在编码上下文信息方面非常强大，可以驱动 NER 系统更好地理解文本并识别输入文本中的NE。</p><p>对于一段语料而言，有很多句法特征，例如词性标签、句法成分、依赖关系等。对NER任务来讲，这些特征可以有效地识别一段文本中的继承结构，从而指导系统相应地找到合适的实体单元。因此，寻找合适的方法将这些信息整合到神经模型中，将会是一次全新的突破。</p><p>AESINER提出了一个巧妙的解决方案。</p><h3 id="有监督-or-无监督？"><a href="#有监督-or-无监督？" class="headerlink" title="有监督 or 无监督？"></a>有监督 or 无监督？</h3><p>AESI模型是有监督学习。其预训练的嵌入包含从大规模语料库中学习到的上下文信息，在本模型中通过在输入中直接连接多个预训练嵌入来合并它们，这里的预训练都是给出训练文本对应标注的训练，因此判断为有监督。</p><h3 id="数据集样式"><a href="#数据集样式" class="headerlink" title="数据集样式"></a>数据集样式</h3><p><code>输入：普通文本</code><br><code>中间输出：每个词向量的句法信息（包括词性标签、语法信息和依赖关系）的集合</code><br><code>最终输出：输出句子中判断出的实体标签</code></p><blockquote><p>输入：Today is my last day at my office.</p></blockquote><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">中间输出：<br>&#123;<span class="hljs-attr">&quot;sentences&quot;</span>: [&#123;<span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">&quot;line&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">&quot;parse&quot;</span>: <span class="hljs-string">&quot;(ROOT\n  (S\n    (NP (NN today))\n    (VP (VBZ is)\n      (NP\n        (NP (PRP$ my) (JJ last) (NN day))\n        (PP (IN at)\n          (NP (DT the) (NN office)))))\n    (. .)))&quot;</span>, <span class="hljs-attr">&quot;basicDependencies&quot;</span>: [&#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;ROOT&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;ROOT&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;nsubj&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;today&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;cop&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;is&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;nmod:poss&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;my&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;amod&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;last&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;case&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;office&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;at&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;det&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;office&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">7</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;the&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;nmod&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;office&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;punct&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">9</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;.&quot;</span>&#125;], <span class="hljs-attr">&quot;enhancedDependencies&quot;</span>: [&#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;ROOT&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;ROOT&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;nsubj&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;today&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;cop&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;is&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;nmod:poss&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;my&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;amod&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;last&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;case&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;office&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;at&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;det&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;office&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">7</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;the&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;nmod:at&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;office&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;punct&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">9</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;.&quot;</span>&#125;], <span class="hljs-attr">&quot;enhancedPlusPlusDependencies&quot;</span>: [&#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;ROOT&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;ROOT&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;nsubj&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;today&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;cop&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;is&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;nmod:poss&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;my&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;amod&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;last&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;case&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;office&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;at&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;det&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;office&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">7</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;the&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;nmod:at&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;office&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;dep&quot;</span>: <span class="hljs-string">&quot;punct&quot;</span>, <span class="hljs-attr">&quot;governor&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;governorGloss&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;dependent&quot;</span>: <span class="hljs-number">9</span>, <span class="hljs-attr">&quot;dependentGloss&quot;</span>: <span class="hljs-string">&quot;.&quot;</span>&#125;], <span class="hljs-attr">&quot;tokens&quot;</span>: [&#123;<span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">&quot;word&quot;</span>: <span class="hljs-string">&quot;today&quot;</span>, <span class="hljs-attr">&quot;originalText&quot;</span>: <span class="hljs-string">&quot;today&quot;</span>, <span class="hljs-attr">&quot;characterOffsetBegin&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">&quot;characterOffsetEnd&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;pos&quot;</span>: <span class="hljs-string">&quot;NN&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">&quot;word&quot;</span>: <span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-attr">&quot;originalText&quot;</span>: <span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-attr">&quot;characterOffsetBegin&quot;</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">&quot;characterOffsetEnd&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">&quot;pos&quot;</span>: <span class="hljs-string">&quot;VBZ&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">&quot;word&quot;</span>: <span class="hljs-string">&quot;my&quot;</span>, <span class="hljs-attr">&quot;originalText&quot;</span>: <span class="hljs-string">&quot;my&quot;</span>, <span class="hljs-attr">&quot;characterOffsetBegin&quot;</span>: <span class="hljs-number">9</span>, <span class="hljs-attr">&quot;characterOffsetEnd&quot;</span>: <span class="hljs-number">11</span>, <span class="hljs-attr">&quot;pos&quot;</span>: <span class="hljs-string">&quot;PRP$&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">&quot;word&quot;</span>: <span class="hljs-string">&quot;last&quot;</span>, <span class="hljs-attr">&quot;originalText&quot;</span>: <span class="hljs-string">&quot;last&quot;</span>, <span class="hljs-attr">&quot;characterOffsetBegin&quot;</span>: <span class="hljs-number">12</span>, <span class="hljs-attr">&quot;characterOffsetEnd&quot;</span>: <span class="hljs-number">16</span>, <span class="hljs-attr">&quot;pos&quot;</span>: <span class="hljs-string">&quot;JJ&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">&quot;word&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;originalText&quot;</span>: <span class="hljs-string">&quot;day&quot;</span>, <span class="hljs-attr">&quot;characterOffsetBegin&quot;</span>: <span class="hljs-number">17</span>, <span class="hljs-attr">&quot;characterOffsetEnd&quot;</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">&quot;pos&quot;</span>: <span class="hljs-string">&quot;NN&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">&quot;word&quot;</span>: <span class="hljs-string">&quot;at&quot;</span>, <span class="hljs-attr">&quot;originalText&quot;</span>: <span class="hljs-string">&quot;at&quot;</span>, <span class="hljs-attr">&quot;characterOffsetBegin&quot;</span>: <span class="hljs-number">21</span>, <span class="hljs-attr">&quot;characterOffsetEnd&quot;</span>: <span class="hljs-number">23</span>, <span class="hljs-attr">&quot;pos&quot;</span>: <span class="hljs-string">&quot;IN&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-number">7</span>, <span class="hljs-attr">&quot;word&quot;</span>: <span class="hljs-string">&quot;the&quot;</span>, <span class="hljs-attr">&quot;originalText&quot;</span>: <span class="hljs-string">&quot;the&quot;</span>, <span class="hljs-attr">&quot;characterOffsetBegin&quot;</span>: <span class="hljs-number">24</span>, <span class="hljs-attr">&quot;characterOffsetEnd&quot;</span>: <span class="hljs-number">27</span>, <span class="hljs-attr">&quot;pos&quot;</span>: <span class="hljs-string">&quot;DT&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">&quot;word&quot;</span>: <span class="hljs-string">&quot;office&quot;</span>, <span class="hljs-attr">&quot;originalText&quot;</span>: <span class="hljs-string">&quot;office&quot;</span>, <span class="hljs-attr">&quot;characterOffsetBegin&quot;</span>: <span class="hljs-number">28</span>, <span class="hljs-attr">&quot;characterOffsetEnd&quot;</span>: <span class="hljs-number">34</span>, <span class="hljs-attr">&quot;pos&quot;</span>: <span class="hljs-string">&quot;NN&quot;</span>&#125;, &#123;<span class="hljs-attr">&quot;index&quot;</span>: <span class="hljs-number">9</span>, <span class="hljs-attr">&quot;word&quot;</span>: <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-attr">&quot;originalText&quot;</span>: <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-attr">&quot;characterOffsetBegin&quot;</span>: <span class="hljs-number">35</span>, <span class="hljs-attr">&quot;characterOffsetEnd&quot;</span>: <span class="hljs-number">36</span>, <span class="hljs-attr">&quot;pos&quot;</span>: <span class="hljs-string">&quot;.&quot;</span>&#125;]&#125;]&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>最终输出：<br>today O<br>is O<br>my O<br>last O<br>day O<br>at O<br>the O<br>office O<br>. O</p></blockquote><h3 id="模型框架"><a href="#模型框架" class="headerlink" title="模型框架"></a>模型框架</h3><p><img src="https://user-images.githubusercontent.com/73998546/183022036-0d0fcb88-8e00-4fff-96b4-9049d7d47a26.png" alt="模型框架"></p><p>AESINER由6个模块组成。</p><h4 id="1-Embedding-Layer-amp-Encoder"><a href="#1-Embedding-Layer-amp-Encoder" class="headerlink" title="1.Embedding Layer &amp; Encoder"></a>1.Embedding Layer &amp; Encoder</h4><p>以transformer作为上下文编码器，输出单字在句子中的向量表示<br><code>输入：文本</code><br><code>输出：文本中各个字融合了全文语义信息后的向量表示</code></p><h4 id="2-句法信息提取"><a href="#2-句法信息提取" class="headerlink" title="2.句法信息提取"></a>2.句法信息提取</h4><p><img src="https://user-images.githubusercontent.com/73998546/183026914-e2868d7d-f662-4929-a11f-641d1359ed79.png" alt="句法信息提取"></p><p><strong>For POS LABELS</strong>:我们将每个 xi 视为中心字并采用±1字的窗口来提取<br>它的上下文词及其对应的词性标签。<br>例如，在图 (a) 的示例中，对于“Salt”，±1 字窗口覆盖其左侧和右侧的单词，以便生成的上下文特征是“Salt”、“is”和“Lake”，我们使用这些词及其词性标签的组合作为POS 信息（即“Salt NNP”、“is BVZ”和“Lake NNP”）用于 NER 任务。</p><p><strong>For syntactic constituents</strong>：我们从 xi 开始(X 的语法树的叶子)，然后向上搜索树来找到第一个可接受的语法节点2,并选择该节点下的所有标记作为上下文特征，并将它们组合起来用语法节点2获取成分信息。<br>例如，在图 (b) 中，我们从“Salt”开始并提取其第一个接受节点“NP”，然后收集“NP”下的token作为上下文特征（即“Salt”、“Lake”和“City”）并将它们组合起来<br>用“NP”来获取成分信息（即，“Salt NP”, “Lake NP”, and “City NP”)。</p><p><strong>For dependency relations</strong>：对于依赖关系，我们找到所有上下文，通过收集其所有依赖项来为每个 xi 提供特征。<del>然后考虑上下文特征的组合和它们的入站依赖类型作为相应的依赖信息。</del>（不说人话是吧，直接看例子）<br>例如，如图 (c) 所示，对于“Salt”，其上下文特征是“Salt”和“City”，以及它们对应的依赖信息是“Salt compound”和“City root”.</p><p><code>输入：字向量</code><br><code>输出：每个字对应的POS LABELS、syntactic constituents、dependency relations的key-values向量表示</code></p><h4 id="3-kvmn模块"><a href="#3-kvmn模块" class="headerlink" title="3.kvmn模块"></a>3.kvmn模块</h4><p>由于句法信息是从现成的工具包，可能有提取的句法信息中的噪声，其中如果使用不当，可能会损害模型性能。此模型提出了一个 KVMN 模块（Mc)对成对组织的上下文特征进行建模和句法信息实例。</p><p><img src="https://user-images.githubusercontent.com/73998546/183028144-86a78bae-b95a-4fbc-a4b7-5d6980bd0c57.png" alt="kvmn模块"></p><p>首先映射它的上下文特征和句法信息到 KVMN 中的键和值，用Kc i = [k c i,1 , . . . , kc i,j , . . . , kc i,mi ]和V c i = [v c i,1 , . . . , vc i,j , . . . , vc i,mi ]表示</p><p><img src="https://user-images.githubusercontent.com/73998546/183028378-d97127d1-725e-4231-8e96-95aa720103e4.png" alt=" "><br><img src="https://user-images.githubusercontent.com/73998546/183028397-f39ba36b-043e-4d12-8132-e001a7caca2b.png" alt=" "></p><p>Si是Mc（即KVMN模块）的输出<br>KVMN 保证了句法信息根据其对应的上下文特征进行加权，以便重要信息可以相应地加以区分和利用</p><p><code>输入：每个字对应的POS LABELS、syntactic constituents、dependency relations的key-values向量</code><br><code>输出：由k-v映射出的si向量</code></p><h4 id="4-The-Syntax-Attention"><a href="#4-The-Syntax-Attention" class="headerlink" title="4.The Syntax Attention"></a>4.The Syntax Attention</h4><p><img src="https://user-images.githubusercontent.com/73998546/183029034-3dd082e4-e2bd-40b6-8c5e-5d8338398dc9.png" alt="Syntax Attention模块"><br>在对每种类型的句法信息进行编码时通过 KVMN，最直接的做法是把他们直接相连。然而考虑到不同的句法信息可能会相互冲突，所以采用一个更有效的方式将它们结合起来。</p><p><code>输入：si向量</code><br><code>输出：si‘是不同句法类型的syntax attention的输出</code></p><h4 id="5-The-Gate-Mechanism"><a href="#5-The-Gate-Mechanism" class="headerlink" title="5.The Gate Mechanism"></a>5.The Gate Mechanism</h4><p>AESI模型提出了一种门机制 (GM) 将其合并到主干 NER 模型中，其中这种机制可以动态加权并决定如何在标记 NE 时利用句法信息。</p><p><img src="https://user-images.githubusercontent.com/73998546/183235285-305dce78-1160-49cd-9486-ff39dc12f85a.png" alt="Gate Mechanism"></p><p>主要操作是重置函数ri得到来自上下文编码器的编码和语法注意</p><p><img src="https://user-images.githubusercontent.com/73998546/183235767-3baaf8fb-6b0f-48c1-8de7-47fcff7dad4e.png" alt=" "><br><img src="https://user-images.githubusercontent.com/73998546/183235768-f60289ab-4954-4183-98fd-b99e658593c0.png" alt=" "></p><p><code>输入：si‘和hi（融合了全文语义信息后的字向量表示）</code><br><code>输出：Oi（对应于输入xi的门机制输出）</code></p><h4 id="6-Output-layer"><a href="#6-Output-layer" class="headerlink" title="6.Output layer"></a>6.Output layer</h4><p>将oi用一个可训练的矩阵 Wo 用于将其维度对齐到ui = Wo · oi 的输出空间得到yi。之后应用条件随机场 (CRF) 解码器预测标签 y^i ∈ T（其中 T 是具有所有NE标签），再输出序列Y</p><p><code>输入：oi</code><br><code>输出：最终的标签序列Y</code></p><p>参考论文<br><a href="https://arxiv.org/pdf/2010.15466.pdf">Improving Named Entity Recognition with<br>Attentive Ensemble of Syntactic Information</a></p>]]></content>
    
    
    <categories>
      
      <category>NER</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NER</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关系三重提取的新框架</title>
    <link href="/posts/e938ff54.html"/>
    <url>/posts/e938ff54.html</url>
    
    <content type="html"><![CDATA[<h2 id="CASREL模型的分析"><a href="#CASREL模型的分析" class="headerlink" title="CASREL模型的分析"></a>CASREL模型的分析</h2><p>在做知识图谱的工作时，我们面临的首要问题是对一段语料进行实体识别(NER)和关系抽取(RE)。</p><p><del>啥？知识图谱是啥？</del></p><blockquote><p>A knowledge graph, also known as a semantic network, represents a network of real-world entities—i.e. objects, events, situations, or concepts—and illustrates the relationship between them. This information is usually stored in a graph database and visualized as a graph structure, prompting the term knowledge “graph.”</p></blockquote><p><img src="https://user-images.githubusercontent.com/73998546/182825426-f5f2a104-51eb-4ccd-b340-5a990a1c615a.png" alt="知识图谱"></p><p>简而言之，我们现实生活中的一切都可以用三元组（主语，关系，宾语）表示，抽象到图的数据结构中，圈圈代表主语和宾语，连接圈圈的箭头表示关系。</p><p>知识图谱的关键成分是关系事实，其中大部分由两个实体组成，由语义关系连接。 这些事实是以（主语，关系，宾语）或（s，r，o）的形式，称为关系三元组。</p><p>在之前的做法中，针对关系提取最早的做法是<strong>管道方法</strong>。它首先识别句子中的所有实体，然后对每个实体对进行关系分类。这种方法往往会受到错误传播问题的影响，因为早期阶段的错误无法在早期阶段得到纠正。</p><p>为了解决这个问题，后续大牛们提出了<strong>实体和关系的联合学习</strong>，其中有基于特征的模型以及神经网络模型。但是现有方法不能有效处理一个句子包含多个关系三元组的情况。<br>而且这些提取重叠三元组的工作仍有很多不足之处。</p><p>我们来看看当有多个三元组时，可能会出现的问题：</p><p>Normal：<font color=Green>华科</font>学生<font color=Green>wpy</font>邀请<font color=Green>腾讯</font>老板<font color=Green>马化腾</font>上模电课<br>关系三元组：（wpy，就读于，华科），（马化腾，CEO，腾讯）</p><p>EPO:<font color=Green>姜文</font>在他导演的<font color=Green>让子弹飞</font>中出演张麻子<br>关系三元组：（姜文，出演，让子弹飞），（姜文，导演，让子弹飞）</p><p>SEO：<font color=Green>我</font>出生在<font color=Green>河南</font>，<font color=Green>郑州</font><br>关系三元组：（我，出生地，河南），（我，出生地，郑州），（郑州，是…省会，河南）</p><blockquote><p>EPO:EntityPairOverlap<br>SEO:SingleEntityOverlap overlapping patterns.</p></blockquote><p>面对上面的三元组重叠问题，现有方法都不能很好的解决。</p><p>具体来说，它们都将关系视为分配给实体对的离散标签。这个公式使关系分类成为一个困难的机器学习问题。<strong>首先，类分布高度不平衡</strong>。在所有提取的实体对中，大多数都没有形成有效的关系，产生了太多的反面例子。<strong>其次，当同一实体参与多个有效关系（重叠三元组）时，分类器可能会混淆。</strong>如果没有足够的训练样本，分类器很难分辨出实体参与了哪个关系。因此，提取的三元组是通常不完整和不准确。</p><p>这就体现出来CASREL牛逼的地方了，别人不能解决的，他行啊。</p><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><p>该框架的核心是全新的观点，即我们可以将关系建模为将主体映射到对象的函数，而不是将关系视为实体对上的离散标签。这完全颠覆了以往的离散思想，而是把关系作为函数进行训练。更准确地说，我们<strong>不是学习关系分类器 f(s, o) → r</strong>，而是<strong>学习关系特定标记器 fr(s) → o，</strong>每个标记器都识别特定关系下给定实体s的可能对象；或不返回对象，表示有没有给定实体s和关系的三元组。</p><p>在这个框架下，三重提取是一个两步过程：</p><p><strong>1.我们识别一个句子中所有可能的实体s；</strong></p><p><strong>2.对于每个实体s，我们应用关系特定的标记器来同时识别所有可能的关系和相应的对象。</strong></p><p>CASREL框架将实现上述步骤。它由一个<strong>BERT 模块</strong>、一个<strong>subject标记模块</strong>和一个<strong>特定于关系的object标记模块</strong>组成。</p><h4 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h4><blockquote><p>到了头疼的公式推导环节，非战斗人员请撤离</p></blockquote><p>给定注释的句子 xj 从训练集 D 和一组可能重叠的xj 中的三元组 Tj = {(s, r, o)} ：<br><img src="https://user-images.githubusercontent.com/73998546/182838469-44b3758e-663c-4592-becf-15da5e316150.png" alt="公式推导"><br>第二步应用了概率的链式法则方程。第三步，我们应该承认：<strong>对于一个给定的主题 s，与 s 相关的任何关系（Tj |s 中的那些）会导致句子中出现对应的宾语，并且所有其他关系必然没有句子中的宾语，即“空”宾语。</strong></p><p>我们的目的是把公式（3）的每一块尽量提高，以保证最后结果最大。（即最大化训练集 D 的数据似然度）</p><h4 id="模型框架"><a href="#模型框架" class="headerlink" title="模型框架"></a>模型框架</h4><p>事实上，这种新颖的标记方案使我们能够一次提取多个三元组：我们首先运行subject标记器以查找句子中所有可能的subject，然后对于找到的每个subject，应用特定于关系的object标记器以查找所有相关的关系和对应的object。<br><img src="https://user-images.githubusercontent.com/73998546/182839709-7f967c70-5bc1-4fb4-9268-81e0a9a7ee8c.png" alt="模型框架"></p><blockquote><p>An overview of the proposed CASREL framework. In this example, there are three candidate subjects detected at the low level, while the presented 0/1 tags at high level are specific to the first subject Jackie R. Brown, i.e., a snapshot of the iteration state when k = 1 is shown as above. For the subsequent iterations (k = 2, 3), the results at high level will change, reflecting different triples detected. For instance, when k = 2, the high-level orange (green) blocks will change to 0 (1), respectively, reflecting the relational triple (Washington, Capital of,United States Of America) led by the second candidate subject Washington.</p></blockquote><h5 id="BERT-ENCODER"><a href="#BERT-ENCODER" class="headerlink" title="BERT ENCODER"></a>BERT ENCODER</h5><p><img src="https://user-images.githubusercontent.com/73998546/182840186-999b5114-8c15-48db-9018-2553e2ce7409.png" alt=" "><br>其中 S 是输入句子中子词索引的 one-hot 向量矩阵，Ws 是子词嵌入矩阵，Wp是位置嵌入矩阵，其中 p 表示位置输入序列中的索引，hα是隐藏状态<br>向量，即输入句子在第α层的上下文表示，N是Transformer块的数量。</p><p><code>输入：单个文本句子</code><br><code>输出：综合文本信息的单词向量矩阵</code></p><h5 id="Cascade-Decoder"><a href="#Cascade-Decoder" class="headerlink" title="Cascade Decoder"></a>Cascade Decoder</h5><p>首先，我们从输入句子中检测主体s。 然后对于每个候选主体s，我们检查所有可能的关系，看看是否有关系可以将句子中的对象与该主体s相关联。<br>这又分为两个模块</p><h6 id="1-Subject-Tagger"><a href="#1-Subject-Tagger" class="headerlink" title="1.Subject Tagger"></a>1.Subject Tagger</h6><p>通过直接解码 N 层 BERT 编码器产生的编码向量 hN 来识别输入句子中所有可能的主体。<br>它采用两个相同的二元分类器来检测对象的开始和结束位置，如果概率超过某个特定阈值，则标记为 1，否则标签 0<br><img src="https://user-images.githubusercontent.com/73998546/182840329-1412ccd7-bbf6-4a23-8200-8aa8c167d459.png" alt=" "><br>W是训练权重，xi=hn[i],b是偏差，derta是激活函数<br>此外论文中还提到了实体跨度的监测，在此不再赘述</p><h6 id="2-Relation-specific-Object-Taggers"><a href="#2-Relation-specific-Object-Taggers" class="headerlink" title="2.Relation-specific Object Taggers"></a>2.Relation-specific Object Taggers</h6><p>所有对象标记器object taggers将同时为每个检测到的对象识别相应的对象。<br><img src="https://user-images.githubusercontent.com/73998546/182840360-96fc9871-1cb1-479a-844a-66a8e751e566.png" alt=" "></p><p>参考论文<br><a href="https://arxiv.org/pdf/1909.03227.pdf">A Novel Cascade Binary Tagging Framework for Relational Triple Extraction</a></p>]]></content>
    
    
    <categories>
      
      <category>NER</category>
      
      <category>RE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NER</tag>
      
      <tag>RE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BERT-BiLSTM-CRF</title>
    <link href="/posts/7a6a6b5a.html"/>
    <url>/posts/7a6a6b5a.html</url>
    
    <content type="html"><![CDATA[<h1 id="BERT-BiLSTM-CRF模型分析"><a href="#BERT-BiLSTM-CRF模型分析" class="headerlink" title="BERT-BiLSTM-CRF模型分析"></a>BERT-BiLSTM-CRF模型分析</h1><p>上学期搞大创的时候接触了NER相关的模型和知识，暑假终于有时间整理一下乐</p><p>首先先了解一下BERT-BiLSTM-CRF的应用场景，这种方法主要用于命名实体识别。简单来讲，就是在一段语料中抽出其中的名词进行划分。<br>先上例子，以提取公司企业和人物实体为例：</p><p><code>输入： &#123;&quot;text&quot;: &quot;作为蔚来汽车的 a 轮投资人，刘二海已经是第二次见证李斌在纽交所敲钟，第一次是李斌创办的易车在纽交所上市。&#125;</code><br><code>输出： &#123;&quot;label&quot;: &#123;&quot;person&quot;: &#123;&quot;刘二海&quot;: [13, 15]&#125;, &quot;org&quot;: &#123;&quot;蔚来汽车&quot;: [2，5]&#125;&#125;&#125;</code></p><p>输入一段文本 text，输出的标签为句子中的organization 和 person 实体</p><p>需要明确的是，BERT-BiLSTM-CRF是有监督分类问题，训练语料一定要给出训练文本对应的标注。</p><p>那么我们如何从一段语料中“聪明地”获取实体并打上标签呢？<br>上模型！</p><h3 id="模型框架"><a href="#模型框架" class="headerlink" title="模型框架"></a>模型框架</h3><p><img src="https://user-images.githubusercontent.com/73998546/182521959-df17f189-c427-4a99-a38b-1b52ce78de4e.png" alt="模型框架"></p><p>BERT-CRF 模型由 3 个模块组成。首先使用 BERT 模型获取字向量，提<br>取文本重要特征；之后由 BiLSTM 层对 BERT 的输出序列处理，通过双向 LSTM 计算输入隐藏信息；<br>在CRF层，结合 CRF 中的状态转移矩阵，根<br>据相邻之间标签得到一个全局最优序列。</p><h4 id="BERT层"><a href="#BERT层" class="headerlink" title="BERT层"></a>BERT层</h4><p>模型第一层是利用预训练的 BERT 语言模型初始化获取输入文本信息中的字向量记为<br>序列 E=(e1,e2,e3,⋯ ,en) , 所获取的字向量能够利用词与词之间的相互关<br>系</p><p>BERT 是一种自然语言处理预训练语言表征模型. BERT 能够计算词语之间的相互关系, 并利用所计算的关系调节权重提取文本中的重要特征, 利用自注意力机制的结构来进行预<br>训练, 基于所有层融合左右两侧语境来预训练深度双向表征, 比起以往的预训练模型, 它捕<br>捉到的是真正意义上的上下文信息, 并能够学习到连续文本片段之间的关系.</p><h4 id="BiLSTM"><a href="#BiLSTM" class="headerlink" title="BiLSTM"></a>BiLSTM</h4><p>想要知道BiLSTM是什么，需要先了解LSTM是干嘛的</p><p>LSTM 长短期记忆网络<br>是一种特殊的循环神经网络。RNN 网络主要包括输入层、隐藏层和输出层三部分组成，<br>隐藏层连接前后两层，这种特殊的结构，能让 RNN 网络具有一定的“记忆能力，能够有效<br>处理命名实体识别任务。</p><h5 id="LSTM框架"><a href="#LSTM框架" class="headerlink" title="LSTM框架"></a>LSTM框架</h5><p><img src="https://user-images.githubusercontent.com/73998546/182525122-b3fe78f8-650e-419b-9b72-7ba250c895db.png" alt="LSTM框架"><br>LSTM模型可以理解为：现在有一串细胞代表着不同时刻的状态（C0，C1…Ct），他们是串联关系。在t时刻，你有三个输入，分别为上一细胞状态Ct-1、隐藏层ht-1和输入词Xt。在经过细胞Ct后，你将得到本细胞的隐藏信息ht和此时新的细胞状态Ct。<br>在每个细胞中具体有遗忘门，记忆门和输出门，让我们看看这些可爱的小细胞是如何工作的吧</p><p><strong>计算过程</strong><br>计算过程的思路就是，将遗忘信息和新的信息整合起来，得到有用的信息传递给下一细胞，同时丢弃无用信息。并在每一时刻输出隐层状态ht，ht相当于一个中间参数，参与到下一层的信息计算中。</p><ul><li><p>计算<strong>遗忘门</strong><br><code>输入：前一时刻隐藏状态ht-1,输入词Xt</code><br><code>输出：遗忘门的值ft</code><br><img src="https://user-images.githubusercontent.com/73998546/182526393-185580bb-f2f9-45bf-97bd-59b6785bf134.png" alt="遗忘门"></p></li><li><p>计算<strong>记忆门</strong><br><code>输入：前一时刻隐藏状态ht-1,输入词Xt</code><br><code>输出：记忆门的值it，临时细胞状态Ct</code><br><img src="https://user-images.githubusercontent.com/73998546/182526419-d7ee10bb-90cb-437a-91c1-30a965ddd351.png" alt="记忆门"></p></li><li><p>更新<strong>细胞状态</strong><br><code>输入：记忆门的值it，遗忘门的值ft，上一细胞状态Ct-1，临时细胞状态Ct</code><br><code>输出：当前细胞状态Ct</code><br><img src="https://user-images.githubusercontent.com/73998546/182526444-b82c367d-ef01-4241-a43f-a6d82012efef.png" alt="细胞状态更新"></p></li><li><p>计算<strong>隐藏层</strong><br><code>输入：前一时刻隐藏状态ht-1,输入词Xt ，当前细胞状态Ct</code><br><code>输出：隐层状态ht</code><br><img src="https://user-images.githubusercontent.com/73998546/182526465-c75c0560-5471-4e96-8188-0d826f189c57.png" alt="最后输出"></p></li></ul><p>一顿操作下来，我们得到了和原始句子一样长的隐层状态序列[h0,h1…hn-1]</p><h5 id="BiLSTM框架"><a href="#BiLSTM框架" class="headerlink" title="BiLSTM框架"></a>BiLSTM框架</h5><p>知道了LSTM的计算流程，他是从一个方向得到状态序列。进一步想，我们如果从两个方向（从左到右，从右到左）进行LSTM的运算，并将两个结果合并，是否能得到更全面的语义信息呢</p><p>SMART GUY!这就是BiLSTM的思路。</p><p><img src="https://user-images.githubusercontent.com/73998546/182528230-0d562287-b91b-42eb-928b-660ed09b89f2.png" alt="BiLSTM框架"><br>我们对一句话进行两个方向的LSTM计算，最后将两者捏在一起。这样每个词和前后的词都存在关联性，在ner中能表现出更好的性能。</p><h4 id="CRF层"><a href="#CRF层" class="headerlink" title="CRF层"></a>CRF层</h4><p>CRF 用来分割和标记序列数据, 根据输入的观察序列来预测对应的状态序列, 同时考<br>虑输入的当前状态特征和各个标签类别转移特征, 被广泛应用于 NER 的问题中.</p><p><img src="https://user-images.githubusercontent.com/73998546/182520083-e46c0fd1-f27d-409a-8a49-b4a2d5ffb3de.png" alt="CRF层"><br>如上图可知，BiLSTM层输出全文的向量表示后，得到这个词对应每个标签的权重。<br>CRF层会选取权重较高的标签，注意不是最高。他还会从训练数据中学习约束，确保选取标签的合理性。<br>CRF 层可以为最终预测的标签添加一些约束（如句子中第一个单词的标签应该以“B-”或“O”开头，而不是“I-”、“B-label1 I-label2 I-label3 I-…”，<br>在这个模式中，label1、label2、label3…应该是同一个命名实体标签），以减少无效预测标签序列的数量。这些约束可以在训练过程中由 CRF 层自动从训练数据集中学习。<br><em>约束可能是：<br>句子中第一个单词的标签应该以“B-”或“O”开头，而不是“I-” “B-label1 I-label2 I-label3 I-…”，在这个模式中，label1、label2、label3…应该是同一个命名实体标签。例如，“B-Person I-Person”有效，但“B-Person I-Organization”无效。<br>“O I-label”无效。一个命名实体的第一个标签应该以“B-”而不是“I-”开头，换句话说，有效模式应该是“O B-label</em></p><p>再回头梳理一遍<strong>模型IO</strong><br><code>原始输入：语句文本</code><br><strong>BERT 层</strong>：<br><code>输入：</code><br>①由原始文本利用 word2Vector 等算法得到的原始字向量<br>②文本向量：该向量的取值在模型训练过程中自动学习，用于刻画文本的全局语义信息，<br>并与单字/词的语义信息相融合<br>③位置向量：刻画不同位置的字，对不同位置的字附加一个不同的向量加以区分<br><code>输出：文本中各个字融合了全文语义信息后的向量表示</code><br><strong>BiLSTM层</strong>：<br><code>输入：BERT 模型的输出序列</code><br><code>输出：每个字对应的标签权重</code><br><strong>CRF 层</strong>：<br><code>输入：每个字对应的标签权重</code><br><code>输出：预测的标签序列</code><br><img src="https://user-images.githubusercontent.com/73998546/182521959-df17f189-c427-4a99-a38b-1b52ce78de4e.png" alt=" "><br>复习一下前面的图~<br>over</p>]]></content>
    
    
    <categories>
      
      <category>NER</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NER</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SAT问题及DPLL简述</title>
    <link href="/posts/935b2a8c.html"/>
    <url>/posts/935b2a8c.html</url>
    
    <content type="html"><![CDATA[<h2 id="聊聊SAT问题是什么"><a href="#聊聊SAT问题是什么" class="headerlink" title="聊聊SAT问题是什么"></a>聊聊SAT问题是什么</h2><blockquote><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3></blockquote><p>SAT问题又称命题逻辑公式的可满足性问题（satisfiability problem），是判断对合取范式形式给出的命题逻辑公式是否存在一个真值指派使得该逻辑公式为真。SAT问题是计算机科学与人工智能基本问题，是一个典型的NP完全问题。看似简单，却可广泛应用于许多实际问题如人工智能、电子设计自动化、自动化推理、硬件设计、安全协议验证等，具有重要理论意义与应用价值。对于SAT问题的研究从没有停止过，在1997年和2003年，H.Kautz与B.Selman两次列举出SAT搜索面临的挑战性问题，并于2011年和2007年，两度对当时的SAT问题研究现状进行了全面的综述。黄文奇提出的Solar算法在北京第三届SAT问题快速算法比赛中获得第一名。对SAT问题的求解主要有完备算法和不完备算法两大类。不完备算法主要是局部搜索算法，这种算法不能保证一定找到解，但是求解速度快，对于某些SAT问题的求解，局部搜索算法要比很多完备算法更有效。完备算法出现的时间更早，优点是可以正确判断SAT问题的可满足性，在算例无解的情况下可以给出完备的证明。对于求解SAT问题的优化算法主要有启发式算法、冲突子句学习算法、双文字监视法等。</p><blockquote><h3 id="研究意义"><a href="#研究意义" class="headerlink" title="研究意义"></a>研究意义</h3></blockquote><p>SAT问题是第一个被证明的NP完全问题，而NP完全问题由于其极大的理论价值和困难程度，破解后将会在许多领域得到广泛应用，从而在计算复杂性理论中具有非常重要的地位。由于所有的NP完全问题都能够在多项式时间内进行转换，那么如果SAT问题能够得到高效解决，所有的NP完全问题都能够在多项式时间内得到解决。对SAT问题的求解，可用于解决计算机和人工智能领域内的CSP问题（约束满足问题）、语义信息的处理和逻辑编程等问题，也可用于解决计算机辅助设计领域中的任务规划与设计、三维物体识别等问题。SAT问题的应用领域非常广泛，还能用于解决数学研究和应用领域中的旅行商问题和逻辑算数问题。许多实际问题，例如数据库检索、积木世界规划、超大规模集成电路设计、人工智能等都可以转换成SAT问题进而进行求解。可见对SAT问题求解的研究，具有重大意义。</p><blockquote><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3></blockquote><p>SAT问题即命题逻辑公式的可满足性问题（satisfiability problem），是计算机科学与人工智能基本问题，是一个典型的NP完全问题，可广泛应用于许多实际问题如硬件设计、安全协议验证等，具有重要理论意义与应用价值。SAT问题也是程序设计与竞赛的经典问题。<br>对于任一布尔变元x，x与其非“¬x”称为文字(literal)。对于多个布尔变元，若干个文字的或运算l1∨l2∨…∨lk称为子句(clause)。只含一个文字的子句称为单子句。不含任何文字的子句称为空子句，常用符号□表示。子句所含文字越多，越易满足，空子句不可满足。<br>SAT问题一般可描述为：给定布尔变元集合{x1, x2, …, xn}以及相应的子句集合{c1, c2, …, cm}，对于合取范式（CNF范式）：F = c1∧c2∧…∧cm，判定是否存在对每个布尔变元的一组真值赋值使F为真，当为真时（问题是可满足的，SAT），输出对应的变元赋值（一组解）结果。<br>一个CNF公式也可以表示成子句集合的形式：S={c1,c2,…,cm}.<br>例如，由三个布尔变元a,b,c所形成的一个CNF公式（¬a∨b）∧（¬b∨c）,可用集合表示为{¬a∨b,¬b∨c}，该公式是满足的，a=0, b=0,c=1是其一组解。 </p><blockquote><h3 id="cnf文件解读"><a href="#cnf文件解读" class="headerlink" title="cnf文件解读"></a>cnf文件解读</h3></blockquote><p>一个CNF SAT公式或算例的具体信息通常存储在一个.cnf文件中，下图是算例problem1.cnf文件前若干行的截图。</p><p><img src="https://user-images.githubusercontent.com/73998546/133534700-41b7c5f8-9448-4cea-a079-763b69aa4988.png" alt="1(1)"></p><p>在每个CNF文件的开始，由‘c’开头的是若干注释说明行；‘p’开头的行说明公式的总体信息，包括：范式为CNF；公式有200个布尔变元，由1到200的整数表示；320个子句。之后每行对应一个子句，0为结束标记。46表示第46号变元，且为正文字；-46则是对应的负文字，文字之间以空格分隔。</p><p>DPLL算法是经典的SAT完备型求解算法，对给定的一个SAT问题实例，理论上可判定其是否满足，满足时可给出对应的一组解。</p><h2 id="DPLL算法是什么呢"><a href="#DPLL算法是什么呢" class="headerlink" title="DPLL算法是什么呢"></a>DPLL算法是什么呢</h2><p>DPLL算法是基于树/二叉树的回溯搜索算法，主要使用两种基本处理策略：</p><p>单子句规则。如果子句集S中有一个单子句L,那么L一定取真值，于是可以从S中删除所有包含L的子句（包括单子句本身），得到子句集S1，如果它是空集，则S可满足。否则对S1中的每个子句，如果它包含文字¬L,则从该子句中去掉这个文字，这样可得到子句集合S2。S可满足当且仅当S2可满足。单子句传播策略就是反复利用单子句规则化简S的过程。</p><p>分裂策略。按某种策略选取一个文字L.如果L取真值，则根据单子句传播策略，可将S化成S2；若L取假值（即¬L成立）时，S可化成S1.</p><p>交错使用上述两种策略可不断地对公式化简，并最终达到终止状态，其执行过程可表示为一棵二叉搜索树,如下图所示。</p><p><img src="https://user-images.githubusercontent.com/73998546/133535483-b924184a-7b00-4034-9e67-5489e8e7cec1.png" alt="1(2)"></p><p>基于单子句传播与分裂策略的DPLL算法可以描述为一个如后所示的递归过程DPLL( S ), DPLL算法也可用非递归实现。</p><div class="hljs code-wrapper"><pre><code>DPLL( S) :/* S为公式对应的子句集。若其满足，返回TURE；否则返回FALSE. */&#123;while(S中存在单子句) &#123;//单子句传播在S中选一个单子句L；依据单子句规则，利用L化简S；if S = Φ return(TRUE);else if (S中有空子句 ) return（FALSE）；&#125;//while基于某种策略选取变元v；         //策略对DPLL性能影响很大if DPLL（S ∪v ）return(TURE);  //在第一分支中搜索return DPLL(S ∪¬v);//回溯到对v执行分支策略的初态进入另一分支&#125;</code></pre></div><p>对于公式{¬1∨2, ¬2，¬3∨4, 3∨¬5,3∨4, 3∨5，¬2∨¬5∨6} ,大家可以利用DPLL算法进行手动推理其搜索处理及回溯过程，获得求解结果。</p>]]></content>
    
    
    <categories>
      
      <category>由SAT问题引发的小思考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA相关</title>
    <link href="/posts/5504c575.html"/>
    <url>/posts/5504c575.html</url>
    
    <content type="html"><![CDATA[<h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>发生在类的继承中，这个方法子和父名称一样，子生效<br><a name="44XsM"></a></p><h3 id="重写（override）规则："><a href="#重写（override）规则：" class="headerlink" title="重写（override）规则："></a>重写（override）规则：</h3><ol><li>参数列表必须完全与被重写方法相同</li><li>返回类型必须完全与被重写的返回类型相同</li><li>访问权限不能比父类中被重写的访问权限更低。例如：如果父类的一个方法被声明为public，name子类中重写该方法就不能声明为protected</li><li>父类的成员方法只能被他的子类重写</li><li>声明为static和private的方法不能被重写，但是能够被再次声明<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> stsic <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Student s = <span class="hljs-keyword">new</span> Student();<br>        s.say();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span>&#123;<br>        System.<span class="hljs-function">out <span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;锄禾日当午，汗滴禾下土&quot;</span>)</span></span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">class Student extends Person</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;床前明月光&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><p><a name="Gotao"></a></p><h4 id="注意：面试题：Java中重写（override）和重载（overland）的区别"><a href="#注意：面试题：Java中重写（override）和重载（overland）的区别" class="headerlink" title="注意：面试题：Java中重写（override）和重载（overland）的区别"></a>注意：面试题：Java中重写（override）和重载（overland）的区别</h4><ol><li>重写是发生在子父类中的操作</li><li>重载是一个类里面参数列表的长度、参数类型和参数类型顺序不同（分为构造方法重载和方法重载）</li></ol><p>a. 发生的位置<br />重载：一个类中<br />重写：子父类中<br />b. 参数列表限制<br />重载：必须不同<br />重写：必须相同<br />c. 返回值类型：<br />重载：与返回值类型无关<br />重写：返回值类型必须一致<br />d. 访问权限：<br />重载：与访问权限无关<br />重写： 子的方法权限 必须不能小于 父的方法权限<br />e.异常（bug）处理：<br />重载：与异常无关<br />重写：可以减少或删除（异常范围可以更小更精准，但是不能抛出新的异常）<br /><br><br /></p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>情况描述：当程序出现bug时，Java虚拟机发现异常，虚拟机就会new出来一个新的对象，用类似返回的方式返回错误类型和异常原因，同时中断程序。</p><h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><p>对异常进行处理，捕获异常，避免异常返回使程序中断</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//有可能发生异常的代码</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">1</span> 对象名<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-comment">//异常的操作</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">1</span> 对象名<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-comment">//异常的操作</span><br>&#125;...<br><span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-comment">//异常的统一出口</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>catch语句相当于if语句<br />如果满足异常类型，则实现代码块里面的操作<br /><br><br />易错警告<br />eg1.</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.java.demo1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Person p =haha();<br>        System.out.println(p.age);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Person <span class="hljs-title">haha</span><span class="hljs-params">()</span></span>&#123;<br>        Person p = <span class="hljs-keyword">new</span> Person();<br>       <span class="hljs-keyword">try</span>&#123;<br>           p.age = <span class="hljs-number">18</span>;<br>           <span class="hljs-keyword">return</span> p;<br>       &#125;<span class="hljs-keyword">finally</span>&#123;<br>           p.age = <span class="hljs-number">28</span>;<br>       &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>        <span class="hljs-keyword">int</span> age;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//始终是一个对象，最后执行finally，p.age年龄被更改</span><br></code></pre></div></td></tr></table></figure><p>eg2.</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.java.demo1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> a =haha();<br>        System.out.println(a);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">haha</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;<span class="hljs-keyword">finally</span>&#123;<br>            a = <span class="hljs-number">20</span>;<br>        &#125;<br><br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//return a;中的a是被备份的那个</span><br><span class="hljs-comment">//实际上又开辟了一块内存空间，这是返回的a和finally中的赋值的a无关</span><br></code></pre></div></td></tr></table></figure><p>eg3.</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.java.demo1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        haha();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">haha</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;<br>            System.out.println(a/b);<br>        &#125;<br>        <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            <span class="hljs-comment">//退出JVM</span><br>            System.exit(<span class="hljs-number">0</span>);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;锄禾日当午，汗滴禾下土&quot;</span>);<br><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>唯一一种在代码中使finally不执行的代码就是上述eg3.<br /> System.exit(0);<br />总结：finally问题总绕不开两点：<br />1.finally必然执行<br />2.return的时机以及备份的具体内容</p><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>final用于修饰属性、变量<br />变量成为了常量，无法对其再次进行赋值<br />final修饰的局部变量，只能赋值一次（可以先声明后赋值）<br />final修饰的是成员属性，必须在声明时赋值<br />全局常量（public static final）<br /><br><br />常量的命名规范：<br />由一个或多个单词组成，单词与单词之间必须使用下划线隔开，单词中所有字母大写<br />例如：SQL_INSET<br /><br><br /><br><br />final用于修饰类<br />final修饰的类，不可以被继承<br />final用于修饰方法<br />final修饰的方法，不能被子类重写<br />全局常量（public static final）<br /></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>github访问加速</title>
    <link href="/posts/ceb1ca5c.html"/>
    <url>/posts/ceb1ca5c.html</url>
    
    <content type="html"><![CDATA[<h2 id="通过修改HOSTS文件进行加速"><a href="#通过修改HOSTS文件进行加速" class="headerlink" title="通过修改HOSTS文件进行加速"></a>通过修改HOSTS文件进行加速</h2><p>参考如下介绍</p><hr><h3 id="为什么github下载速度这么龟？"><a href="#为什么github下载速度这么龟？" class="headerlink" title="为什么github下载速度这么龟？"></a>为什么github下载速度这么龟？</h3><p>GitHub 我们都知道是世界上最大的开源及私有软件项目的托管平台，全世界每天有海量优秀的开源软件在这里产生，而 GitHub 在国内很多时候获取到的下载链接是亚马逊的服务器。</p><span id="more"></span><p>国内访问github，经常抽疯或龟速。</p><h3 id="如何提高github的下载速度？"><a href="#如何提高github的下载速度？" class="headerlink" title="如何提高github的下载速度？"></a>如何提高github的下载速度？</h3><p>手动把cdn和ip地址绑定。</p><h3 id="第一步：访问：这里-获取cdn和ip域名"><a href="#第一步：访问：这里-获取cdn和ip域名" class="headerlink" title="第一步：访问：这里 获取cdn和ip域名"></a>第一步：访问：<a href="http://github.global.ssl.fastly.net.ipaddress.com/#ipinfo">这里</a> 获取cdn和ip域名</h3><h3 id="第二步：获取github的global-ssl-fastly地址"><a href="#第二步：获取github的global-ssl-fastly地址" class="headerlink" title="第二步：获取github的global.ssl.fastly地址"></a>第二步：获取github的global.ssl.fastly地址</h3><p>得到：192.30.255.112</p><h3 id="第三步：获取github-com地址"><a href="#第三步：获取github-com地址" class="headerlink" title="第三步：获取github.com地址"></a>第三步：获取github.com地址</h3><p>得到：185.31.16.184</p><h3 id="第四步：修改host文件映射上面查找到的IP"><a href="#第四步：修改host文件映射上面查找到的IP" class="headerlink" title="第四步：修改host文件映射上面查找到的IP"></a>第四步：修改host文件映射上面查找到的IP</h3><p>windows系统：</p><p>找到C:\Windows\System32\drivers\etc\hosts<br>在<mark>最后写入 </p><p>192.30.255.112  github.com git</p><p>185.31.16.184 github.global.ssl.fastly.net</p><h3 id="第五步：在cmd中输入：ping-github-com即可"><a href="#第五步：在cmd中输入：ping-github-com即可" class="headerlink" title="第五步：在cmd中输入：ping github.com即可"></a>第五步：在cmd中输入：ping github.com即可</h3>]]></content>
    
    
    <categories>
      
      <category>github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实用技能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>build the drawing bed on github</title>
    <link href="/posts/96102aeb.html"/>
    <url>/posts/96102aeb.html</url>
    
    <content type="html"><![CDATA[<p>问题描述：在写第一篇博客时，图片在md文件中能够正常显示，而在网页上浏览时显示上传失败。查了资料发现原因是md中的文件路径使用相对路径，page到网页上时路径失效，找不到本地存图片的文件，因此加载失败。想解决这个问题，需要将本地图片page到网上生成网链（md可辨别的）。</p><span id="more"></span><p>做法：</p><p>1.在github上新建仓库作为图床<br>2.在issue中点击new issues<br><img src="https://user-images.githubusercontent.com/73998546/122338823-cdbeff80-cf72-11eb-98a0-c7af3504da7c.png" alt="1 (1)"></p><p>3.将图片拖入输入框</p><p>4.在preview中可以预览图片样式</p><p>5.在write中生成的链接可以再md中直接应用<br><img src="https://user-images.githubusercontent.com/73998546/122338817-cbf53c00-cf72-11eb-8527-09a51858866b.png" alt="1 (2)"></p><p>完成！撒花✿✿ヽ(°▽°)ノ✿</p>]]></content>
    
    
    <categories>
      
      <category>github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实用技能</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
